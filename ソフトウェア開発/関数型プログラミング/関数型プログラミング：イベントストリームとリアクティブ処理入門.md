---
title: 関数型プログラミング：イベントストリームとリアクティブ処理入門
created: 2025-05-23 14:52:52
updated: 2025-05-24 05:16:24
draft: true
tags:
  - 関数型プログラミング
categories:
  - ソフトウェア設計
---

**目次**

- [関数型プログラミング：イベントストリームとリアクティブ処理入門](#関数型プログラミングイベントストリームとリアクティブ処理入門)
- [はじめに：時間と共に変化する値とどう向き合うか](#はじめに時間と共に変化する値とどう向き合うか)
  - [イベント駆動の世界：現代的アプリケーションの現実](#イベント駆動の世界現代的アプリケーションの現実)
  - [従来のイベント処理の課題：複雑化する状態とコールバック](#従来のイベント処理の課題複雑化する状態とコールバック)
  - [関数型リアクティブプログラミング (FRP) とは？ 新しい視点](#関数型リアクティブプログラミング-frp-とは-新しい視点)
  - [この資料で目指すこと：イベントの「川」をエレガントに操る](#この資料で目指すことイベントの川をエレガントに操る)
- [第 1 部：イベントストリームの基本：非同期データの流れを捉える](#第-1-部イベントストリームの基本非同期データの流れを捉える)
  - [イベントストリーム (Observable) とは何か？](#イベントストリーム-observable-とは何か)
  - [ストリームの 3 つの要素：値 (Next), エラー (Error), 完了 (Complete)](#ストリームの-3-つの要素値-next-エラー-error-完了-complete)
  - [ストリームの生成：イベントの源を作る](#ストリームの生成イベントの源を作る)
    - [DOM イベントから](#dom-イベントから)
    - [配列や Promise から](#配列や-promise-から)
    - [タイマー (interval, timer) から](#タイマー-interval-timer-から)
    - [カスタムストリームの作成](#カスタムストリームの作成)
  - [ストリームの購読 (Subscription)：流れを受け止める](#ストリームの購読-subscription流れを受け止める)
    - [`subscribe` メソッドと Observer](#subscribe-メソッドと-observer)
    - [購読の解除とリソース管理の重要性](#購読の解除とリソース管理の重要性)
  - [コールドストリーム vs ホットストリーム：購読時の振る舞いの違い](#コールドストリーム-vs-ホットストリーム購読時の振る舞いの違い)
- [第 2 部：ストリーム操作の基礎：高階関数的な演算子](#第-2-部ストリーム操作の基礎高階関数的な演算子)
  - [FRP における「演算子 (Operator)」とは？](#frp-における演算子-operatorとは)
    - [ストリームを変換・合成する純粋関数的な道具](#ストリームを変換合成する純粋関数的な道具)
    - [入力ストリームから新しい出力ストリームを生成する](#入力ストリームから新しい出力ストリームを生成する)
  - [変換系演算子：ストリームの値を形作る](#変換系演算子ストリームの値を形作る)
    - [`map`：各値を変換する](#map各値を変換する)
    - [`pluck`：特定のプロパティを抽出する](#pluck特定のプロパティを抽出する)
    - [`mapTo`：固定値に置き換える](#mapto固定値に置き換える)
    - [`scan`：値を累積・集約しながら発行する](#scan値を累積集約しながら発行する)
  - [フィルタリング系演算子：必要な値だけを選び出す](#フィルタリング系演算子必要な値だけを選び出す)
    - [`filter`：条件に合う値だけを通す](#filter条件に合う値だけを通す)
    - [`take` / `takeLast` / `takeUntil` / `takeWhile`：特定の条件まで値を取得する](#take--takelast--takeuntil--takewhile特定の条件まで値を取得する)
    - [`skip` / `skipLast` / `skipUntil` / `skipWhile`：特定の条件まで値を無視する](#skip--skiplast--skipuntil--skipwhile特定の条件まで値を無視する)
    - [`first` / `last`：最初/最後の値だけを取得する](#first--last最初最後の値だけを取得する)
    - [`distinct` / `distinctUntilChanged`：重複を排除する](#distinct--distinctuntilchanged重複を排除する)
  - [合成系演算子：複数のストリームを組み合わせる](#合成系演算子複数のストリームを組み合わせる)
    - [`merge`：複数のストリームを一つにまとめる（発行順はそのまま）](#merge複数のストリームを一つにまとめる発行順はそのまま)
    - [`concat`：複数のストリームを順番に繋げる](#concat複数のストリームを順番に繋げる)
    - [`combineLatest`：複数のストリームの最新値を組み合わせて発行する](#combinelatest複数のストリームの最新値を組み合わせて発行する)
    - [`zip`：複数のストリームの値をペア（タプル）にして発行する](#zip複数のストリームの値をペアタプルにして発行する)
    - [`forkJoin`：複数のストリームがすべて完了した時点で最後の値の組を発行する (`Promise.all` に似る)](#forkjoin複数のストリームがすべて完了した時点で最後の値の組を発行する-promiseall-に似る)
  - [高階マッピング演算子（内部ストリームの扱い）：非同期処理の連鎖をフラットに](#高階マッピング演算子内部ストリームの扱い非同期処理の連鎖をフラットに)
    - [`mergeMap` (または `flatMap`)：各値を新しいストリームに変換し、結果をマージする](#mergemap-または-flatmap各値を新しいストリームに変換し結果をマージする)
    - [`switchMap`：各値を新しいストリームに変換し、新しい値が来たら前の内部ストリームをキャンセルする](#switchmap各値を新しいストリームに変換し新しい値が来たら前の内部ストリームをキャンセルする)
    - [`concatMap`：各値を新しいストリームに変換し、結果を順番に繋げる](#concatmap各値を新しいストリームに変換し結果を順番に繋げる)
    - [`exhaustMap`：各値を新しいストリームに変換するが、前の内部ストリームが完了するまで新しい値は無視する](#exhaustmap各値を新しいストリームに変換するが前の内部ストリームが完了するまで新しい値は無視する)
  - [時間制御系演算子：イベントのタイミングを操る](#時間制御系演算子イベントのタイミングを操る)
    - [`delay` / `delayWhen`：発行を遅延させる](#delay--delaywhen発行を遅延させる)
    - [`debounceTime` / `debounce`：連続するイベントを間引く（最後の安定した値）](#debouncetime--debounce連続するイベントを間引く最後の安定した値)
    - [`throttleTime` / `throttle`：一定期間内の最初の（または最後の）イベントだけを通す](#throttletime--throttle一定期間内の最初のまたは最後のイベントだけを通す)
    - [`auditTime` / `audit`：一定期間ごとに最新の値を発行する](#audittime--audit一定期間ごとに最新の値を発行する)
    - [`sampleTime` / `sample`：一定期間ごとに最新の値を取得する](#sampletime--sample一定期間ごとに最新の値を取得する)
    - [`timeout` / `timeoutWith`：タイムアウト処理](#timeout--timeoutwithタイムアウト処理)
    - [`buffer` / `bufferTime` / `bufferCount` / `bufferToggle` / `bufferWhen`：値をバッファリングする](#buffer--buffertime--buffercount--buffertoggle--bufferwhen値をバッファリングする)
    - [`window` / `windowTime` / `windowCount` / `windowToggle` / `windowWhen`：値をウィンドウ（別の Observable）に分割する](#window--windowtime--windowcount--windowtoggle--windowwhen値をウィンドウ別の-observableに分割する)
  - [エラーハンドリング演算子：失敗に備える](#エラーハンドリング演算子失敗に備える)
    - [`catchError` (または `onErrorResumeNext`)：エラー発生時に別のストリームに切り替えるか、エラーを処理する](#catcherror-または-onerrorresumenextエラー発生時に別のストリームに切り替えるかエラーを処理する)
    - [`retry` / `retryWhen`：エラー発生時にストリームの購読を再試行する](#retry--retrywhenエラー発生時にストリームの購読を再試行する)
  - [ユーティリティ演算子](#ユーティリティ演算子)
    - [`tap` (または `do`)：副作用（ロギングなど）を実行する](#tap-または-do副作用ロギングなどを実行する)
    - [`finalize` (または `tap({ complete, error })`)：ストリーム完了時またはエラー時に処理を実行する](#finalize-または-tap-complete-error-ストリーム完了時またはエラー時に処理を実行する)
    - [`count`：発行された値の総数を数える](#count発行された値の総数を数える)
    - [`toArray`：ストリームのすべての値を配列にして発行する](#toarrayストリームのすべての値を配列にして発行する)
- [第 3 部：FRP の実践的な活用と設計パターン](#第-3-部frp-の実践的な活用と設計パターン)
  - [UI プログラミングにおける FRP：イベント駆動 UI の構築](#ui-プログラミングにおける-frpイベント駆動-ui-の構築)
    - [状態管理とデータバインディング](#状態管理とデータバインディング)
    - [複雑なユーザーインタラクションの宣言的な記述](#複雑なユーザーインタラクションの宣言的な記述)
  - [非同期データフローの管理：API 呼び出しとキャッシュ戦略](#非同期データフローの管理api-呼び出しとキャッシュ戦略)
  - [バックプレッシャー：データの洪水を制御する（再訪と具体的な戦略）](#バックプレッシャーデータの洪水を制御する再訪と具体的な戦略)
  - [マルチキャスト：複数の購読者でストリームを共有する](#マルチキャスト複数の購読者でストリームを共有する)
    - [`multicast`, `publish`, `share`, `shareReplay` 演算子](#multicast-publish-share-sharereplay-演算子)
  - [カスタム演算子の作成：再利用可能な処理の抽象化](#カスタム演算子の作成再利用可能な処理の抽象化)
  - [テスト：リアクティブなコードをどうテストするか](#テストリアクティブなコードをどうテストするか)
    - [Marble Diagram を使ったテストの考え方](#marble-diagram-を使ったテストの考え方)
    - [テストスケジューラと時間制御](#テストスケジューラと時間制御)
- [第 4 部：FRP のエコシステムとさらに学ぶために](#第-4-部frp-のエコシステムとさらに学ぶために)
  - [代表的な FRP ライブラリの比較と特徴（RxJS, Reactor, Akka Streams など再訪）](#代表的な-frp-ライブラリの比較と特徴rxjs-reactor-akka-streams-など再訪)
  - [FRP と他のパラダイム（Actor モデル、CSP など）との関係](#frp-と他のパラダイムactor-モデルcsp-などとの関係)
  - [学習リソースとコミュニティ](#学習リソースとコミュニティ)
- [おわりに：イベントの波を乗りこなす、リアクティブな思考へ](#おわりにイベントの波を乗りこなすリアクティブな思考へ)

# 関数型プログラミング：イベントストリームとリアクティブ処理入門

# はじめに：時間と共に変化する値とどう向き合うか

若手エンジニアの皆さん、これまでの関数型プログラミングの学習では、主に静的なデータや、一回限りの計算結果を扱うためのテクニックを中心に学んできましたね。純粋関数、不変データ、Future/Promise といった概念は、コードの安全性や予測可能性を高める上で非常に強力です。

しかし、私たちが開発する現代のアプリケーションは、それだけでは完結しません。ユーザーのクリック、マウスの動き、キーボード入力、センサーからのリアルタイムなデータ、サーバーからのプッシュ通知、株価の変動…。私たちの周りには、**時間とともに次々と、そして非同期的に発生する「イベント」や「変化する値」**が溢れています。

これらの「時間の流れの中で発生するデータ」を、従来の命令的なプログラミングスタイル（例えば、イベントリスナーを個別に設定し、コールバック関数で状態を管理するような方法）で扱おうとすると、しばしばコードは複雑化し、状態管理は煩雑になり、処理の流れを追うのが困難になるという問題に直面します。

## イベント駆動の世界：現代的アプリケーションの現実

ユーザーインターフェースを持つアプリケーションはもちろんのこと、サーバーサイドシステムにおいても、外部システムとの連携、リアルタイムなデータ処理、メッセージキューを介した非同期通信など、システムは何らかの「イベント」に応答 (React) しながら動作することが当たり前になっています。

このような**イベント駆動型 (Event-Driven)** のシステムにおいて、

- 複数のイベントソースからの入力をどのように整理し、
- それらのイベントのシーケンス（順序やタイミング）をどのように扱い、
- イベント間の複雑な依存関係や組み合わせをどのように表現し、
- そして、それらに対する応答（処理）をどのように効率的かつ宣言的に記述するか、

という課題は、ソフトウェア設計における重要なテーマです。

## 従来のイベント処理の課題：複雑化する状態とコールバック

伝統的なイベント処理では、イベントの種類ごとにコールバック関数を登録し、そのコールバック関数の中で状態変数を更新したり、さらに別の処理を呼び出したり、といったアプローチが取られることが一般的でした。

しかし、イベントの種類が増えたり、イベント間の連携が複雑になったりすると、

- 多数のコールバック関数が散在し、全体の処理フローが見えにくくなる。
- 状態変数が複数のコールバックから変更される可能性があり、状態管理が複雑化し、バグの原因となりやすい。
- 非同期処理の完了を待って次の処理を行う、といった順序制御が「コールバック地獄」を引き起こしやすい。
- エラーハンドリングやリソース管理（イベントリスナーの解除など）が煩雑になる。

といった問題が生じがちです。

## 関数型リアクティブプログラミング (FRP) とは？ 新しい視点

「**関数型リアクティブプログラミング (Functional Reactive Programming - FRP)**」は、これらの課題に対する、関数型プログラミングの原則に基づいたエレガントな解決策を提案するプログラミングパラダイムです。

FRP の核心的なアイデアは、**時間とともに発生する非同期的なイベントやデータの流れを、「イベントストリーム (Event Stream)」または「Observable (オブザーバブル)」と呼ばれる統一された抽象概念として捉え、このストリームに対して関数型プログラミングの高階関数的な「演算子 (Operators)」を適用することで、データの変換、フィルタリング、合成といった処理を宣言的かつ合成可能な方法で記述する**、というものです。

まるで、水道の蛇口から流れ出る「水の流れ（ストリーム）」に対して、フィルターを取り付けたり（フィルタリング）、途中で別の流れと合流させたり（マージ）、水の勢いを調整したり（スロットリング）するようなイメージで、イベントの流れを自在に加工し、制御していくことができます。

## この資料で目指すこと：イベントの「川」をエレガントに操る

この資料では、関数型リアクティブプログラミングの基本的な考え方と、その中心となるイベントストリーム（Observable）の概念、そしてストリームを操作するための主要な演算子について、具体的なイメージを掴みながら学んでいきます。

目標は、皆さんが、

- 非同期的なイベントやデータの流れを「ストリーム」として捉える新しい視点を獲得すること。
- 代表的なストリーム操作演算子の使い方とその効果を理解すること。
- 複雑なイベント駆動型の処理を、よりシンプルで、宣言的で、そして保守しやすい形で設計・実装するための一歩を踏み出すこと。

です。FRP の世界は奥深く、多くの高度なテクニックが存在しますが、まずはその基本的な「イベントの川をエレガントに操る」感覚を掴んでいきましょう。

# 第 1 部：イベントストリームの基本：非同期データの流れを捉える

関数型リアクティブプログラミング (FRP) の旅は、その中心的な構成要素である「イベントストリーム」とは何かを理解することから始まります。この部では、イベントストリームの基本的な概念、その構成要素、そしてストリームをどのように生成し、どのようにその流れを受け止める（購読する）のか、といった基礎を学びます。

## イベントストリーム (Observable) とは何か？

**イベントストリーム (Event Stream)**、あるいは多くの FRP ライブラリで採用されている「**Observable (オブザーバブル)**」という用語は、その名の通り、「**観測可能な (Observable) 一連のイベント（または値）の流れ**」を表す抽象的な概念です。

これをもう少し具体的に言うと、

- **時間軸に沿った値のシーケンス:**
  イベントストリームは、時間とともに、0 個、1 個、あるいは（概念的には）無限個の「値」または「イベント」を次々と発行する可能性があります。
- **非同期的なデータの流れ:**
  各値がいつ発行されるかは予測できません（非同期的です）。ユーザーの操作、ネットワークからの応答、センサーデータの到着など、その発生タイミングは様々です。
- **プッシュ型モデル:**
  多くの場合、イベントストリームは「プッシュ型」のモデルを採用します。つまり、データが必要になったときに消費者（購読者）が能動的に取りに行く（プル型）のではなく、生産者（ストリーム）が新しいデータが発生した時点で、それを購読者に「押し出す（プッシュする）」形で通知します。

**UI イベント、センサーデータ、API 応答など、多様なデータソース**

この「イベントストリーム」という抽象化は、驚くほど多様な種類の非同期的なデータソースを統一的に扱うことを可能にします。

- **ユーザーインターフェース (UI) イベント:** ボタンのクリック、マウスカーソルの移動、キーボードの入力、ウィンドウのリサイズなど、ユーザーが行うあらゆるインタラクションは、イベントのストリームとして捉えることができます。
  - 例: 「ボタン A のクリックイベントのストリーム」「マウス座標のストリーム」
- **センサーデータ:** 温度、湿度、加速度、GPS 位置情報といったセンサーから、時間とともに連続的に送られてくるデータは、まさにイベントストリームそのものです。
  - 例: 「温度センサーデータのストリーム（1 秒ごとに最新の温度を発行）」
- **API 応答 / ネットワークリクエスト:** サーバーへの非同期リクエストの結果（成功時のデータまたは失敗時のエラー）も、単一の値を発行して完了するストリームとしてモデル化できます。Promise/Future をストリームに変換することも一般的です。
  - 例: 「`/api/users` への GET リクエストの結果ストリーム」
- **タイマー / インターバル:** 一定時間後に一度だけ発生するイベントや、一定間隔で繰り返し発生するイベントも、ストリームとして表現できます。
  - 例: 「100 ミリ秒ごとにカウンター値を発行するストリーム」
- **WebSockets / Server-Sent Events (SSE):** サーバーからクライアントへ継続的にプッシュされるリアルタイムなデータも、イベントストリームとして自然に扱うことができます。
  - 例: 「チャットメッセージのストリーム」「株価更新通知のストリーム」

このように、一見すると性質の異なる様々な非同期的なデータソースを、「イベントストリーム」という単一の抽象概念で統一的に扱えるようにすることが、FRP の第一歩であり、その強力さの源泉の一つです。個々のイベント処理の詳細を隠蔽し、より高レベルな「データの流れ」としてプログラムを設計できるようになるのです。

## ストリームの 3 つの要素：値 (Next), エラー (Error), 完了 (Complete)

イベントストリーム（Observable）は、単に時間とともに値を次々と発行するだけではありません。ストリームのライフサイクル全体を通じて、購読者（Observer / Subscriber）に対して、主に以下の 3 種類の重要な「**通知 (Notification)**」を送ることができます。

1.  **値 (Next / onNext):**

    - **意味:** ストリームが新しい**データ（値またはイベント）を発行**したことを示します。これがストリームの主要な役割であり、もっとも頻繁に発生する通知です。
    - **振る舞い:** ストリームは、0 個以上の値を連続して発行できます。各値は、購読者の `next` (または `onNext`) ハンドラに渡され、そこで処理されます。
    - **例:**
      - クリックイベントストリームなら、クリックが発生するたびに `MouseEvent` オブジェクトが `next` 通知として発行されます。
      - 数値のストリームなら、`1`, `2`, `3`, ... といった数値が順次 `next` 通知として発行されます。

2.  **エラー (Error / onError):**

    - **意味:** ストリームの処理中に**何らかのエラーが発生し、ストリームが異常終了**したことを示します。
    - **振る舞い:** エラーが発生すると、ストリームはエラーオブジェクト（またはエラー情報）を伴う `error` (または `onError`) 通知を一度だけ発行し、その後は**完全に停止**します。エラー通知の後は、もはや `next` 通知も `complete` 通知も発行されません。
    - **例:**
      - HTTP リクエストのストリームで、ネットワークエラーが発生したり、サーバーがエラーレスポンスを返したりした場合。
      - ストリームの変換処理（`map` など）の途中で、予期せぬ例外が発生した場合。
    - **重要性:** エラーをストリームのライフサイクルの一部として明示的に扱うことで、非同期処理におけるエラーハンドリングを統一的かつ確実に行うことができます。購読者は、`error` ハンドラでエラーを捕捉し、適切な対処（ユーザーへの通知、リトライ処理、ログ記録など）を行うことができます。

3.  **完了 (Complete / onCompleted):**
    - **意味:** ストリームが**正常にすべての値を発行し終え、これ以上新しい値を発行することなく終了**したことを示します。
    - **振る舞い:** ストリームは、完了を示す `complete` (または `onCompleted`) 通知を一度だけ発行し、その後は**完全に停止**します。完了通知の後は、もはや `next` 通知も `error` 通知も発行されません。
    - **例:**
      - 有限個の要素を持つ配列から生成されたストリームは、すべての要素を発行し終えた後に完了通知を発行します。
      - HTTP リクエストのストリームは、レスポンスを完全に受信し終えた時点で完了通知を発行します。
      - ユーザーが「購読解除」ボタンを押すなど、明示的にストリームの終了が指示された場合。
    - **重要性:** ストリームが正常に終了したことを知ることで、購読者は後片付け処理（リソースの解放など）を行ったり、次の処理シーケンスを開始したりすることができます。すべてのストリームが完了するとは限りません（例: UI のクリックイベントストリームは、アプリケーションが終了するまで無限に続く可能性があります）。

**ストリームのライフサイクル（まとめ）:**

ストリームは、以下のいずれかのパターンでそのライフサイクルを辿ります。

- `next*` (0 回以上の `next` 通知) → `complete?` (0 回または 1 回の `complete` 通知)
- `next*` (0 回以上の `next` 通知) → `error?` (0 回または 1 回の `error` 通知)

つまり、**`error` 通知または `complete` 通知のどちらかが発行された時点で、そのストリームは終了**し、それ以降は何も発行しません。これらの通知は、ストリームの「終端イベント」とも呼ばれます。

この「値」「エラー」「完了」という 3 種類の通知を明確に区別し、それぞれに対応するハンドラを購読者が用意できるようにすることが、イベントストリーム（Observable）という抽象化の基本的な設計となっています。これにより、多様な非同期イベントやデータフローを、統一的で予測可能な方法で扱うことができるのです。

## ストリームの生成：イベントの源を作る

関数型リアクティブプログラミング (FRP) の世界でイベントストリームを扱うためには、まず何らかの「イベントの源」からストリーム（Observable）を**生成 (Create)** する必要があります。多くの FRP ライブラリは、様々な種類のイベントソースやデータ構造から、簡単にストリームを生成するための便利なユーティリティ関数やファクトリメソッド（**生成演算子 (Creation Operators)** とも呼ばれます）を提供しています。

ここでは、代表的なストリームの生成方法をいくつか見ていきましょう。（具体的なメソッド名はライブラリによって異なりますが、ここでは RxJS などで一般的な名前を参考にします。）

### DOM イベントから

Web フロントエンド開発においてもっとも一般的なイベントソースの一つが、HTML 要素の DOM イベント（クリック、マウス移動、キー入力など）です。

- **`fromEvent(targetElement, eventName)`:**
  指定された HTML 要素 (`targetElement`) の、特定のイベント (`eventName`) が発生するたびに、そのイベントオブジェクトを値として発行するストリームを生成します。

  ```javascript
  // 例: RxJS (JavaScript)
  // import { fromEvent } from 'rxjs'; // RxJS の fromEvent をインポート

  const button = document.getElementById("myButton");
  const clickStream$ = fromEvent(button, "click"); // ボタンクリックのストリーム
  // clickStream$ を購読すると、ボタンがクリックされるたびに MouseEvent が流れてくる

  const inputElement = document.getElementById("myInput");
  const keyupStream$ = fromEvent(inputElement, "keyup"); // キー入力のストリーム
  // keyupStream$ を購読すると、キーが離されるたびに KeyboardEvent が流れてくる
  ```

  （ストリームを表す変数名の末尾に `$` を付けるのは、RxJS コミュニティでよく見られる慣習です。）

### 配列や Promise から

既存のデータ構造（配列やイテラブルなオブジェクト）や、非同期処理の結果（Promise）からストリームを生成することも頻繁に行われます。

- **`from(iterableOrPromise)`:**
  配列や文字列、Set、Map といったイテラブルなオブジェクト、あるいは Promise を引数に取り、それらの要素や結果を順に発行するストリームを生成します。

  - **配列の場合:** 配列の各要素を順番に発行し、最後に完了 (complete) します。
  - **Promise の場合:** Promise が成功 (resolve) したらその値を一つ発行して完了し、失敗 (reject) したらエラー (error) を発行して終了します。

  ```javascript
  // 例: RxJS
  // import { from } from 'rxjs';

  const numbersArray = [10, 20, 30];
  const arrayStream$ = from(numbersArray);
  // arrayStream$ は 10, 20, 30 を順に発行し、その後完了する

  const fetchDataPromise = fetch("/api/data").then((res) => res.json());
  const promiseStream$ = from(fetchDataPromise);
  // promiseStream$ は fetch が成功したらそのJSONデータを1つ発行して完了、
  // 失敗したらエラーを発行して終了する
  ```

- **`of(...values)`:**
  引数として与えられた値を順番に発行し、最後に完了するストリームを生成します。

  ```javascript
  // 例: RxJS
  // import { of } from 'rxjs';

  const valueStream$ = of(1, "hello", true, { a: 1 });
  // valueStream$ は 1, "hello", true, {a:1} を順に発行し、完了する
  ```

### タイマー (interval, timer) から

一定時間ごと、あるいは指定した時間後にイベントを発生させたい場合も、ストリームとして簡単に表現できます。

- **`interval(periodMs)`:**
  指定された時間間隔 (`periodMs` ミリ秒) ごとに、0 から始まる連番 (0, 1, 2, ...) を発行し続ける**無限ストリーム**を生成します。（明示的に購読を解除しない限り、完了しません。）

  ```javascript
  // 例: RxJS
  // import { interval } from 'rxjs';

  const intervalStream$ = interval(1000); // 1秒ごとに 0, 1, 2, ... を発行
  // 0 --1s-- 1 --1s-- 2 --1s-- ...
  ```

- **`timer(initialDelayMs, periodMs?)`:**

  - 引数が一つの場合 (`timer(delay)`): 指定された時間 (`initialDelayMs`) が経過した後に、値 `0` を一つだけ発行して完了するストリームを生成します。
  - 引数が二つの場合 (`timer(delay, period)`): 最初の値 `0` を `initialDelayMs` 後に発行し、その後は `periodMs` 間隔で `1`, `2`, ... を発行し続ける無限ストリームを生成します。

  ```javascript
  // 例: RxJS
  // import { timer } from 'rxjs';

  const oneShotTimer$ = timer(2000); // 2秒後に 0 を発行して完了
  const periodicTimer$ = timer(1000, 500); // 1秒後に 0、その後0.5秒ごとに 1, 2, ...
  ```

### カスタムストリームの作成

FRP ライブラリは、より複雑なロジックや、既存のコールバックベースの API からストリームを生成するための、より低レベルな方法も提供しています。

- **`Observable` コンストラクタ (または `create` メソッド):**
  購読者 (Subscriber / Observer) を引数に取る関数を渡して、Observable インスタンスを直接生成します。この関数の中で、購読者に対して `next(value)`, `error(err)`, `complete()` といったメソッドを適切なタイミングで呼び出すことで、ストリームの振る舞いを自由に定義できます。

  ```javascript
  // 例: RxJS (Observable コンストラクタ)
  // import { Observable } from 'rxjs';

  const customStream$ = new Observable((subscriber) => {
    subscriber.next(1); // 値 1 を発行
    subscriber.next(2); // 値 2 を発行

    const timeoutId = setTimeout(() => {
      subscriber.next(3); // 1秒後に値 3 を発行
      subscriber.complete(); // ストリーム完了
    }, 1000);

    // 購読解除時のクリーンアップ処理 (重要)
    return function unsubscribe() {
      clearTimeout(timeoutId);
      console.log("カスタムストリームの購読が解除されました。");
    };
  });
  ```

  この方法は非常に柔軟ですが、エラー処理やリソース管理（とくに購読解除時の処理）を正しく行う責任が開発者に委ねられます。

これらの生成演算子（またはそれに類するファクトリメソッド）を理解し、状況に応じて使い分けることで、様々な種類の非同期的な「イベントの源」を、統一された「イベントストリーム」という抽象的なインターフェースで扱えるようになります。これが、関数型リアクティブプログラミングにおける多様なイベント処理の第一歩となるのです。

## ストリームの購読 (Subscription)：流れを受け止める

イベントストリーム（Observable）を生成しただけでは、まだ何も起こりません。ストリームは、いわば「イベントが流れる可能性のある川」のようなものであり、その流れから実際に値（イベント）を受け取り、何らかの処理を行うためには、誰かがその川のほとりで「待ち構える」必要があります。この「待ち構える」行為、つまり**ストリームに接続して値の通知を受け取り始めること**を、「**購読 (Subscription / Subscribing)**」と呼びます。

ストリームを購読すると、そのストリームは値の発行を開始し（コールドストリームの場合）、購読者に対して「値 (Next)」「エラー (Error)」「完了 (Complete)」という 3 種類の通知を送り始めます。

### `subscribe` メソッドと Observer

ほとんどの FRP ライブラリでは、ストリーム（Observable）オブジェクトは `subscribe` というメソッドを持っています。この `subscribe` メソッドを呼び出すことで、ストリームの購読が開始されます。

`subscribe` メソッドには、通常、以下の 3 種類のコールバック関数（またはそれらをまとめたオブジェクト）を渡します。これらのコールバック関数を持つオブジェクトを総称して「**Observer (オブザーバー)**」または「**Subscriber (サブスクライバ)**」と呼びます。

1. **`next` ハンドラ (または `onNext`):**
   - ストリームから新しい**値が発行されるたびに**呼び出されます。
   - 引数として発行された値を受け取ります。
   - 例: `value => console.log("新しい値:", value)`
2. **`error` ハンドラ (または `onError`):**
   - ストリームの処理中に**エラーが発生し、ストリームが異常終了する際に一度だけ**呼び出されます。
   - 引数としてエラーオブジェクト（またはエラー情報）を受け取ります。
   - 例: `err => console.error("エラー発生:", err.message)`
3. **`complete` ハンドラ (または `onCompleted`):**
   - ストリームが**正常にすべての値を発行し終え、完了する際に一度だけ**呼び出されます。
   - 引数は通常ありません。
   - 例: `() => console.log("ストリームが完了しました。")`

これらのハンドラは、すべてが必須というわけではありません。たとえば、エラー処理や完了処理が不要であれば、`next` ハンドラだけを渡すこともできます（ライブラリの API 仕様によります）。

```javascript
// 例: RxJS (JavaScript)
// import { interval } from 'rxjs';
// import { take } from 'rxjs/operators'; // take 演算子をインポート

const numberStream$ = interval(1000).pipe(take(3)); // 1秒ごとに0, 1, 2 を発行して完了するストリーム

console.log("ストリームの購読を開始します...");

const subscription = numberStream$.subscribe({
  next: (value) => {
    // next ハンドラ
    console.log(`  受信した値: ${value}`);
  },
  error: (err) => {
    // error ハンドラ (この例では呼ばれない)
    console.error(`  エラー: ${err}`);
  },
  complete: () => {
    // complete ハンドラ
    console.log("  ストリームが正常に完了しました。");
  },
});

console.log("購読処理は非同期的に行われます。");

/*
出力イメージ:
ストリームの購読を開始します...
購読処理は非同期的に行われます。
  (1秒後) 受信した値: 0
  (1秒後) 受信した値: 1
  (1秒後) 受信した値: 2
  ストリームが正常に完了しました。
*/
```

この例では、`numberStream$` を `subscribe` メソッドで購読し、`next`, `error`, `complete` の各通知に対応する処理を定義しています。`interval(1000)` は 1 秒ごとに値を出し続けますが、`take(3)` という演算子（後述）によって最初の 3 つの値だけが流れ、その後ストリームは完了します。

### 購読の解除とリソース管理の重要性

ストリームを購読すると、そのストリームが完了するかエラーで終了するまで、あるいは明示的に購読を解除するまで、値の通知を受け取り続けます。とくに、`interval` のような無限に値を生成し続けるストリームや、DOM イベントのようにアプリケーションが終了するまで発生し続ける可能性のあるストリームを購読した場合、**購読を解除しないと、不要になった後もメモリリークや意図しない処理の継続といった問題を引き起こす**可能性があります。

`subscribe` メソッドは、通常、**`Subscription` (購読)** オブジェクトを返します。この `Subscription` オブジェクトは、購読を途中で解除するための `unsubscribe()` メソッドを持っています。

**購読の解除がとくに重要なケース:**

- **コンポーネントのライフサイクル (UI 開発など):**
  特定の UI コンポーネント（例: Web ページの特定のセクション、モバイルアプリの特定の画面）が表示されている間だけストリームを購読し、コンポーネントが破棄される（非表示になる、画面遷移するなど）際には、必ず `unsubscribe()` を呼び出して購読を解除する必要があります。これを怠ると、破棄されたコンポーネントのイベントハンドラが実行され続けようとしたり、メモリ上に残り続けたりする原因となります。
- **長期間実行されるアプリケーション:**
  サーバーサイドアプリケーションなどで、長時間実行されるプロセスがストリームを購読し続ける場合、適切なタイミングで購読を解除しないと、リソースを消費し続ける可能性があります。

```javascript
// 例: RxJS (購読解除のイメージ)
const tickingStream$ = interval(500); // 0.5秒ごとに値を発行し続ける

const mySubscription = tickingStream$.subscribe({
  next: (value) => console.log(`Tick: ${value}`),
});

// 3秒後に購読を解除する
setTimeout(() => {
  console.log("3秒経過。購読を解除します。");
  mySubscription.unsubscribe();
  // これ以降、Tick: ... の出力は止まる
}, 3000);
```

多くの FRP ライブラリでは、複数の購読をまとめて管理し、一度に解除するための仕組み（例: RxJS の `Subscription` オブジェクトの `add()` メソッド）や、特定のスコープ（例: コンポーネント）と購読のライフサイクルを連動させるための演算子（例: `takeUntil`）なども提供されています。

イベントストリームを購読するということは、そのストリームからの通知を受け取り、それに応じて何らかの「反応 (React)」をする、リアクティブプログラミングのまさに核心部分です。そして、不要になった購読を適切に解除することは、リソースを効率的に管理し、安定したアプリケーションを維持するための、非常に重要な責務と言えるでしょう。

## コールドストリーム vs ホットストリーム：購読時の振る舞いの違い

イベントストリーム（Observable）には、その振る舞いの特性によって、大きく分けて「**コールドストリーム (Cold Observable)**」と「**ホットストリーム (Hot Observable)**」という二つの種類があります。この違いを理解することは、ストリームをいつ、どのように購読し、複数の購読者で値を共有するかどうかを考える上で非常に重要です。

**コールドストリーム (Cold Observable): 購読されて初めて動き出す**

- **特徴:**
  コールドストリームは、**購読 (`subscribe`) されるたびに、値の生成やイベントの発行を最初から新しく開始**します。まるで、ビデオテープや DVD のようなもので、再生ボタンを押す（購読する）たびに、物語は最初から始まります。
- **振る舞い:**
  - **遅延実行 (Lazy Execution):** 誰かが購読するまでは、ストリームは活動を開始しません（値を発行しません）。
  - **購読者ごとに独立した実行:** 複数の購読者が同じコールドストリームを購読した場合、それぞれの購読者は、**独立した、自分専用のデータ発行シーケンス**を受け取ります。最初の購読者が途中まで値を受け取っていても、新しい購読者が購読を開始すると、その新しい購読者には最初からの値が発行されます。
- **代表的な例:**
  - **`from(array)`:** 配列からストリームを生成する場合、各購読者は配列の最初の要素から順に値を受け取ります。
  - **`of(value1, value2, ...)`:** 指定された値を順番に発行します。各購読者はすべての値を受け取ります。
  - **HTTP リクエストを表すストリーム:** 通常、HTTP リクエストは購読されるたびに新しく実行されます。そのため、複数の購読者がいれば、リクエストも複数回送信されることになります。
  - **多くの生成演算子 (`interval`, `timer` など) がデフォルトで生成するものもコールドです。**

**ホットストリーム (Hot Observable): 購読の有無に関わらず動き続ける**

- **特徴:**
  ホットストリームは、**購読者の有無に関わらず、値の生成やイベントの発行を独立して行い続けます**。まるで、放送中のラジオやテレビ番組のようなもので、チューニングを合わせる（購読する）タイミングによって、どこから番組を聞き始める（値を受け取り始める）かが変わります。
- **振る舞い:**
  - **即時実行 (Eager Execution) の可能性:** ストリームのソース（例: DOM イベント、WebSocket）は、購読者がいなくてもイベントを発生させ続けている場合があります。
  - **複数の購読者で値を共有:** 複数の購読者が同じホットストリームを購読した場合、それらの購読者は、**同じタイミングで同じ値**を受け取ります（購読開始後に発行された値について）。途中から購読を開始した購読者は、それ以前に発行された値は受け取れません。
- **代表的な例:**
  - **`fromEvent(domElement, 'click')`:** DOM 要素のクリックイベントは、誰かがそれをリッスン（購読）しているかどうかに関わらず発生し続けます。購読を開始した時点以降のクリックイベントを受け取ります。
  - **マウスの移動イベントやキーボード入力イベントのストリーム。**
  - **WebSocket や Server-Sent Events からのメッセージストリーム。**
  - コールドストリームを、特定の演算子（例: RxJS の `share()`, `publish()` + `connect()`, `shareReplay()` など）を使ってホットストリーム（またはそれに近い振る舞いをするストリーム）に変換することもできます。これは、複数の購読者で高価な処理の結果を共有したい場合などに使われます。

**どちらを使うべきか？**

コールドストリームとホットストリームのどちらが適切かは、扱いたいイベントソースの性質や、アプリケーションの要求によって異なります。

- **コールドストリームが適している場合:**
  - 各購読者が、データの完全なシーケンスを最初から必要とする場合（例: 設定情報の読み込み、Promise の結果）。
  - 処理の実行タイミングを、実際に購読されるまで遅延させたい場合。
  - 各購読者に対して、独立したリソースや状態を持たせたい場合。
- **ホットストリームが適している場合（またはコールドをホットに変換する場合）:**
  - UI イベントのように、その発生が購読者の存在に依存しないイベントを扱う場合。
  - 複数の購読者で、同じイベントや計算結果をリアルタイムに共有したい場合（例: 株価の更新通知）。
  - 購読されるたびに高価な処理（例: HTTP リクエスト）が再実行されるのを避けたい場合（コールドストリームを `shareReplay` などでホット化する）。

**例：コールドストリームとホットストリームの振る舞いの違い (RxJS 風)**

```javascript
// コールドストリームの例 (interval はデフォルトでコールド)
const coldStream$ = interval(1000).pipe(take(3));

console.log("コールドストリーム: 最初の購読開始");
coldStream$.subscribe((value) => console.log(`  コールド購読者1: ${value}`));

setTimeout(() => {
  console.log("\nコールドストリーム: 2秒後に2番目の購読開始");
  coldStream$.subscribe((value) =>
    console.log(`    コールド購読者2: ${value}`)
  );
}, 2000);

/*
出力イメージ (コールド):
コールドストリーム: 最初の購読開始
  コールド購読者1: 0  (1秒後)
  コールド購読者1: 1  (2秒後)

コールドストリーム: 2秒後に2番目の購読開始 (この時点で購読者1は既に1まで受信)
    コールド購読者2: 0  (購読開始から1秒後、全体では3秒後)
  コールド購読者1: 2  (3秒後、これで完了)
    コールド購読者2: 1  (購読開始から2秒後、全体では4秒後)
    コールド購読者2: 2  (購読開始から3秒後、全体では5秒後、これで完了)
=> 各購読者が独立して 0, 1, 2 を受信している
*/

// コールドストリームを share() でホット（に近い振る舞い）にする例
// share() は、最初の購読時にソースに接続し、以降の購読者はその結果を共有する
// （ただし、すべての購読者がいなくなるとソースとの接続も切れるなど、詳細な振る舞いがある）
const sharedInterval$ = interval(1000).pipe(
  take(5), // 5回で完了するように
  tap((value) => console.log(`  (ソースから発行: ${value})`)), // ソースの発行をログ
  share() // これでホット（マルチキャスト）になる
);

console.log("\nホット(共有)ストリーム: 最初の購読開始");
const sub1 = sharedInterval$.subscribe((value) =>
  console.log(`  ホット購読者A: ${value}`)
);

setTimeout(() => {
  console.log("\nホット(共有)ストリーム: 1.5秒後に2番目の購読開始");
  const sub2 = sharedInterval$.subscribe((value) =>
    console.log(`    ホット購読者B: ${value}`)
  );
  // sub2 は途中から値を受け取る
  setTimeout(() => {
    console.log(
      "\nホット(共有)ストリーム: さらに2秒後 (全体で3.5秒後) に購読者Aを解除"
    );
    sub1.unsubscribe();
  }, 2000);
}, 1500);

/*
出力イメージ (ホット/共有):
ホット(共有)ストリーム: 最初の購読開始
  (ソースから発行: 0) (1秒後)
  ホット購読者A: 0
  (ソースから発行: 1) (2秒後)

ホット(共有)ストリーム: 1.5秒後に2番目の購読開始 (購読者Aは既に0を受信、次に1が発行されるタイミング)
  ホット購読者A: 1
    ホット購読者B: 1 (購読者Aと同じ値を受け取る)
  (ソースから発行: 2) (3秒後)
  ホット購読者A: 2
    ホット購読者B: 2
  (ソースから発行: 3) (4秒後)

ホット(共有)ストリーム: さらに2秒後 (全体で3.5秒後) に購読者Aを解除 (購読者Aは2まで受信、次は3が発行されるタイミング)
  ホット購読者A: 3 (解除直前に最後の値を受け取る可能性も)
    ホット購読者B: 3
  (ソースから発行: 4) (5秒後)
    ホット購読者B: 4 (購読者Aはもう受け取らない)
  (ソースから発行: 5) (6秒後)
    ホット購読者B: 5 (これで完了)
=> 購読者B は途中から参加し、購読者A と値を共有している
*/
```

このコールドとホットの違いは、FRP ライブラリを使う上でしばしば混乱の元となるポイントですが、一度理解すれば、ストリームの振る舞いをより正確に予測し、意図した通りに制御できるようになります。とくに、複数の場所で同じ非同期処理の結果を共有したい場合や、副作用（例: HTTP リクエスト）が購読のたびに何度も実行されるのを避けたい場合には、コールドストリームをホットストリームに変換するテクニック（`share`, `shareReplay`, `publish` + `refCount` など）が重要になります。

# 第 2 部：ストリーム操作の基礎：高階関数的な演算子

イベントストリーム（Observable）という、時間とともに流れる非同期的なデータの「川」の概念を理解したところで、次はその川の流れをどのように加工し、形を変え、あるいは他の川と合流させるのか、そのための「道具」について学んでいきましょう。関数型リアクティブプログラミング (FRP) において、この道具の役割を果たすのが「**演算子 (Operator)**」です。

## FRP における「演算子 (Operator)」とは？

FRP における演算子とは、**入力として一つ以上のストリーム（Observable）を受け取り、それらを何らかの方法で変換・合成して、新しい出力ストリームを返す関数**のことです。これは、関数型プログラミングにおける高階関数（関数を引数に取ったり、関数を返したりする関数）の考え方を、イベントストリームの世界に適用したものと考えることができます。

多くの FRP ライブラリ（RxJS, Reactor Core, Akka Streams など）は、この演算子を非常に豊富に提供しており、開発者はこれらの演算子をメソッドチェーンのように繋ぎ合わせていくことで、複雑な非同期データフローを宣言的かつ効率的に構築できます。

**演算子の主な役割:**

- **ストリームの変換 (Transformation):** ストリームを流れる各値に対して、何らかの処理を施して新しい値に変換する（例: `map`）。
- **ストリームのフィルタリング (Filtering):** ストリームを流れる値の中から、特定の条件を満たすものだけを選び出す（例: `filter`）。
- **ストリームの合成 (Combination):** 複数のストリームを 1 つにまとめたり、特定のルールに基づいて組み合わせたりする（例: `merge`, `zip`）。
- **ストリームの時間的制御 (Time-based operations):** 値の発行タイミングを遅延させたり、一定間隔で間引いたり、バッファリングしたりする（例: `delay`, `throttleTime`, `buffer`）。
- **エラーハンドリング:** ストリームでエラーが発生した場合の処理（リトライ、代替値の提供など）を行う（例: `catchError`, `retry`）。
- **ユーティリティ:** その他、ストリームのデバッグやロギング、条件分岐など、様々な補助的な機能を提供します。

### ストリームを変換・合成する純粋関数的な道具

FRP の演算子の多くは、**純粋関数的な性質**を持つように設計されています。つまり、

- **入力ストリームを変更しない:** 演算子は、元の入力ストリームを直接変更するのではなく、常に入力ストリームに基づいて**新しい出力ストリームを生成**します。これは不変性の原則に沿っています。
- **副作用を持たない（理想的には）:** 演算子自体の処理は、ストリームの値を変換・合成することに集中し、外部の状態を変更するような副作用を（可能な限り）持ちません。（ただし、`tap`/`do` のように、副作用を意図的に実行するための演算子も存在します。）

この純粋関数的な性質により、演算子を安心して組み合わせることができ、処理の流れが予測しやすく、テストも容易になります。

### 入力ストリームから新しい出力ストリームを生成する

演算子を使ったストリーム処理は、しばしば「**パイプライン (Pipeline)**」に例えられます。

```
[ソースストリーム] --演算子A--> [新しいストリームA'] --演算子B--> [新しいストリームA''] --演算子C--> ...
```

1. まず、何らかのイベントソースから**元のストリーム**が生成されます。
2. そのストリームに対して、最初の**演算子 A** が適用され、変換・フィルタリングなどが行われた結果として、**新しいストリーム A'** が生成されます。
3. 次に、ストリーム A' に対して、**演算子 B** が適用され、さらに**新しいストリーム A''** が生成されます。
4. このように、演算子を次々と繋ぎ合わせていくことで、データの流れを段階的に加工し、最終的に目的とするデータストリームを作り上げていきます。

多くの FRP ライブラリでは、この演算子の連鎖を、Observable オブジェクトのメソッドとして（あるいは専用の `pipe()` メソッドなどを介して）直感的に記述できるようになっています。

```javascript
// RxJS での演算子チェーンのイメージ
sourceStream$
  .pipe(
    filter((value) => value > 10), // 10より大きい値だけをフィルタリング
    map((value) => value * 2), // その値を2倍に変換
    debounceTime(500) // 500ms待って最後の値だけを流す
  )
  .subscribe(
    (processedValue) => console.log(processedValue) // 最終的な処理結果を購読
  );
```

この演算子という「道具」を理解し、効果的に組み合わせるスキルを身につけることが、関数型リアクティブプログラミングをマスターするための鍵となります。次のセクションからは、これらの演算子を具体的なカテゴリに分け、代表的なものを詳しく見ていきましょう。

## 変換系演算子：ストリームの値を形作る

変換系演算子は、ストリームを流れてくる個々の値を、何らかのルールに基づいて別の値に**変換**し、新しいストリームとして出力する役割を持ちます。元のストリームの構造（値の数やタイミング）は基本的には維持しつつ、値そのものの「形」や「種類」を変えるのに使われます。

### `map`：各値を変換する

`map` 演算子は、おそらくもっとも基本的で、もっとも頻繁に使われる変換演算子です。配列の `map` メソッドと非常によく似た働きをします。

- **動作:** 入力ストリームの各要素（値）に対して、指定された**変換関数 (transform function)** を適用し、その関数の戻り値を要素とする新しいストリームを生成します。
- **用途:**
  - ストリームを流れるデータの型を変更する（例: 数値ストリームを文字列ストリームに）。
  - オブジェクトの特定のプロパティだけを取り出す。
  - 各値に対して何らかの計算処理を施す。
- **純粋性:** 変換関数が純粋であれば、`map` 操作自体も純粋性を保ちやすいです。

```javascript
// 例: RxJS (JavaScript)
// import { of } from 'rxjs';
// import { map } from 'rxjs/operators';

const numberStream$ = of(1, 2, 3, 4);

const squaredStream$ = numberStream$.pipe(
  map((value) => value * value) // 各値を2乗する
);

// squaredStream$ を購読すると、1, 4, 9, 16 が順に流れてくる

const eventStream$ = fromEvent(document.getElementById("myButton"), "click");
const clientXStream$ = eventStream$.pipe(
  map((clickEvent) => clickEvent.clientX) // クリックイベントからX座標だけを取り出す
);
// clientXStream$ を購読すると、クリックされるたびにそのX座標が流れてくる
```

`map` は、ストリームのデータを「一対一」で変換する際の基本となります。

### `pluck`：特定のプロパティを抽出する

オブジェクトのストリームを扱っている際、各オブジェクトの特定のプロパティの値だけを取り出して新しいストリームを作りたい、ということはよくあります。`map` を使って `map(obj => obj.propertyName)` と書くこともできますが、一部の FRP ライブラリでは、この一般的な操作のためにより簡潔な `pluck` 演算子を提供しています。

- **動作:** 入力ストリームの各要素（オブジェクトであると期待される）から、指定された**プロパティ名（またはネストしたプロパティのパス）の値**を抽出し、その値を要素とする新しいストリームを生成します。
- **用途:** オブジェクトの特定のフィールドの値だけに興味がある場合に、コードを簡潔にします。

```javascript
// 例: RxJS
// import { from } from 'rxjs';
// import { pluck } from 'rxjs/operators';

const users = [
  { name: "Alice", age: 30, address: { city: "New York" } },
  { name: "Bob", age: 25, address: { city: "London" } },
  { name: "Charlie", age: 35, address: { city: "Paris" } },
];
const userStream$ = from(users);

const nameStream$ = userStream$.pipe(
  pluck("name") // "name" プロパティの値を抽出
);
// nameStream$ は "Alice", "Bob", "Charlie" を発行する

const cityStream$ = userStream$.pipe(
  pluck("address", "city") // ネストしたプロパティ address.city の値を抽出
);
// cityStream$ は "New York", "London", "Paris" を発行する
```

`pluck` は、特定のプロパティアクセスをより宣言的に書くための便利なショートカットと言えます。

### `mapTo`：固定値に置き換える

ストリームを流れる元の値には興味がなく、イベントが発生したという「事実」だけに基づいて、常に**固定の値を新しいストリームに流したい**場合があります。`mapTo` 演算子は、このようなケースで使用されます。

- **動作:** 入力ストリームから値が発行されるたびに、元の値の内容に関わらず、あらかじめ指定された**固定の値**を発行する新しいストリームを生成します。
- **用途:**
  - イベントの発生を検知し、それを特定の状態やメッセージにマッピングする。
  - 複数の異なるイベントストリームを、共通の識別子を持つストリームに変換してマージする前処理など。

```javascript
// 例: RxJS
// import { fromEvent, interval } from 'rxjs';
// import { mapTo, merge } from 'rxjs/operators'; // merge も後で説明します

const clickStream$ = fromEvent(document.getElementById("myButton"), "click");
const intervalStream$ = interval(2000); // 2秒ごとのタイマー

const clickNotificationStream$ = clickStream$.pipe(
  mapTo("Button Clicked!") // クリックのたびに固定の文字列を発行
);

const timerNotificationStream$ = intervalStream$.pipe(
  mapTo("Timer Tick") // タイマーイベントのたびに固定の文字列を発行
);

// merge(clickNotificationStream$, timerNotificationStream$).subscribe(console.log);
// 出力例:
// Button Clicked! (ボタンクリック時)
// Timer Tick (2秒後)
// Timer Tick (4秒後)
// Button Clicked! (ボタンクリック時)
// ...
```

`mapTo` は、ストリームの値を無視して、イベントの発生そのものに意味を持たせたい場合に便利です。

### `scan`：値を累積・集約しながら発行する

配列の `reduce` メソッドは、配列全体を一つの最終的な値に畳み込みました。ストリーム操作における `scan` 演算子は、これと似ていますが、重要な違いがあります。`scan` は、ストリームに新しい値が流れてくるたびに、それまでの**集約結果（アキュムレータ）と新しい値を組み合わせて計算し、その中間の集約結果を都度、新しいストリームの要素として発行し続けます**。

- **動作:**
  1. 初期値（シード値）と、アキュムレータ関数 `(accumulator, currentValue) => newAccumulator` を引数に取ります。
  2. 最初の値が入力ストリームから発行されると、アキュムレータ関数が `(初期値, 最初の値)` で呼び出され、その結果が最初の中間集約値として出力ストリームに発行されます。この結果が次のアキュムレータとなります。
  3. 次の値が入力ストリームから発行されると、アキュムレータ関数が `(前回の集約結果, 今回の値)` で呼び出され、その結果が次の中間集約値として出力ストリームに発行されます。
  4. これをストリームが完了するまで繰り返します。
- **用途:**
  - イベントの発生回数をカウントする。
  - 値の合計や平均をリアルタイムに計算し続ける。
  - アプリケーションの状態を、イベントストリームに基づいて段階的に更新していく（Redux のリデューサに近い考え方）。

```javascript
// 例: RxJS
// import { fromEvent } from 'rxjs';
// import { scan, map } from 'rxjs/operators';

const clickStream$ = fromEvent(document.getElementById('clickCounterButton'), 'click');

const clickCountStream$ = clickStream$.pipe(
  mapTo(1), // 各クリックを数値の 1 に変換 (scan の入力として)
  scan((currentCount, one) => currentCount + one, 0) // 初期値0で、クリックごとに1を加算
);

// clickCountStream$ を購読すると、
// 1回目のクリックで 1
// 2回目のクリックで 2
// 3回目のクリックで 3 ... といったように、現在の総クリック数が流れてくる

// 例：入力された数値の合計を逐次計算する
const numberInput$ = new Subject<number>(); // Subject は値を手動で発行できる Observable
const sumStream$ = numberInput$.pipe(
  scan((currentSum, newValue) => currentSum + newValue, 0)
);

// sumStream$.subscribe(sum => console.log(`現在の合計: ${sum}`));
// numberInput$.next(10); // 出力: 現在の合計: 10
// numberInput$.next(5);  // 出力: 現在の合計: 15
// numberInput$.next(20); // 出力: 現在の合計: 35
```

`scan` は、ストリームの履歴（あるいはその集約結果）を保持しながら、新しい値に基づいて状態を更新していくような処理を表現するのに非常に強力です。「現在の状態は、過去のすべてのイベントの集積である」という考え方を直接的にコードに落とし込むことができます。

これらの変換系演算子は、イベントストリームを扱う上での基本的な「語彙」となります。これらを理解し、組み合わせることで、多様なデータの流れを柔軟に、そして宣言的に形作っていくことができるようになります。

## フィルタリング系演算子：必要な値だけを選び出す

イベントストリームを扱っていると、流れてくるすべての値に興味があるわけではなく、特定の条件を満たす値だけを選び出したり、あるいはストリームの特定の部分だけを取り出したりしたい、という場面がよくあります。フィルタリング系演算子は、このような「**ストリームから必要な値だけを選別する**」という役割を担います。

これらの演算子もまた、入力ストリームを変更せず、条件に合致した値だけを含む新しい出力ストリームを生成します。

### `filter`：条件に合う値だけを通す

`filter` 演算子は、配列の `filter` メソッドと全く同じように、ストリームの各要素に対して**述語関数 (predicate function)** を適用し、その関数が `true` を返した要素だけを通過させる新しいストリームを生成します。

- **動作:** 入力ストリームの各値に対して、指定された述語関数 `(value) => boolean` を実行します。述語関数が `true` を返した値のみが、出力ストリームに発行されます。`false` を返した値は無視（フィルタリング）されます。
- **用途:**
  - 特定の条件を満たすイベントだけを処理したい場合。
  - 不要なデータやノイズを除去したい場合。

```javascript
// 例: RxJS (JavaScript)
// import { interval } from 'rxjs';
// import { filter } from 'rxjs/operators';

const numberStream$ = interval(500); // 0.5秒ごとに 0, 1, 2, 3, ... を発行

const evenNumberStream$ = numberStream$.pipe(
  filter((value) => value % 2 === 0) // 偶数だけをフィルタリング
);

// evenNumberStream$ を購読すると、0, 2, 4, 6, ... といった偶数だけが流れてくる
```

`filter` は、ストリームの内容を絞り込むためのもっとも基本的な演算子の一つです。

### `take` / `takeLast` / `takeUntil` / `takeWhile`：特定の条件まで値を取得する

ストリームから、最初の数個、最後の数個、あるいは特定の条件が満たされるまでの値だけを取り出したい、という場合があります。これらの「**個数や条件でストリームを打ち切る**」系の演算子は、とくに無限ストリームを扱う際や、不要な処理を早期に終了させたい場合に役立ちます。

- **`take(count)`:**
  入力ストリームの**最初の `count` 個の値**だけを発行し、その後ストリームを完了させます。
  ```javascript
  // interval(1000).pipe(take(3)) は 0, 1, 2 を発行して完了する
  ```
- **`takeLast(count)`:**
  入力ストリームが**完了した時点で、その最後の `count` 個の値**を発行し、その後ストリームを完了させます。（入力ストリームが完了するまで、どの値が最後になるか分からないため、内部的に値をバッファリングします。）
- **`takeUntil(notifierObservable)`:**
  入力ストリームの値を通常通り発行し続けますが、**別の `notifierObservable`（通知用ストリーム）が最初の値を発行した時点で、入力ストリームを即座に完了**させます。コンポーネントの破棄イベントなど、外部からのシグナルでストリームを終了させたい場合に非常に便利です。
  ```javascript
  // clickStream$.pipe(takeUntil(componentDestroy$))
  // componentDestroy$ が発行されるまでクリックイベントを流し、発行されたら完了
  ```
- **`takeWhile(predicateFn, inclusive?)`:**
  入力ストリームの各値に対して述語関数 `predicateFn` を適用し、**`true` を返している間だけ**値を発行し続けます。述語関数が初めて `false` を返した時点でストリームを完了させます。オプションの `inclusive` が `true` の場合、`false` を返したその値も発行してから完了します。

### `skip` / `skipLast` / `skipUntil` / `skipWhile`：特定の条件まで値を無視する

`take` 系の演算子とは逆に、ストリームの最初の数個の値を無視したり、特定の条件が満たされるまで値を無視したりするための演算子群です。

- **`skip(count)`:**
  入力ストリームの**最初の `count` 個の値を無視**し、それ以降の値を発行します。
- **`skipLast(count)`:**
  入力ストリームが完了する際に、**最後の `count` 個の値を無視**します。（`takeLast` 同様、内部バッファリングが必要です。）
- **`skipUntil(notifierObservable)`:**
  別の `notifierObservable` が最初の値を発行するまでは入力ストリームの値をすべて無視し、**`notifierObservable` が発行された後から**入力ストリームの値を発行し始めます。
- **`skipWhile(predicateFn)`:**
  入力ストリームの各値に対して述語関数 `predicateFn` を適用し、**`true` を返している間は値をすべて無視**します。述語関数が初めて `false` を返した時点から、値の発行を開始します。

### `first` / `last`：最初/最後の値だけを取得する

ストリームの中から、最初または最後の値（オプションで条件に合致するもの）だけを取り出したい場合に使います。

- **`first(predicateFn?)`:**
  入力ストリームの**最初の値**（オプションで `predicateFn` を満たす最初の値）を発行し、その後ストリームを完了させます。もし条件を満たす値が見つからないままストリームが完了した場合、エラーを発行するか、あるいはデフォルト値を返すように設定できます。
- **`last(predicateFn?)`:**
  入力ストリームが完了した時点で、その**最後の値**（オプションで `predicateFn` を満たす最後の値）を発行し、その後ストリームを完了させます。`first` 同様、値が見つからない場合の挙動を設定できます。

### `distinct` / `distinctUntilChanged`：重複を排除する

ストリームに同じ値が連続して、あるいは複数回流れてくる場合に、重複を排除したいことがあります。

- **`distinct(keySelectorFn?)`:**
  入力ストリームを流れる値のうち、**過去に一度も発行されたことのない値だけ**を発行します。オプションで `keySelectorFn` を指定すると、その関数で変換された値に基づいて重複を判定します。
  ```javascript
  // of(1, 2, 2, 3, 1, 2, 4).pipe(distinct()) は 1, 2, 3, 4 を発行
  ```
- **`distinctUntilChanged(compareFn?)`:**
  入力ストリームにおいて、**直前に発行された値と現在の値が異なる場合のみ**、現在の値を発行します。つまり、「連続した重複」だけを排除します。オプションで比較関数 `compareFn` を指定できます。
  ```javascript
  // of(1, 1, 2, 2, 2, 1, 3, 3).pipe(distinctUntilChanged()) は 1, 2, 1, 3 を発行
  ```

これらのフィルタリング系演算子を使いこなすことで、イベントストリームから本当に必要な情報だけを効率的に抽出し、後続の処理に渡すことができます。これにより、不要な処理の実行を抑え、プログラム全体のパフォーマンスと可読性を向上させることが可能になります。

## 合成系演算子：複数のストリームを組み合わせる

実際のアプリケーションでは、単一のイベントストリームだけを扱うのではなく、複数の異なるストリームからの情報を組み合わせて、新しい意味のあるデータフローを作り出したいという場面が頻繁にあります。合成系演算子は、このような**複数の入力ストリームを受け取り、それらを特定のルールに基づいて一つの出力ストリームに統合する**役割を担います。

これにより、異なるイベントソースからの情報を同期させたり、特定の条件が揃ったときにのみ処理を実行したり、といった複雑な連携処理を宣言的に記述できます。

### `merge`：複数のストリームを一つにまとめる（発行順はそのまま）

`merge` 演算子は、複数の入力ストリームを**一つに合流**させ、いずれかの入力ストリームから値が発行されるたびに、その値をそのまま出力ストリームに発行します。値が発行される順序は、入力ストリームからの発行タイミングに依存します（つまり、早く来たものから順に流れます）。

- **動作:** 複数のストリームを引数に取ります。どの入力ストリームから値が発行されても、その値を即座に出力ストリームに流します。すべての入力ストリームが完了した時点で、出力ストリームも完了します。いずれかの入力ストリームがエラーを発行すると、出力ストリームもそのエラーで終了します。
- **用途:**
  - 複数の異なる種類のイベント（例: ボタン A のクリックとボタン B のクリック）を、同じ種類の通知として扱いたい場合。
  - 複数のデータソースからの更新情報を、単一のストリームでまとめて監視したい場合。

```javascript
// 例: RxJS (JavaScript)
// import { fromEvent, interval } from 'rxjs';
// import { map, merge, take } from 'rxjs/operators';

const clicksA$ = fromEvent(document.getElementById("buttonA"), "click").pipe(
  map(() => "A")
);
const clicksB$ = fromEvent(document.getElementById("buttonB"), "click").pipe(
  map(() => "B")
);
const timer$ = interval(1000).pipe(
  map((i) => `Timer ${i}`),
  take(3)
); // 0, 1, 2

const mergedStream$ = merge(clicksA$, clicksB$, timer$);

// mergedStream$.subscribe(value => console.log(value));
// 出力例 (ボタンのクリックやタイマーのタイミングで順不同に発行):
// Timer 0 (1秒後)
// A (ボタンAクリック時)
// Timer 1 (2秒後)
// B (ボタンBクリック時)
// Timer 2 (3秒後)
// ...
```

`merge` は、複数の非同期イベントソースを単純に「混ぜ合わせる」ための基本的な演算子です。

### `concat`：複数のストリームを順番に繋げる

`concat` 演算子は、複数の入力ストリームを**順番に連結**します。最初の入力ストリームが完了 (complete) してから、次の入力ストリームの購読を開始し、その値を発行します。これがすべての入力ストリームに対して繰り返されます。

- **動作:** 複数のストリームを引数に取ります。最初のストリームの値を発行し、それが完了したら、2 番目のストリームの購読を開始してその値を発行し…というように、順番に処理します。すべての入力ストリームが完了した時点で、出力ストリームも完了します。途中でいずれかのストリームがエラーを発行すると、出力ストリームもそのエラーで終了します。
- **用途:**
  - 複数の非同期処理を、前の処理が完了するのを待ってから順番に実行したい場合（Promise の `.then()` チェーンに似た振る舞いをストリームで実現）。
  - 最初にキャッシュされたデータを表示し、それが完了したらネットワークから最新のデータを取得して表示する、といったシーケンス。

```javascript
// 例: RxJS
// import { of, interval } from 'rxjs';
// import { concat, take, delay } from 'rxjs/operators';

const stream1$ = of(1, 2, 3).pipe(delay(500)); // 0.5秒後に 1, 2, 3 を発行して完了
const stream2$ = interval(300).pipe(
  take(2),
  map((i) => `B${i}`)
); // 0.3秒ごとに B0, B1 を発行して完了

const concattedStream$ = concat(stream1$, stream2$);

// concattedStream$.subscribe(value => console.log(value));
// 出力:
// (0.5秒後) 1
// (続けて) 2
// (続けて) 3
// (stream1$完了後、0.3秒後) B0
// (さらに0.3秒後) B1
```

`concat` は、ストリームの実行順序を保証したい場合に有効です。

### `combineLatest`：複数のストリームの最新値を組み合わせて発行する

`combineLatest` 演算子は、複数の入力ストリームを監視し、**いずれかの入力ストリームが新しい値を発行するたびに**、**すべての入力ストリームの最新の値の組み合わせ**を出力ストリームに発行します。

- **動作:** 複数のストリームを引数に取ります。
  1. すべての入力ストリームが少なくとも一度は値を発行するまで待機します。
  2. いずれかの入力ストリームが新しい値を発行すると、その時点での**各入力ストリームの最新の値**を取得し、それらを配列（または指定された結合関数で処理した結果）として出力ストリームに発行します。
  3. すべての入力ストリームが完了した時点で、出力ストリームも完了します。
- **用途:**
  - 複数の独立した状態（例: フォームの複数の入力フィールドの値、異なるセンサーの最新値）を組み合わせて、現在の全体的な状態を導き出したい場合。
  - ユーザーの選択（例: 色、サイズ）と商品の在庫状況（非同期で更新される）の両方を考慮して、購入可能かどうかをリアルタイムに判定したい場合。

```javascript
// 例: RxJS
// import { timer, combineLatest } from 'rxjs';
// import { map, startWith, take } from 'rxjs/operators';

const weight$ = timer(0, 1000).pipe(
  map((i) => 50 + i * 2),
  take(3),
  startWith(50)
); // 0秒:50, 1秒:52, 2秒:54
const height$ = timer(500, 1500).pipe(
  map((i) => 160 + i * 5),
  take(2),
  startWith(160)
); // 0.5秒:160, 2秒:165

const bmiStream$ = combineLatest([weight$, height$]).pipe(
  map(([weight, height]) => {
    const heightM = height / 100;
    const bmi = weight / (heightM * heightM);
    return `体重: ${weight}kg, 身長: ${height}cm => BMI: ${bmi.toFixed(1)}`;
  })
);

// bmiStream$.subscribe(console.log);
// 出力イメージ (タイミングによって発行される値と順序が変わる):
// (0.5秒後くらい) 体重: 50kg, 身長: 160cm => BMI: 19.5 (height$ が最初に発行、weight$ は startWith の 50)
// (1秒後くらい)   体重: 52kg, 身長: 160cm => BMI: 20.3 (weight$ が発行)
// (2秒後くらい)   体重: 54kg, 身長: 165cm => BMI: 19.8 (weight$ と height$ がほぼ同時に発行 (先にweight$の54, 次にheight$の165))
```

`combineLatest` は、複数の動的な値を常に組み合わせて最新の状態を反映させたい場合に非常に便利です。

### `zip`：複数のストリームの値をペア（タプル）にして発行する

`zip` 演算子は、複数の入力ストリームから、**それぞれのストリームの同じインデックス（発行順）の値**をペア（またはタプル、あるいは指定された結合関数で処理した結果）にして、出力ストリームに発行します。

- **動作:** 複数のストリームを引数に取ります。すべての入力ストリームが、対応するインデックスの値を発行するまで待機し、それらが揃ったら、それらを組み合わせて出力します。いずれかの入力ストリームが完了し、それ以上ペアを作れなくなったら、出力ストリームも完了します。
- **用途:**
  - 関連する異なる種類のデータを、同じタイミングで発行されたもの同士でペアリングしたい場合。
  - アニメーションで、X 座標のストリームと Y 座標のストリームを組み合わせて、(X, Y) 座標のストリームを作るなど。

```javascript
// 例: RxJS
// import { interval, zip } from 'rxjs';
// import { map, take } from 'rxjs/operators';

const streamA$ = interval(1000).pipe(
  map((i) => `A${i}`),
  take(3)
); // A0, A1, A2
const streamB$ = interval(700).pipe(
  map((i) => `B${i}`),
  take(4)
); // B0, B1, B2, B3

const zippedStream$ = zip(streamA$, streamB$);

// zippedStream$.subscribe(valuePair => console.log(valuePair));
// 出力:
// (約1秒後)  [ 'A0', 'B0' ]  (streamA$がA0, streamB$がB0を発行するのを待つ)
// (約2秒後)  [ 'A1', 'B1' ]  (streamA$がA1, streamB$がB1を発行するのを待つ)
// (約2.8秒後)[ 'A2', 'B2' ]  (streamA$がA2, streamB$がB2を発行するのを待つ)
// streamA$ が完了したので、zippedStream$ もここで完了 (B3 は使われない)
```

`zip` は、複数のストリーム間で値の「同期」を取りたい場合に有効です。

### `forkJoin`：複数のストリームがすべて完了した時点で最後の値の組を発行する (`Promise.all` に似る)

`forkJoin` 演算子は、`Promise.all()` の振る舞いに非常に似ています。複数の入力ストリームを引数に取り、**すべての入力ストリームが完了した時点で、各ストリームが最後に発行した値**を配列（または指定された結合関数で処理した結果）として、一度だけ発行し、その後出力ストリームも完了します。

- **動作:** すべての入力ストリームが完了するのを待ちます。もし、いずれかの入力ストリームが値を一つも発行せずに完了した場合、`forkJoin` も値を何も発行せずに完了します。いずれかの入力ストリームがエラーを発行すると、`forkJoin` もそのエラーで即座に終了します。
- **用途:**
  - 複数の独立した非同期タスク（それぞれがストリームとして表現される）がすべて完了するのを待ち、それらの最終結果をまとめて処理したい場合。
  - 初期化処理などで、複数の設定値やリソースがすべてロードされるのを待ってからアプリケーションを開始したい場合。

```javascript
// 例: RxJS
// import { of, timer, forkJoin } from 'rxjs';
// import { delay, map, startWith } from 'rxjs/operators';

const source1$ = of("Result A").pipe(delay(1000)); // 1秒後に "Result A" を発行して完了
const source2$ = timer(1500).pipe(map(() => "Result B")); // 1.5秒後に "Result B" を発行して完了
const source3$ = of("Result C").pipe(startWith("Initial C")); // "Initial C" を発行し、すぐに "Result C" を発行して完了

const joinedStream$ = forkJoin([source1$, source2$, source3$]);

// joinedStream$.subscribe(
//   results => console.log("forkJoin 結果:", results), // results は ["Result A", "Result B", "Result C"]
//   err => console.error(err),
//   () => console.log("forkJoin 完了")
// );
// 出力イメージ (約1.5秒後、source2$ が最後に完了するタイミング):
// forkJoin 結果: [ 'Result A', 'Result B', 'Result C' ]
// forkJoin 完了
```

`forkJoin` は、複数の非同期処理の「最終結果」をまとめて扱いたい場合に便利ですが、すべてのストリームが完了するまで待つ、という点に注意が必要です。

これらの合成系演算子は、イベントストリームをレゴブロックのように組み合わせ、複雑な非同期の依存関係やデータフローを、宣言的かつ柔軟に構築するための強力な手段を提供してくれます。

## 高階マッピング演算子（内部ストリームの扱い）：非同期処理の連鎖をフラットに

これまでの変換系演算子（`map` など）は、ストリームを流れる「値」を別の「値」に変換していました。しかし、実際のアプリケーションでは、**ストリームを流れる値に基づいて、さらに別の非同期処理（つまり、別のストリーム）を開始し、その結果を扱いたい**というケースが非常に多くあります。

たとえば、

- ユーザー ID のストリームがあり、各ユーザー ID に対して、そのユーザーの詳細情報を取得する API 呼び出し（これもストリームまたは Promise）を行いたい。
- 検索キーワードの入力ストリームがあり、各キーワードに対して、検索結果を取得する非同期リクエストを送信したい。

もし、ここで `map` 演算子を使ってしまうと、`map(userId => fetchUserDetails(userId))` のような形になり、結果のストリームは「Promise のストリーム」や「Observable のストリーム」（**高階 Observable / Higher-Order Observable** と呼ばれます。ストリームのストリーム、という入れ子構造）になってしまいます。これでは、内側のストリームの結果を直接扱うのが難しくなります。

このような「ストリームのストリーム」を「平坦化 (flatten)」し、内側のストリームが発行する値を直接下流に流すようにしてくれるのが、「**高階マッピング演算子 (Higher-Order Mapping Operators)**」です。これらの演算子は、入力ストリームの各値に対して、新しい「**内部ストリーム (Inner Observable)**」を生成する関数を適用し、それらの内部ストリームが発行する値を、特定の戦略に基づいて一つの出力ストリームに統合（マージ）します。

モナドのセクションで学んだ `flatMap` (または `bind`) の考え方に非常に近いものであり、非同期処理の連鎖をエレガントに記述するための鍵となります。

### `mergeMap` (または `flatMap`)：各値を新しいストリームに変換し、結果をマージする

`mergeMap`（多くのライブラリで `flatMap` という名前でも知られています）は、もっとも基本的な高階マッピング演算子です。

- **動作:**
  1.  入力ストリーム（**外部ストリーム / Outer Observable**）から値が発行されるたびに、指定された関数を適用します。
  2.  この関数は、受け取った値に基づいて新しい**内部ストリーム (Inner Observable)** を返します。
  3.  `mergeMap` は、生成されたすべての内部ストリームを**並行して購読**し、いずれかの内部ストリームから値が発行されるたびに、その値を**そのまま出力ストリームにマージして発行**します。
  4.  すべての内部ストリームが完了し、かつ外部ストリームも完了した時点で、出力ストリームも完了します。（エラー処理も適切に行われます。）
- **特徴:**
  内部ストリームの実行順序や完了順序は保証されません。発行された順にマージされます（`merge` 演算子の振る舞いに似ています）。
- **用途:**
  - 複数の非同期リクエストを並行して発行し、それらの結果を到着順に処理したい場合。
  - あるイベント（例: クリック）に応じて、複数の独立したアニメーションやデータ取得処理（それぞれがストリーム）を開始したい場合。

```javascript
// 例: RxJS (JavaScript)
// import { fromEvent, interval } from 'rxjs';
// import { mergeMap, map, take } from 'rxjs/operators';

const clickStream$ = fromEvent(document.getElementById("myButton"), "click");

// 各クリックに対して、0, 1, 2 を 0.5秒間隔で発行する内部ストリームを生成
const resultStream$ = clickStream$.pipe(
  mergeMap((clickEvent) => {
    console.log("クリック発生！内部ストリームを開始します。");
    return interval(500).pipe(
      // これが内部ストリーム
      map((i) => `クリック ${clickEvent.timeStamp} の結果 ${i}`),
      take(3) // 各内部ストリームは3回発行して完了
    );
  })
);

// resultStream$.subscribe(value => console.log(value));
// 出力イメージ (ボタンを連続でクリックした場合):
// クリック発生！内部ストリームを開始します。 (1回目のクリック)
// クリック発生！内部ストリームを開始します。 (2回目のクリック、1回目が完了する前でも開始)
// クリック [タイムスタンプ1] の結果 0 (0.5秒後)
// クリック [タイムスタンプ2] の結果 0 (0.5秒後、1回目のクリックから約0.5秒＋α)
// クリック [タイムスタンプ1] の結果 1 (1秒後)
// クリック [タイムスタンプ2] の結果 1 (1秒後＋α)
// ... といったように、複数の内部ストリームが並行して値をマージして発行する
```

### `switchMap`：各値を新しいストリームに変換し、新しい値が来たら前の内部ストリームをキャンセルする

`switchMap` は、`mergeMap` と似ていますが、外部ストリームから新しい値が発行された際の内部ストリームの扱いに重要な違いがあります。

- **動作:**
  1.  外部ストリームから値が発行されるたびに、指定された関数を適用し、新しい内部ストリームを生成して購読を開始します。
  2.  **もし、現在の内部ストリームがまだ完了していない状態で、外部ストリームから次の新しい値が発行された場合、`switchMap` は現在の内部ストリームの購読をキャンセル（停止）し、新しい値に基づいて生成された新しい内部ストリームに「切り替え (switch)」ます。**
  3.  出力ストリームには、その時点でアクティブな（最後に切り替えられた）内部ストリームが発行する値だけが流れます。
- **特徴:**
  常に最新の外部ストリームの値に対応する内部ストリームの結果だけに関心がある場合に非常に有効です。「古いリクエストの結果はもう不要なので、新しいリクエストの結果を優先したい」というシナリオに適しています。
- **用途:**
  - **検索ボックスのオートコンプリート:** ユーザーが文字を入力するたびに検索 API を叩くが、入力が速い場合、古いキーワードでの検索結果はもはや不要なのでキャンセルし、最新のキーワードでの検索結果だけを表示したい。
  - キャンセル可能な非同期処理の制御：ある操作を開始し、ユーザーが別の操作をしたら前の操作を中断したい場合。

```javascript
// 例: RxJS
// import { fromEvent, interval } from 'rxjs';
// import { switchMap, map, take, debounceTime } from 'rxjs/operators';

const inputStream$ = fromEvent(document.getElementById("searchInput"), "input");

const searchResults$ = inputStream$.pipe(
  debounceTime(300), // 300ms入力がなければ最新の値を通す (頻繁なAPI呼び出しを防ぐ)
  map((event) => event.target.value), // input要素の値を取得
  switchMap((searchTerm) => {
    console.log(`「${searchTerm}」で検索APIを呼び出します...`);
    // return fakeHttpSearch(searchTerm); // 検索APIを叩く非同期処理 (PromiseやObservableを返す)
    // 以下はシミュレーション用の内部ストリーム
    return interval(500).pipe(
      map((i) => `「${searchTerm}」の結果 ${i}`),
      take(2)
    );
  })
);

// searchResults$.subscribe(result => console.log(result));
// 動作イメージ:
// 1. ユーザーが "a" と入力 → (300ms後) 「a」で検索API呼び出し...
// 2. (0.5秒後) 「a」の結果 0 が発行
// 3. ユーザーがすぐに "ab" と入力 → (300ms後) 「ab」で検索API呼び出し...
//    ★この時点で、"a" の検索結果ストリームはキャンセルされる！
// 4. (0.5秒後) 「a」の結果 1 は発行されない (キャンセルされたため)
// 5. (「ab」の検索開始から0.5秒後) 「ab」の結果 0 が発行
// 6. (「ab」の検索開始から1秒後) 「ab」の結果 1 が発行
```

### `concatMap`：各値を新しいストリームに変換し、結果を順番に繋げる

`concatMap` は、外部ストリームから発行された値の**順序を維持**しつつ、各値に対応する内部ストリームを順番に実行・完了させてから、次の内部ストリームの実行を開始します。

- **動作:**
  1.  外部ストリームから値が発行されるたびに、指定された関数を適用し、新しい内部ストリームを生成します。
  2.  しかし、`mergeMap` とは異なり、**前の内部ストリームが完了するまで、次の内部ストリームの購読を開始しません**。
  3.  すべての内部ストリームが、外部ストリームからの発行順序と同じ順序で、次々と実行され、その結果が出力ストリームに連結（`concat`）されていきます。
- **特徴:**
  処理の順序性が重要で、かつ各非同期処理が完了するのを待ってから次に進みたい場合に有効です。
- **用途:**
  - 複数のファイルを順番にアップロードし、それぞれの結果を順序通りに受け取りたい場合。
  - 一連の API 呼び出しがあり、前の呼び出しの結果を次の呼び出しの入力として使う必要があるが、各ステップが非同期である場合（ただし、Promise の `.then()` チェーンの方が素直な場合もある）。

```javascript
// 例: RxJS
// import { fromEvent, interval } from 'rxjs';
// import { concatMap, map, take } from 'rxjs/operators';

const clickStream_concat$ = fromEvent(
  document.getElementById("orderedButton"),
  "click"
);

const resultStream_concat$ = clickStream_concat$.pipe(
  concatMap((clickEvent) => {
    const clickId = Math.floor(clickEvent.timeStamp % 1000); // 簡単なID
    console.log(
      `クリック ${clickId}: 内部ストリームを開始 (前のものが完了するまで待機)`
    );
    return interval(700).pipe(
      map((i) => `クリック ${clickId} の結果 ${i}`),
      take(2) // 各内部ストリームは2回発行して完了
    );
  })
);

// resultStream_concat$.subscribe(value => console.log(value));
// 動作イメージ (ボタンを連続でクリックしても、内部ストリームは順番に実行される):
// クリック 123: 内部ストリームを開始 (前のものが完了するまで待機)
// (0.7秒後) クリック 123 の結果 0
// (1.4秒後) クリック 123 の結果 1
// (1.4秒後、クリック456の処理開始) クリック 456: 内部ストリームを開始 (前のものが完了するまで待機)
// (2.1秒後) クリック 456 の結果 0
// (2.8秒後) クリック 456 の結果 1
```

### `exhaustMap`：各値を新しいストリームに変換するが、前の内部ストリームが完了するまで新しい値は無視する

`exhaustMap` は、`switchMap` とは逆の振る舞いをします。

- **動作:**
  1.  外部ストリームから値が発行されると、指定された関数を適用し、新しい内部ストリームを生成して購読を開始します。
  2.  **もし、現在の内部ストリームがまだ完了していない状態で、外部ストリームから次の新しい値が発行された場合、`exhaustMap` はその新しい値を無視します。**
  3.  現在の内部ストリームが完了した後で、外部ストリームから新しい値が発行されれば、その時点で再び新しい内部ストリームの生成・購読が開始されます。
- **特徴:**
  一度開始した非同期処理が完了するまでは、他の同様のトリガーを無視したい場合に有効です。「処理中は他の要求を受け付けない」というセマンティクスを実現します。
- **用途:**
  - ログインボタンなど、一度クリックしたら処理が完了するまで、連続クリックを無視したい場合。
  - リソースを大量に消費する処理を開始したら、それが終わるまでは次の同様の処理を開始させたくない場合。

```javascript
// 例: RxJS
// import { fromEvent, interval } from 'rxjs';
// import { exhaustMap, map, take, tap } from 'rxjs/operators';

const clickStream_exhaust$ = fromEvent(
  document.getElementById("onceButton"),
  "click"
);

const resultStream_exhaust$ = clickStream_exhaust$.pipe(
  tap(() => console.log("ボタンがクリックされました！ (exhaustMap)")),
  exhaustMap((clickEvent) => {
    const clickId = Math.floor(clickEvent.timeStamp % 1000);
    console.log(
      `  クリック ${clickId}: 内部ストリーム処理を開始します (完了まで他は無視)`
    );
    return interval(1000).pipe(
      // 1秒ごとに発行する内部ストリーム
      map((i) => `  クリック ${clickId} の処理結果 ${i}`),
      take(3), // 3回発行で完了 (計3秒かかる)
      tap({
        complete: () =>
          console.log(`  クリック ${clickId}: 内部ストリーム完了`),
      })
    );
  })
);

// resultStream_exhaust$.subscribe(value => console.log(value));
// 動作イメージ:
// ボタンがクリックされました！ (exhaustMap)
//   クリック 123: 内部ストリーム処理を開始します (完了まで他は無視)
// (1秒後)   クリック 123 の処理結果 0
// (もしこの間に再度ボタンがクリックされても、ログは出るが exhaustMap は無視する)
// ボタンがクリックされました！ (exhaustMap)  <-- 無視される
// (2秒後)   クリック 123 の処理結果 1
// (3秒後)   クリック 123 の処理結果 2
//   クリック 123: 内部ストリーム完了
// (この後にボタンがクリックされれば、新しい内部ストリームが開始される)
```

これらの高階マッピング演算子 (`mergeMap`, `switchMap`, `concatMap`, `exhaustMap`) は、非同期処理の連鎖や、外部イベントに応じて動的に開始される内部ストリームのライフサイクルを、非常に柔軟かつ宣言的に制御するための強力なツールです。それぞれの演算子が持つ「内部ストリームをどのように扱うか」という戦略の違いを理解し、解決したい問題の性質に合わせて適切なものを選択することが、複雑な非同期データフローをエレガントに構築する鍵となります。

## 時間制御系演算子：イベントのタイミングを操る

イベントストリームは、その名の通り「時間」という概念と密接に結びついています。値がいつ発行されるか、どのくらいの頻度で発行されるか、あるいは発行されるタイミングをどのように調整するか、といった時間的な側面を制御することは、インタラクティブな UI やリアルタイムなデータ処理において非常に重要です。

FRP ライブラリは、この時間軸を巧みに操るための、多種多様な「時間制御系演算子」を提供しています。これらを活用することで、イベントの洪水を制御したり、ユーザー体験を向上させたり、あるいは特定のリズムで処理を実行したりすることができます。

### `delay` / `delayWhen`：発行を遅延させる

- **`delay(dueTime, scheduler?)`:**
  入力ストリームの**各値（または完了/エラー通知）の発行を、指定された時間 (`dueTime` ミリ秒、または Date オブジェクト) だけ遅延**させます。元のストリームの各値間の相対的な時間間隔は維持されます。オプションでスケジューラを指定できます。

  ```javascript
  // of(1, 2, 3).pipe(delay(1000))
  // 1秒後に 1、さらに (元の発行タイミングから) 1秒後に 2、... と発行される
  ```

- **`delayWhen(delayDurationSelector, subscriptionDelay?)`:**
  入力ストリームの各値に対して `delayDurationSelector` 関数を適用し、その関数が返す Observable（**期間 Observable / Duration Observable**）が最初の値を発行するか完了するまで、元の値の発行を遅延させます。より動的に遅延時間を制御したい場合に有効です。

### `debounceTime` / `debounce`：連続するイベントを間引く（最後の安定した値）

ユーザーの連続的な入力（例: 検索ボックスへのキー入力、ウィンドウのリサイズ）に対して、入力があるたびに処理を実行すると、パフォーマンスが悪化したり、不要な API 呼び出しが発生したりします。`debounce` 系の演算子は、このような「**イベントの洪水」の中から、意味のある最後のイベントだけを取り出す**のに役立ちます。

- **`debounceTime(dueTime, scheduler?)`:**
  入力ストリームから値が発行された後、指定された時間 (`dueTime`) 内に新しい値が発行されなければ、その**最後に発行された値**を出力ストリームに流します。もし `dueTime` 内に新しい値が来たら、タイマーはリセットされ、再び新しい値の到着を待ちます。
  **用途:** ユーザーの入力が「落ち着いた」タイミングで処理を実行したい場合（例: 検索キーワードの入力が止まってから 300ms 後に API 検索を開始）。

  ```javascript
  // inputStream$.pipe(debounceTime(300))
  // ユーザーが "abc" と素早く入力した場合、"a", "ab" は無視され、
  // "abc" の入力後 300ms 他の入力がなければ "abc" が発行される。
  ```

- **`debounce(durationSelector)`:**
  `debounceTime` と似ていますが、静的な待機時間ではなく、各値に対して `durationSelector` 関数を適用し、その関数が返す Observable（期間 Observable）が値を発行するか完了するまで、元の値の出力を遅延させます。より動的に「落ち着き時間」を制御できます。

### `throttleTime` / `throttle`：一定期間内の最初の（または最後の）イベントだけを通す

`debounce` が「イベントが止まるのを待つ」のに対し、`throttle` 系の演算子は、「**一定期間内に高頻度で発生するイベントを、最初の（または最後の）一つだけに間引く**」という振る舞いをします。

- **`throttleTime(duration, scheduler?, config?)`:**
  入力ストリームから値が発行されると、その値を出力ストリームに流し、その後、指定された期間 (`duration`) は入力ストリームからの新しい値を無視します。期間が過ぎた後、再び入力ストリームから値が発行されれば、それを出力し、また期間中は無視…という動作を繰り返します。オプションの `config` で、期間の開始時に発行するか (`leading: true`)、終了時に発行するか (`trailing: true`) を制御できます。
  **用途:** マウスの連続移動イベントや、スクロールイベントなど、非常に高頻度で発生するイベントの処理回数を制限し、パフォーマンスを維持したい場合。

  ```javascript
  // mouseMoveStream$.pipe(throttleTime(100))
  // マウスが動いている間、100ms ごとに最大1回だけ、その時点のマウス座標を発行する。
  ```

- **`throttle(durationSelector, config?)`:**
  `debounce` と同様に、静的な期間ではなく、各値に対して `durationSelector` 関数が返す期間 Observable に基づいてスロットリング（間引き）を行います。

### `auditTime` / `audit`：一定期間ごとに最新の値を発行する

`audit` 系の演算子は、入力ストリームを監視し、指定された期間が経過するたびに、その**期間中に発行された最新の値**を出力ストリームに流します。

- **`auditTime(duration, scheduler?)`:**
  指定された期間 (`duration`) ごとにサンプリングウィンドウを開き、そのウィンドウが閉じる（期間が経過する）時点で、そのウィンドウ内で入力ストリームから発行された**最後の値**を出力します。もしウィンドウ内で値が発行されなければ、何も出力しません。
  **用途:** 定期的に最新の状態を取得したいが、すべての変更をリアルタイムに追跡する必要はない場合。

### `sampleTime` / `sample`：一定期間ごとに最新の値を取得する

`sample` 系の演算子は、`audit` と似ていますが、サンプリングのタイミングや条件が異なります。

- **`sampleTime(period, scheduler?)`:**
  指定された期間 (`period`) ごとに、その時点までに入力ストリームから発行された**最新の値**を出力します。もしその期間内に新しい値が発行されていなければ、何も出力しません。
- **`sample(notifierObservable)`:**
  `notifierObservable` が値を発行するたびに、その時点までに入力ストリームから発行された最新の値を出力します。

### `timeout` / `timeoutWith`：タイムアウト処理

非同期処理が期待した時間内に完了しない場合に、エラーとして扱いたい（タイムアウトさせたい）ことがあります。

- **`timeout(due, scheduler?)` / `timeout(config)`:**
  入力ストリーム（またはその各値）が、指定された時間 (`due` ミリ秒または Date) 内に次の値を発行しない（あるいは完了しない）場合、出力ストリームはエラー通知を発行して終了します。`config` オブジェクトで、いつタイムアウトするか（最初の値か、各値か）、タイムアウト時に返す Observable を指定できます。
- **`timeoutWith(due, withObservable, scheduler?)`:**
  タイムアウトした場合に、エラーを発行する代わりに、指定された別の `withObservable` に切り替えます。

### `buffer` / `bufferTime` / `bufferCount` / `bufferToggle` / `bufferWhen`：値をバッファリングする

ストリームの値を個別に処理するのではなく、ある程度の期間や個数ごとに**まとめて（配列として）処理したい**場合に、`buffer` 系の演算子が役立ちます。

- **`bufferTime(bufferTimeSpan, bufferCreationInterval?, maxBufferSize?, scheduler?)`:**
  指定された時間 (`bufferTimeSpan`) ごとに、その間にストリームから発行された値を配列としてまとめて発行します。オプションで、バッファを新規作成する間隔や、バッファの最大サイズも指定できます。
- **`bufferCount(bufferSize, startBufferEvery?)`:**
  指定された個数 (`bufferSize`) の値がストリームから発行されるたびに、それらを配列としてまとめて発行します。オプションで、新しいバッファを開始する間隔（値の個数）も指定できます。
- **その他 (`buffer`, `bufferToggle`, `bufferWhen`):**
  より複雑な条件（別の Observable が発行するタイミングなど）でバッファの開始と終了を制御できます。

### `window` / `windowTime` / `windowCount` / `windowToggle` / `windowWhen`：値をウィンドウ（別の Observable）に分割する

`buffer` 系が値を配列としてまとめるのに対し、`window` 系演算子は、入力ストリームの値を、**Observable の Observable (高階 Observable)**、つまり「**Observable のストリーム**」として分割します。各内部 Observable（ウィンドウ）は、元のストリームの一部分の値を持ちます。

- **用途:** グループ化されたイベントに対して、それぞれ独立したストリーム処理を行いたい場合など、より高度な制御が可能です。

これらの時間制御系演算子は、非同期イベントの時間的な側面を巧みに扱うための、関数型リアクティブプログラミングの強力な表現力を示しています。最初は多くの種類があって戸惑うかもしれませんが、それぞれの演算子がどのような「時間の流れのパターン」を扱おうとしているのかを理解し、問題に応じて適切なものを選択できるようになると、UI のインタラクションやリアルタイムデータの処理が格段に洗練されるでしょう。

## エラーハンドリング演算子：失敗に備える

非同期処理やイベントストリームでは、エラーの発生は避けられません。ネットワークの問題、API のエラーレスポンス、予期せぬデータの処理など、様々な要因でストリームがエラー状態に陥る可能性があります。FRP ライブラリは、これらのエラーに適切に対処し、アプリケーションの堅牢性を高めるための「エラーハンドリング演算子」を提供しています。

これらの演算子は、ストリームがエラー通知を発行した場合に介入し、エラーを回復させたり、処理をリトライしたり、あるいは代替の処理フローに切り替えたりする役割を担います。

### `catchError` (または `onErrorResumeNext`)：エラー発生時に別のストリームに切り替えるか、エラーを処理する

`catchError`（多くのライブラリで `onErrorResumeNext` という名前の場合もあります）は、入力ストリームでエラーが発生した際に、その**エラーを捕捉し、代わりに別の Observable を購読して処理を継続させる**か、あるいは**エラーを新しいエラーとして再スロー（または新しい種類のストリームに変換）する**ことを可能にする、もっとも基本的なエラーハンドリング演算子です。

- **動作:**
  入力ストリームがエラー通知を発行すると、`catchError` に渡された**エラーハンドリング関数** `(error, caughtObservable) => ObservableInput` が呼び出されます。
  - この関数は、引数としてエラーオブジェクト `error` と、エラーが発生した元のストリーム（の再試行版）`caughtObservable` を受け取ります。
  - この関数は、**新しい Observable (ObservableInput)** を返す必要があります。
    - もし、エラーから回復して正常な値を流したい場合は、その値を含む新しい Observable（例: `of(defaultValue)`）を返します。
    - もし、エラーを別の種類のエラーとして伝えたい場合は、エラーを発行する新しい Observable（例: `throwError(newCustomError)`）を返します。
    - もし、元のストリームの処理をリトライしたい場合は、引数の `caughtObservable` をそのまま返すことで再購読を試みることができます（ただし、無限ループに注意が必要なため、通常は `retry` 演算子を使います）。
- **用途:**
  - API 呼び出しが失敗した場合に、キャッシュされたデータを返す、あるいはデフォルト値を表示する。
  - 特定の種類のエラーを、よりアプリケーションに適したエラー型に変換する。
  - エラー発生時に、ユーザーにフレンドリーなエラーメッセージを表示するための処理を挟む。

```javascript
// 例: RxJS (JavaScript)
// import { of, throwError, timer } from 'rxjs';
// import { ajax } from 'rxjs/ajax'; // HTTPリクエスト用
// import { map, catchError, switchMap } from 'rxjs/operators';

// APIからデータを取得する関数 (失敗する可能性あり)
function fetchDataWithPotentialError(url) {
  return ajax.getJSON(url).pipe(
    catchError((error) => {
      console.error(`APIエラー (${url}):`, error.message);
      // 代わりにデフォルトの空配列を返すObservableに切り替える
      // return of([]); // パターン1: エラーから回復してデフォルト値を返す

      // あるいは、アプリケーション固有のエラーをスローするObservableを返す
      return throwError(
        () => new Error(`データ取得に失敗しました: ${error.status}`)
      ); // パターン2
    })
  );
}

// fetchDataWithPotentialError("/api/non-existent-data")
//   .subscribe({
//     next: data => console.log("データ受信:", data),
//     error: err => console.error("最終的なエラー:", err.message)
//   });
```

### `retry` / `retryWhen`：エラー発生時にストリームの購読を再試行する

一時的なネットワークの不安定さなどが原因で非同期処理が失敗した場合、少し時間をおいてから再試行すれば成功することがあります。`retry` および `retryWhen` 演算子は、このような**エラー発生時の自動リトライ処理**を実現します。

- **`retry(count?)`:**
  入力ストリームがエラーを発行した場合、指定された回数 (`count`) だけ、そのストリームの購読を**即座に再試行**します。`count` を指定しない場合、無限にリトライを試みます（注意が必要）。リトライしても成功しない場合は、最終的にエラーが出力ストリームに流れます。
  **用途:** 一時的なエラーからの自動回復を期待する場合。

- **`retryWhen(notifierFunction)`:**
  より高度なリトライ戦略を実装するための演算子です。入力ストリームがエラーを発行すると、そのエラーを通知する Observable（エラー通知ストリーム）が `notifierFunction` に渡されます。`notifierFunction` は、このエラー通知ストリームを受け取り、**新しい Observable（通知用ストリーム）**を返す必要があります。
  - もし `notifierFunction` が返す通知用ストリームが**値を発行**すると、元の入力ストリームの購読が再試行されます。
  - もし通知用ストリームが**エラーを発行**すると、リトライは行われず、そのエラーが出力ストリームに流れます。
  - もし通知用ストリームが**完了**すると、リトライは行われず、出力ストリームも完了します。
    **用途:**
    - リトライの間隔を制御したい（例: 指数バックオフリトライ）。
    - 特定の種類のエラーの場合のみリトライしたい。
    - 一定回数リトライしてもダメなら諦める、といった複雑なロジック。

```javascript
// 例: RxJS (retry)
// import { interval, throwError, of } from 'rxjs';
// import { mergeMap, retry, delay, tap } from 'rxjs/operators';
let attempt = 0;
const problematicStream$ = interval(500).pipe(
  mergeMap((val) => {
    attempt++;
    if (attempt < 3) {
      // 最初の2回はエラーを発生させる
      console.log(`試行 ${attempt}: エラーを発生させます`);
      return throwError(() => new Error(`試行 ${attempt} でエラー`));
    }
    console.log(`試行 ${attempt}: 成功！ 値: ${val}`);
    return of(`成功データ (試行 ${attempt}, 元の値 ${val})`);
  }),
  retry(3) // 最大3回までリトライ (最初のエラー + 2回のリトライ)
);

// problematicStream$.subscribe({
//   next: value => console.log("受信:", value),
//   error: err => console.error("最終エラー:", err.message),
//   complete: () => console.log("完了")
// });
/*
出力イメージ:
試行 1: エラーを発生させます
試行 2: エラーを発生させます (1回目のリトライ)
試行 3: 成功！ 値: 0 (2回目のリトライで成功)
受信: 成功データ (試行 3, 元の値 0)
試行 4: 成功！ 値: 1
受信: 成功データ (試行 4, 元の値 1)
... (以降は成功し続ける)
*/

// 例: RxJS (retryWhen で指数バックオフ)
// import { timer } from 'rxjs';
// import { retryWhen, delayWhen, tap, scan } from 'rxjs/operators';
// source$.pipe(
//   retryWhen(errors =>
//     errors.pipe(
//       scan((retryCount, err) => {
//         if (retryCount >= 2) { // 最大2回リトライ
//           throw err; // 諦めてエラーを再スロー
//         }
//         return retryCount + 1;
//       }, 0),
//       delayWhen(retryCount => timer(retryCount * 1000)), // 0秒, 1秒, 2秒... と遅延
//       tap(retryCount => console.log(`${retryCount * 1000}ms 後にリトライします...`))
//     )
//   )
// )
```

これらのエラーハンドリング演算子を適切に使うことで、非同期処理の失敗に対してより堅牢で、回復力のあるアプリケーションを構築できます。「失敗は成功のもと」と言いますが、FRP の世界では、「失敗は別のストリームの始まり」とも言えるかもしれません。

## ユーティリティ演算子

イベントストリームを操作する際には、変換、フィルタリング、合成、エラーハンドリングといった主要なカテゴリの演算子以外にも、デバッグ、ロギング、あるいは特定の補助的な処理を行うための便利な「ユーティリティ演算子」が数多く存在します。これらは、ストリームの振る舞いを理解したり、開発中の問題を特定したり、あるいはストリームのライフサイクルに特定の処理をフックしたりするのに役立ちます。

### `tap` (または `do`)：副作用（ロギングなど）を実行する

`tap`（一部のライブラリでは `do` という名前）演算子は、ストリームを流れる値、エラー、あるいは完了通知を**傍受（タップする）**し、それらの通知に対して**副作用（Side Effect）**を伴う処理を実行するために使われます。重要なのは、`tap` 演算子自体は、**入力ストリームから受け取った通知をそのまま出力ストリームに影響を与えることなく通過させる**という点です。つまり、ストリームの流れそのものを変えることはありません。

- **動作:**
  `tap` には、`next` 通知用、`error` 通知用、`complete` 通知用のコールバック関数（あるいはそれらをまとめた Observer オブジェクト）を渡すことができます。
  - 入力ストリームから `next(value)` が発行されると、`tap` の `next` ハンドラがその `value` で実行され、その後、同じ `value` が出力ストリームに発行されます。
  - 同様に、`error` や `complete` 通知も、`tap` の対応するハンドラを実行した後、そのまま出力ストリームに伝播します。
- **用途:**
  - **デバッグとロギング:** ストリームの途中でどのような値が流れているか、あるいはエラーや完了が発生したかをコンソールに出力して確認するのに非常に便利です。「この演算子の前後で値はどう変わったかな？」といったことを調べるのに役立ちます。
  - **副作用の実行:** 原則として FRP の演算子は純粋であるべきですが、どうしてもストリームの途中で副作用（例: グローバルな状態の更新、外部 API への（結果を期待しない）通知など）を実行したい場合に、その副作用を `tap` の中にカプセル化することがあります。ただし、多用は禁物で、副作用はできるだけストリームの「最後」（`subscribe` の中）で扱うのが基本です。
  - 分析データの送信など。

```javascript
// 例: RxJS (JavaScript)
// import { interval } from 'rxjs';
// import { tap, map, take, finalize } from 'rxjs/operators';

interval(1000)
  .pipe(
    take(3), // 0, 1, 2 を発行して完了
    tap((value) => console.log(`  [tap] 元の値: ${value}`)), // next通知をログ
    map((value) => value * 10),
    tap({
      // Observerオブジェクト形式
      next: (value) => console.log(`    [tap] map後の値: ${value}`),
      error: (err) => console.error("    [tap] エラー発生:", err), // この例では呼ばれない
      complete: () => console.log("    [tap] ストリーム完了 (map後)"),
    }),
    finalize(() =>
      console.log(
        "      [finalize] ストリームが最終的に終了しました (tapの完了/エラー後)"
      )
    )
    // finalize は tap の complete/error と似ているが、購読解除時にも呼ばれる
  )
  .subscribe({
    next: (value) => console.log(`        [subscribe] 受信値: ${value}`),
    complete: () => console.log("        [subscribe] 購読完了"),
  });

/*
出力イメージ (1秒ごと):
  [tap] 元の値: 0
    [tap] map後の値: 0
        [subscribe] 受信値: 0
  [tap] 元の値: 1
    [tap] map後の値: 10
        [subscribe] 受信値: 10
  [tap] 元の値: 2
    [tap] map後の値: 20
        [subscribe] 受信値: 20
    [tap] ストリーム完了 (map後)
        [subscribe] 購読完了
      [finalize] ストリームが最終的に終了しました (tapの完了/エラー後)
*/
```

`tap` は、ストリームの「のぞき窓」のようなものであり、流れを邪魔せずに中身を観察したり、ちょっとしたおまけの処理を挟んだりするのに便利です。

### `finalize` (または `tap({ complete, error })`)：ストリーム完了時またはエラー時に処理を実行する

`finalize` 演算子（あるいは `tap` に `complete` と `error` の両方のハンドラを指定する方法）は、ストリームが**正常に完了したか、あるいはエラーで終了したかに関わらず、そのストリームのライフサイクルが終了する際に必ず実行したい処理**を定義するために使います。これは、命令型プログラミングにおける `try...catch...finally` ブロックの `finally` 節に似ています。

- **動作:** 入力ストリームが `complete` 通知または `error` 通知を発行した直後（そしてそれらの通知が出力ストリームに伝播する前、あるいは後、ライブラリの実装による）に、指定されたコールバック関数を実行します。このコールバックは、通常、引数を取りません。
- **用途:**
  - **リソースの解放:** ストリームが利用していたリソース（例: WebSocket 接続、ファイルハンドル、タイマーなど）を、ストリーム終了時に確実に解放する。
  - ローディングインジケータの非表示など、UI の後片付け処理。
  - 処理の開始と終了をペアで管理したい場合。

```javascript
// 例: RxJS (前出の tap の例に finalize も含まれています)
// loadingIndicator.show(); // 処理開始前にインジケータ表示
// myStream$.pipe(
//   finalize(() => loadingIndicator.hide()) // ストリーム終了時に必ずインジケータ非表示
// ).subscribe(...);
```

`finalize` は、ストリームのクリーンアップ処理を保証する上で重要な役割を果たします。

### `count`：発行された値の総数を数える

- **動作:** 入力ストリームが完了した時点で、それまでに発行された**値の総数**を一つだけ発行し、その後出力ストリームも完了します。
- **用途:** ストリームがいくつのイベントを生成したかを知りたい場合。

```javascript
// of(10, 20, 30).pipe(count()) は、3 を発行して完了する
```

### `toArray`：ストリームのすべての値を配列にして発行する

- **動作:** 入力ストリームが完了するまで、発行されたすべての値を内部的に収集し、入力ストリームが完了した時点で、**収集したすべての値を格納した単一の配列**を発行し、その後出力ストリームも完了します。
- **用途:** 非同期的に到着する複数の値を、すべて揃ってから一度に処理したい場合。ただし、ストリームが発行する値の数が非常に多い場合や、無限ストリームに対して使うと、メモリを大量に消費する可能性があるので注意が必要です。

```javascript
// interval(100).pipe(take(5), toArray())
// は、[0, 1, 2, 3, 4] という配列を一つ発行して完了する (約0.5秒後)
```

これらのユーティリティ演算子は、ストリーム処理のロジックをより明確にしたり、開発やデバッグを助けたり、あるいは特定の集計や変換を簡潔に行ったりするための、痒い所に手が届く便利な道具です。主要な変換・フィルタリング・合成演算子と合わせて覚えておくと、FRP の表現力がさらに広がるでしょう。

# 第 3 部：FRP の実践的な活用と設計パターン

これまでの部で、イベントストリーム（Observable）の基本的な概念と、それを操作するための多様な演算子について学んできました。この第 3 部では、これらの知識を基に、関数型リアクティブプログラミング (FRP) が実際のアプリケーション開発において、どのように具体的な課題を解決し、どのような設計パターンとして活用されるのか、その実践的な側面を見ていきましょう。

## UI プログラミングにおける FRP：イベント駆動 UI の構築

現代のユーザーインターフェース (UI) は、ユーザーのクリック、マウス操作、キー入力、タッチ操作といった多種多様な「イベント」に動的に応答 (React) することが求められます。FRP は、このような**イベント駆動型の UI プログラミング**を、非常に宣言的かつエレガントに扱うための強力なパラダイムとなります。

### 状態管理とデータバインディング

UI アプリケーションにおける複雑さの源泉の一つが、「状態 (State)」の管理です。ユーザーの操作や外部からのデータ受信によってアプリケーションの状態は変化し、その状態変更を UI の表示に正しく反映させる（データバインディング）必要があります。

FRP のアプローチでは、

- **アプリケーションの状態をストリームとして表現する:**
  たとえば、カウンターアプリの現在のカウント値、フォームの各入力フィールドの値、TODO リストのアイテム一覧などを、それぞれ独立したイベントストリーム（あるいは状態を保持し変化を通知する BehaviorSubject や State ストリームのような特殊なストリーム）としてモデル化します。
- **イベントストリームを変換・合成して新しい状態ストリームを導出する:**
  ユーザーの操作（例: 「+1 ボタンのクリックストリーム」）や外部イベントを元に、`map`, `scan`, `combineLatest` といった演算子を使って、アプリケーションの状態ストリームを更新・派生させていきます。ここでの処理は、多くの場合、純粋関数的なデータ変換として記述されます。

  ```javascript
  // 例: RxJS 風のカウンタ状態管理
  // const incrementClick$ = fromEvent(incrementButton, 'click');
  // const decrementClick$ = fromEvent(decrementButton, 'click');

  // const count$ = merge(
  //   incrementClick$.pipe(mapTo(1)),  // インクリメントは +1
  //   decrementClick$.pipe(mapTo(-1)) // デクリメントは -1
  // ).pipe(
  //   startWith(0), // 初期値 0
  //   scan((currentCount, change) => currentCount + change, 0) // 変化量を累積
  // );

  // count$.subscribe(count => {
  //   displayElement.textContent = count; // UI を更新 (データバインディング)
  // });
  ```

- **UI は状態ストリームを購読して表示を更新する:**
  UI の表示部分は、この状態ストリームを購読し、新しい状態が発行されるたびに、画面の対応する部分を更新します。これにより、状態と UI の間の同期がリアクティブに（自動的に）行われます。

このアプローチは、Redux や NgRx (Angular), Vuex (Vue.js) といった状態管理ライブラリの根底にある考え方（状態は一方向のデータフローで更新され、UI はその状態を反映する）とも非常に親和性が高いです。FRP を使うことで、これらの状態管理のロジックを、より宣言的で合成可能なストリーム処理として記述できる場合があります。

### 複雑なユーザーインタラクションの宣言的な記述

ドラッグ＆ドロップ、オートコンプリート付き検索ボックス、連続クリックの検知といった、少し複雑なユーザーインタラクションも、FRP のストリームと演算子を使うことで、驚くほど簡潔かつ宣言的に記述できます。

- **ドラッグ＆ドロップ:**
  `mousedown` イベントのストリームを開始点とし、そこから `mousemove` イベントのストリームを `takeUntil(mouseup$)` で購読し、マウスの移動量を計算する、といった形で表現できます。
- **オートコンプリート検索:**
  入力フィールドの `input` イベントストリームに対して、`debounceTime` で入力が落ち着くのを待ち、`distinctUntilChanged` で値が変わった場合のみ、`switchMap` で検索 API を呼び出すストリームに切り替える、といったパイプラインを構築できます。
- **ダブルクリック/トリプルクリック:**
  クリックイベントのストリームに対して、`buffer` や `throttleTime` などを組み合わせて、短時間内の連続クリックを検知するロジックを演算子の組み合わせで表現できます。

これらの複雑な非同期インタラクションを、個別のフラグ変数や状態管理ロジックをあちこちに書く代わりに、イベントストリームの「宣言的なパイプライン」として記述することで、コードの見通しが格段に良くなり、バグも混入しにくくなります。

UI プログラミングは、本質的に非同期なイベントの連続に応答していくものであり、FRP はそのための非常に自然で強力なツールセットを提供してくれるのです。

## 非同期データフローの管理：API 呼び出しとキャッシュ戦略

現代のアプリケーション、とくに Web フロントエンドやモバイルアプリでは、サーバーサイドの API との非同期通信が頻繁に行われます。FRP は、これらの API 呼び出しのシーケンスや、その結果のキャッシュといった、非同期データフローの管理にも有効です。

**API 呼び出しの連鎖とエラーハンドリング**

Promise/Future のセクションで見たように、複数の API 呼び出しを順番に行い、前の結果を次に渡す、といった処理は、`mergeMap` (または `flatMap`), `concatMap`, `switchMap` といった高階マッピング演算子を使ってエレガントに記述できます。

```javascript
// 例: RxJS 風
// function fetchUser(id) { return from(ajax.getJSON(`/api/users/${id}`)); }
// function fetchPostsForUser(userId) { return from(ajax.getJSON(`/api/users/${userId}/posts`)); }

// userId$ がユーザーIDを発行するストリームだとして...
// userId$.pipe(
//   switchMap(id => // 新しいユーザーIDが来たら、前のリクエストはキャンセル
//     fetchUser(id).pipe(
//       mergeMap(user => fetchPostsForUser(user.id)), // ユーザー情報から投稿を取得
//       catchError(error => {
//         console.error("APIエラー:", error);
//         return of([]); // エラー時は空の投稿リストを返す
//       })
//     )
//   )
// ).subscribe(posts => { /* 投稿リストでUIを更新 */ });
```

エラーハンドリングも、`catchError` 演算子を使ってパイプラインの途中で適切に処理できます。

**キャッシュ戦略の実装**

一度取得した API のレスポンスをキャッシュしておき、次回同じリクエストがあった場合にはキャッシュから返す、といったキャッシュ戦略も、FRP の演算子を組み合わせることで比較的簡単に実装できます。

- **`shareReplay(bufferSize, windowTime?, scheduler?)`:**
  この演算子は、コールドストリームをホットストリーム（に近い振る舞い）に変換し、**過去に発行された最後の `bufferSize` 個の値をリプレイ（再発行）する**機能を持っています。
  API 呼び出しを行うストリームに `shareReplay(1)` を適用すると、最初の購読時に API が呼び出され、その結果がキャッシュされます。それ以降の購読者には、API を再実行することなく、キャッシュされた最新の結果が即座にリプレイされます。

  ```javascript
  // const userSettings$ = from(ajax.getJSON("/api/settings")).pipe(
  //   shareReplay(1) // 結果を1つだけキャッシュし、リプレイする
  // );

  // 最初の購読: APIが呼ばれる
  // userSettings$.subscribe(settings => console.log("購読者A:", settings));

  // 少し後の2回目の購読: APIは呼ばれず、キャッシュされた値が即座に返る
  // setTimeout(() => {
  //   userSettings$.subscribe(settings => console.log("購読者B:", settings));
  // }, 1000);
  ```

  キャッシュの有効期限 (`windowTime`) を設定することも可能です。

**リクエストの重複排除**

複数のコンポーネントがほぼ同時に同じ API リクエストを開始しようとする場合、`shareReplay` などを使って、実際にネットワークを叩くリクエストを一つにまとめる（重複を排除する）こともできます。

FRP を使うことで、複雑になりがちな非同期データフローの管理や、キャッシュのような横断的な関心事を、宣言的なストリーム処理のパイプラインとして、より見通し良く、かつモジュール的に実装できる可能性があります。

## バックプレッシャー：データの洪水を制御する（再訪と具体的な戦略）

「イベントストリームの基本」の部で、生産者と消費者の処理速度の違いによって発生する「データの洪水」問題と、それを制御するための「**バックプレッシャー (Backpressure)**」の重要性について触れました。関数型リアクティブプログラミングを実践する上で、とくに大量のデータや高頻度のイベントを扱う際には、このバックプレッシャーをどのように設計・制御するかがシステムの安定性を左右する鍵となります。

**なぜバックプレッシャーが再訪するほど重要なのか？**

多くの FRP ライブラリは、デフォルトでは「プッシュ型」で動作し、生産者は消費者の準備状況に関わらずデータを送り続けようとします。もし消費者の処理が追いつかなければ、データはバッファに溜まり続け、最終的にはメモリ不足やパフォーマンス低下を引き起こします。

バックプレッシャーは、この問題を解決するために、**消費者側から生産者側へ「処理が追いつかない」という情報をフィードバックし、生産者のデータ生成・発行速度を抑制する**メカニズムです。

**具体的なバックプレッシャー戦略と FRP 演算子**

FRP ライブラリやストリーム処理基盤は、バックプレッシャーを実現・制御するための様々な戦略や演算子を提供しています。

1.  **バッファリング戦略の選択:**
    前述の通り、バッファがいっぱいになったときにどう振る舞うか（ドロップ、ブロック、エラー）を選択できます。

    - **`buffer(...)` 系演算子:** これらは値をまとめて配列として発行しますが、内部的にはバッファリングを行っています。バッファサイズや時間間隔を適切に設定することが重要です。
    - 一部のライブラリでは、`onBackpressureBuffer()`, `onBackpressureDrop()`, `onBackpressureLatest()` といった、バックプレッシャー発生時の挙動を明示的に指定する演算子が用意されていることもあります。

2.  **時間ベースのサンプリング・間引き:**
    消費者の処理能力に合わせて、ストリームから流れてくるデータの頻度を意図的に落とす戦略です。

    - **`throttleTime(duration)`:** 一定期間内に最初の（または最後の）イベントだけを通します。
    - **`debounceTime(dueTime)`:** イベントが落ち着くまで待ってから最後のイベントを通します。
    - **`sampleTime(period)` / `auditTime(duration)`:** 一定期間ごとに最新の（または期間内の最後の）値を取得します。
      これらの演算子は、必ずしも消費者からのフィードバックに基づくものではありませんが、生産者側（またはパイプラインの途中）でデータ量を効果的に減らすことができます。

3.  **ウィンドウ処理 (`window(...)` 系):**
    ストリームを有限の「ウィンドウ」（それ自体が Observable）に分割し、各ウィンドウを個別に処理（場合によっては並列処理）することで、全体の処理負荷を分散させることができます。ウィンドウ内の処理が追いつかない場合は、そのウィンドウに対するバックプレッシャー戦略（ドロップなど）を適用することも考えられます。

4.  **プルベースの制御 (Reactive Streams 仕様など):**
    より低レベルな制御として、Reactive Streams 仕様に基づいたライブラリ（Project Reactor, Akka Streams など）では、Subscriber (消費者) が Subscription (購読契約) を通じて Publisher (生産者) に対して「次に `n` 個のデータをください」と**要求 (request)** する形で、データフローを明示的に制御します。これにより、消費者は自身の処理能力を超えるデータを受け取ることを防ぎます。
    FRP ライブラリの多くの高レベルな演算子は、内部的にこのようなプルベースの制御を隠蔽している場合があります。

5.  **処理の並行化とリソース割り当て:**
    もし消費者の処理が CPU バウンドで、かつ並列化可能であれば、複数のコンシューマを用意して処理を並列実行することで、全体の処理スループットを向上させ、結果的にバックプレッシャーを緩和できる場合があります。（例: `mergeMap` の並行度 (`concurrent` パラメータ) を調整する）ただし、リソース（CPU コア、スレッドプール）の適切な管理が必要です。

**バックプレッシャー設計の考慮点:**

- **アプリケーションの要件:** データが失われてもよいのか（ドロップ許容）、処理が遅延してもよいのか（バッファリングやブロック）、エラーとして扱うべきか、といったアプリケーションの要件によって、適切な戦略は異なります。
- **ボトルネックの特定:** システム全体のどこでデータの滞留が発生しやすいのか、パフォーマンス上のボトルネックはどこかを特定することが、効果的なバックプレッシャー戦略を立てる上で重要です。
- **監視とチューニング:** バックプレッシャーの設定は、一度行ったら終わりではありません。システムの負荷状況を監視し、バッファサイズやレート制限などを適宜チューニングしていく必要があります。

バックプレッシャーは、リアクティブシステムにおける「縁の下の力持ち」のような存在です。目立たないかもしれませんが、システムの安定稼働とスケーラビリティを支えるためには、その設計と制御が不可欠なのです。FRP ライブラリのドキュメントを参照し、提供されているバックプレッシャー関連の機能や演算子について理解を深めることをお勧めします。

## マルチキャスト：複数の購読者でストリームを共有する

「コールドストリーム vs ホットストリーム」のセクションで、ストリームの振る舞いについて学びました。

- **コールドストリーム:** 購読されるたびに、値の生成やイベントの発行を最初から新しく開始する。各購読者は独立したデータシーケンスを受け取る。
- **ホットストリーム:** 購読者の有無に関わらず値を生成し続け、複数の購読者が同じタイミングで同じ値を共有する。

多くの FRP ライブラリの基本的な生成演算子（`of`, `from(array)`, `interval` など）は、デフォルトで**コールドストリーム**を生成します。これは、各購読者が必要な時に必要なデータを確実に受け取れるようにするためですが、場合によっては不都合が生じることがあります。

**コールドストリームの課題（複数の購読者がいる場合）:**

- **副作用の重複実行:** もしコールドストリームが、その生成ロジックの中で副作用（例: HTTP リクエスト、データベースクエリ）を実行する場合、複数の購読者がそのストリームを購読すると、副作用が**購読のたびに何度も実行されてしまう**可能性があります。これは、パフォーマンスの悪化や、意図しない結果を引き起こす原因となります。
- **リソースの無駄遣い:** 同じデータを取得するために、同じ API が何度も呼び出されるのは非効率です。

このような課題を解決し、「**一つのストリームソース（データ生成元）からの値を、複数の購読者で効率的に共有する**」ための仕組みが、「**マルチキャスト (Multicasting)**」です。マルチキャストは、コールドストリームをホットストリーム（あるいはそれに近い、共有可能な振る舞いをするストリーム）に変換するテクニックと言えます。

### `multicast`, `publish`, `share`, `shareReplay` 演算子

FRP ライブラリは、このマルチキャストを実現するためのいくつかの演算子を提供しています。代表的なものに、RxJS の `multicast`, `publish`, `share`, `shareReplay` などがあります。これらの演算子は、内部的に「**Subject (サブジェクト)**」という特殊な Observable を使って、値の共有を実現します。（Subject は、自身が Observable でありながら Observer でもある、つまり値を発行することも購読することもできる存在です。）

- **`multicast(subjectOrSubjectFactory)`:**
  もっとも基本的なマルチキャスト演算子。引数として Subject（または Subject を生成するファクトリ関数）を取り、元のコールドストリーム（ソース）をその Subject に接続します。
  `multicast` が返すのは `ConnectableObservable` という特殊な Observable で、これは `connect()` メソッドを呼び出すまではソースストリームへの購読を開始しません。`connect()` が呼ばれると、ソースストリームの値が Subject を通じてすべての購読者にブロードキャスト（マルチキャスト）されます。
  購読者がいなくなっても、`connect()` によって開始されたソースの購読は自動的には解除されません（手動で `Subscription` を解除する必要がある）。

- **`publish()`:**
  `multicast(new Subject())` とほぼ同じ動作をする便利なショートカットです。これも `ConnectableObservable` を返します。

- **`refCount()` (通常 `publish().refCount()` または `multicast().refCount()` と組み合わせて使う):**
  `ConnectableObservable` に適用すると、**最初の購読者が現れた時点で自動的に `connect()` を呼び出し、すべての購読者がいなくなった時点でソースストリームへの購読を自動的に解除する**ように振る舞う、通常の Observable に変換します。これにより、リソース管理が少し楽になります。

- **`share()`:**
  `publish().refCount()`（または `multicast(new Subject()).refCount()`）とほぼ同等の、より一般的なユースケースのための便利なショートカットです。最初の購読者が現れるとソースの購読を開始し、後続の購読者はその値を共有します。すべての購読者がいなくなるとソースの購読も解除されます。
  **用途:** 複数の購読者で、副作用（例: API 呼び出し）を一度だけ実行し、その結果を共有したい場合に非常に便利です。

  ```javascript
  // 例: RxJS (share)
  // const expensiveHttpRequest$ = new Observable(subscriber => {
  //   console.log("HTTPリクエストを実行します！ (副作用)");
  //   setTimeout(() => { // API呼び出しをシミュレート
  //     subscriber.next(Math.random());
  //     subscriber.complete();
  //   }, 1000);
  // });

  // const sharedRequest$ = expensiveHttpRequest$.pipe(share()); // これで共有可能になる

  // console.log("最初の購読 (APIが呼ばれる)");
  // sharedRequest$.subscribe(value => console.log("購読者A:", value));

  // setTimeout(() => {
  //   console.log("2番目の購読 (APIは再実行されず、Aと結果を共有するはず...だがタイミング次第)");
  //   // share() の場合、もし購読者Aが完了していれば、再度ソースが実行される可能性もある
  //   sharedRequest$.subscribe(value => console.log("購読者B:", value));
  // }, 500); // 最初の購読から0.5秒後

  // setTimeout(() => {
  //   console.log("3番目の購読 (タイミングによっては再度ソースが実行されることも)");
  //   sharedRequest$.subscribe(value => console.log("購読者C:", value));
  // }, 2000); // 最初の購読から2秒後 (最初のAPIは完了しているはず)
  ```

  `share()` は便利ですが、ソースの完了と購読解除のタイミングによっては、意図せずソースが再実行されるケースもあるため、注意が必要です。

- **`shareReplay({ bufferSize, windowTime?, refCount?, scheduler? })` / `shareReplay(bufferSize, windowTime?, scheduler?)`:**
  `share()` と似ていますが、さらに強力な機能として、**ソースストリームが発行した最後の `bufferSize` 個の値をキャッシュし、新しい購読者に対してそれらの値を「リプレイ（再発行）」する**能力を持っています。
  `refCount: true` (または古い API では `refCount` 引数なしの `shareReplay(N)`) を指定すると、`share` と同様に参照カウントの振る舞いをします。
  `windowTime` を指定すると、キャッシュの有効期限を設定できます。
  **用途:**

  - API から取得したデータをキャッシュし、複数のコンポーネントで共有・再利用したい。
  - 新しい購読者にも、直近のいくつかの値をすぐに提供したい。
  - 副作用のあるストリームを一度だけ実行し、その結果を確実に複数の購読者で共有し、かつリプレイもさせたい場合に非常に強力です。

  ```javascript
  // 例: RxJS (shareReplay)
  // const configData$ = new Observable(subscriber => {
  //   console.log("設定データをAPIから取得します！(一度だけ呼ばれることを期待)");
  //   setTimeout(() => {
  //     subscriber.next({ theme: "dark", language: "ja" });
  //     subscriber.complete();
  //   }, 1000);
  // }).pipe(
  //   shareReplay({ bufferSize: 1, refCount: true }) // 最後の1つの値をキャッシュし、参照カウント
  // );

  // console.log("購読者1: 設定データを要求");
  // configData$.subscribe(config => console.log("  購読者1 受信:", config));

  // setTimeout(() => {
  //   console.log("購読者2: 設定データを要求 (キャッシュから取得されるはず)");
  //   configData$.subscribe(config => console.log("    購読者2 受信:", config));
  // }, 500);

  // setTimeout(() => {
  //   console.log("購読者3: 設定データを要求 (これもキャッシュから)");
  //   configData$.subscribe(config => console.log("      購読者3 受信:", config));
  // }, 2000);
  /*
  出力イメージ:
  購読者1: 設定データを要求
  設定データをAPIから取得します！(一度だけ呼ばれることを期待)
    購読者1 受信: { theme: 'dark', language: 'ja' } (約1秒後)
  購読者2: 設定データを要求 (キャッシュから取得されるはず)
      購読者2 受信: { theme: 'dark', language: 'ja' } (即座に)
  購読者3: 設定データを要求 (これもキャッシュから)
        購読者3 受信: { theme: 'dark', language: 'ja' } (即座に)
  */
  ```

マルチキャスト系の演算子は、コールドストリームが持つ「購読ごとの再実行」という性質を理解した上で、いつ値を共有し、いつ副作用を一度だけに限定したいのか、という設計意図を明確に表現するために不可欠な道具です。とくに `shareReplay` は、API レスポンスのキャッシュなど、多くの実用的なシナリオで活躍します。

## カスタム演算子の作成：再利用可能な処理の抽象化

FRP ライブラリは非常に多くの組み込み演算子を提供していますが、アプリケーションを開発していく中で、「この一連の演算子の組み合わせ、色々な場所で何度も使っているな…」という状況が出てくることがあります。同じようなストリーム処理のパイプラインを複数の場所にコピー＆ペーストするのは、DRY (Don't Repeat Yourself) 原則に反し、保守性を低下させる原因となります。

このような場合に役立つのが、「**カスタム演算子 (Custom Operator)**」を作成するというアプローチです。カスタム演算子とは、**既存の組み込み演算子をいくつか組み合わせた、特定の目的を持つ新しい演算子を、自分自身で定義する**ことです。

**なぜカスタム演算子が必要か？**

- **再利用性の向上:** 頻繁に使われる一連のストリーム処理ロジックを、一つの名前付き演算子としてカプセル化することで、コードの重複を避け、様々な場所で簡単に再利用できるようになります。
- **可読性の向上:** 複雑な演算子の組み合わせに意味のある名前を付けることで、ストリーム処理のパイプライン全体の意図がより明確になり、コードの可読性が向上します。「このカスタム演算子は、〇〇という処理を行うものだ」と一目で理解できます。
- **抽象化レベルの向上:** アプリケーション固有のドメインロジックや、特定の処理パターンを、より高レベルな抽象操作として表現できます。
- **テスト容易性:** カスタム演算子自体を独立してテストすることで、そのロジックの正しさを保証しやすくなります。

**カスタム演算子の作成方法（一般的なアプローチ）**

カスタム演算子を作成する方法は、使用する FRP ライブラリによって多少異なりますが、基本的な考え方は共通しています。多くの場合、「**入力として Observable を受け取り、何らかの処理（既存の演算子の組み合わせなど）を施した結果として、新しい Observable を返す関数**」として定義されます。

**RxJS におけるカスタム演算子の作成例 (pipeable operator)**

RxJS では、`pipe()` メソッドに渡すことができる「パイパブル演算子 (pipeable operator)」としてカスタム演算子を作成するのが一般的です。これは、単に `Observable<In> => Observable<Out>` というシグネチャを持つ関数を定義するだけです。

```javascript
// 例: RxJS (JavaScript)
// import { filter, map, scan } from 'rxjs/operators';
// import { Observable } from 'rxjs';

// カスタム演算子: 0以上の偶数だけを取り出し、それぞれを2乗し、その累計を出す
function processPositiveEvenSquaresSum(): (
  source: Observable<number>
) => Observable<number> {
  return (
    source: Observable<number> // ソースObservableを受け取る関数を返す
  ) =>
    source.pipe(
      // ソースに対して既存の演算子をパイプする
      filter((n) => n >= 0 && n % 2 === 0), // 0以上の偶数のみ
      map((n) => n * n), // 2乗する
      scan((acc, squared) => acc + squared, 0) // 累計を計算
    );
}

// --- カスタム演算子の利用 ---
// import { interval } from 'rxjs';
// import { take }
//
// interval(500).pipe(
//   take(10), // 0, 1, 2, ..., 9
//   processPositiveEvenSquaresSum() // ★ 作成したカスタム演算子を適用
// ).subscribe(sum => console.log(`0以上の偶数の2乗の累計: ${sum}`));

/*
出力イメージ:
0以上の偶数の2乗の累計: 0   (入力0: 0*0=0, sum=0)
0以上の偶数の2乗の累計: 4   (入力2: 2*2=4, sum=0+4=4)
0以上の偶数の2乗の累計: 20  (入力4: 4*4=16, sum=4+16=20)
0以上の偶数の2乗の累計: 56  (入力6: 6*6=36, sum=20+36=56)
0以上の偶数の2乗の累計: 120 (入力8: 8*8=64, sum=56+64=120)
*/
```

この `processPositiveEvenSquaresSum` 関数は、それ自体が新しいパイパブル演算子です。内部では、`filter`, `map`, `scan` という組み込み演算子を組み合わせて、特定のデータ処理フローを実現しています。このカスタム演算子を使う側は、その内部実装の詳細を意識することなく、「0 以上の偶数を 2 乗して累計する」という高レベルな操作として利用できます。

**カスタム演算子を設計する際の考慮点:**

- **単一責任の原則:** カスタム演算子もまた、一つの明確な目的や責務を持つように設計します。あまりに多くの異なる処理を一つのカスタム演算子に詰め込みすぎないように注意しましょう。
- **汎用性と再利用性:** どのような入力ストリームに対して適用できるか、どの程度汎用的に使えるかを考慮します。特定の状況でしか使えない演算子よりも、より多くの場面で再利用できる演算子の方が価値が高い場合があります（ただし、過度な汎用化は複雑さを招くこともあります）。
- **命名の重要性:** カスタム演算子の名前は、その演算子が何をするのかを明確に、かつ簡潔に表すように慎重に選びます。
- **パラメータ化:** カスタム演算子が、その振る舞いを調整するためのパラメータ（例: `debounceTime` のミリ秒数）を受け取れるように設計することで、より柔軟で再利用しやすくなります。

カスタム演算子を作成する能力は、FRP を使った開発において、コードの品質、再利用性、そして保守性を大きく向上させるための重要なスキルです。よく使われる処理のパターンを見つけ出し、それを独自の「道具」として抽象化していくことで、皆さんの FRP のコードはより洗練され、表現力豊かになるでしょう。

## テスト：リアクティブなコードをどうテストするか

関数型リアクティブプログラミング (FRP) で書かれたコード、とくにイベントストリーム（Observable）を扱うコードは、その非同期性や時間依存性、そして多数の演算子の組み合わせといった特性から、従来の同期的なコードとは異なるテストのアプローチが必要となる場合があります。

しかし、FRP の原則（純粋関数的な演算子、不変データなど）は、実はテスト容易性を高める方向にも作用します。ここでは、リアクティブなコードをテストする際の基本的な考え方とテクニックについて見ていきましょう。

### Marble Diagram を使ったテストの考え方

FRP の世界、とくに RxJS などでは、「**Marble Diagram (マーブルダイアグラム)**」という図を使って、イベントストリームの時間的な振る舞いを視覚的に表現することがよく行われます。

- **時間軸:** 左から右へ流れる線で時間を表します。
- **値の発行 (Next):** 線上の特定の位置に置かれた「マーブル（ビー玉）」で、ストリームが値を発行するタイミングとその値を表現します。
- **完了 (Complete):** 線上の縦棒 `|` で、ストリームが正常に完了したことを示します。
- **エラー (Error):** 線上のバツ印 `X` で、ストリームがエラーで終了したことを示します。

**例：`map(x => x * 10)` 演算子のマーブルダイアグラム**

```
入力ストリーム: --1--2--3--|
                   map(x => x * 10)
出力ストリーム: --10-20-30-|
```

このマーブルダイアグラムは、入力ストリームが `1, 2, 3` と値を順に発行し完了すると、`map(x => x * 10)` 演算子を適用した結果、出力ストリームは `10, 20, 30` と値を順に発行して完了することを示しています。

**テストにおけるマーブルダイアグラムの役割:**

このマーブルダイアグラムの考え方は、**リアクティブなコードのテストケースを定義し、その期待結果を記述する**上で非常に役立ちます。多くの FRP テストライブラリでは、このマーブルダイアグラムに似た記法（ASCII 文字列など）を使って、

1.  **入力ストリーム（群）の振る舞い（どのタイミングでどの値を出すか、いつ完了/エラーになるか）**
2.  **期待される出力ストリームの振る舞い**

を定義し、実際に演算子やストリーム処理パイプラインを適用した結果が、期待通りになるかを検証します。

### テストスケジューラと時間制御

イベントストリームのテスト、とくに `debounceTime`, `throttleTime`, `delay`, `interval`, `timer` といった時間制御系の演算子を含むストリームのテストでは、「時間」の概念をどのように扱うかが重要になります。実際の時間経過を待ってテストを実行すると、テストスイート全体の実行時間が非常に長くなってしまいます。

この問題を解決するために、多くの FRP テストライブラリは「**テストスケジューラ (TestScheduler)**」という仕組みを提供しています。

- **仮想時間:** テストスケジューラは、「仮想的な時間」を導入し、実際のクロック時間とは独立して、テストコード内で時間の経過をシミュレート（制御）することを可能にします。
- **同期的なテスト実行:** `delay(1000)` のような非同期処理も、テストスケジューラを使うと、あたかも同期的に（仮想時間が 1000ms 進んだかのように）実行し、その結果を即座に検証できます。
- **マーブルテストとの連携:** テストスケジューラは、マーブルダイアグラム風の記法で定義された入力ストリームと期待出力ストリームのタイミングを解釈し、仮想時間上でテストを実行・検証するのに使われます。

```javascript
// 例: RxJS のテスト (TestScheduler とマーブル構文を使ったイメージ)
// (実際のコードはもう少し複雑になりますが、ここでは概念を示します)

// it('map 演算子は各値を変換すべき', () => {
//   const scheduler = new TestScheduler((actual, expected) => {
//     // ここで actual と expected (マーブルダイアグラムで表現されたイベントシーケンス) を比較
//     expect(actual).toEqual(expected);
//   });
//
//   scheduler.run(helpers => {
//     const { cold, expectObservable } = helpers;
//
//     const source$ = cold('-a-b-c-|', { a: 1, b: 2, c: 3 });
//     // source$ は、仮想時間 10フレーム目に1, 30フレーム目に2, 50フレーム目に3を発行し、70フレーム目に完了
//
//     const expectedMarbles = '-x-y-z-|';
//     const expectedValues = { x: 10, y: 20, z: 30 };
//
//     const result$ = source$.pipe(map(x => x * 10));
//
//     expectObservable(result$).toBe(expectedMarbles, expectedValues);
//   });
// });
```

この例では、`cold` ヘルパーで入力ストリームのタイミングと値をマーブル構文で定義し、`expectObservable` で期待される出力ストリームの振る舞いを同じくマーブル構文で記述しています。テストスケジューラが、これらの定義に基づいて仮想時間上でテストを実行し、結果を比較します。

**リアクティブコードのテスト容易性を高めるポイント:**

- **演算子の純粋性を信頼する:** ライブラリが提供する組み込み演算子自体は十分にテストされていると信頼し、自分のテストでは、演算子を組み合わせた「パイプライン全体」が期待通りに振る舞うか、あるいは自身が作成した「カスタム演算子」や「変換関数」のロジックが正しいかに焦点を当てます。
- **入力と出力を明確にする:** テスト対象のストリーム処理に対して、どのような入力ストリームを与えれば、どのような出力ストリーム（値、タイミング、完了/エラー）が期待されるのかを明確に定義します。マーブルダイアグラムはそのための良いツールです。
- **依存性を分離する:** ストリーム処理の途中で外部の非同期 API を呼び出すなど、テストを不安定にする可能性のある依存関係は、テストダブル（モックされたストリームや Promise など）を使って分離します。
- **テストスケジューラを活用する:** 時間が絡むテストは、テストスケジューラを使って仮想時間で制御し、高速かつ安定したテストを目指します。

関数型リアクティブプログラミングは、その宣言的で合成可能な性質から、一見複雑に見える非同期処理やイベント処理のロジックを、実は非常にテストしやすい形で記述することを可能にします。マーブルダイアグラムやテストスケジューラといったテスト支援の仕組みを理解し活用することで、リアクティブなコードの品質と信頼性を効果的に高めることができるでしょう。

# 第 4 部：FRP のエコシステムとさらに学ぶために

関数型リアクティブプログラミング (FRP) の基本的な概念、イベントストリームの扱い方、そして多様な演算子について学んできました。FRP は非常に強力なパラダイムであり、その考え方をサポートするための様々なライブラリやフレームワーク、そしてコミュニティが存在します。この部では、FRP のエコシステムと、皆さんがさらに学びを深めていくための道筋について触れたいと思います。

## 代表的な FRP ライブラリの比較と特徴（RxJS, Reactor, Akka Streams など再訪）

「はじめに」や各演算子の説明で、いくつかの代表的な FRP ライブラリに触れてきました。ここでは、それらの特徴を改めて簡単に比較し、どのような状況でどのライブラリが選択されることが多いのか、その概要を掴んでおきましょう。

1.  **RxJS (Reactive Extensions for JavaScript):**

    - **エコシステム:** JavaScript / TypeScript の世界でもっとも広く使われている FRP ライブラリ。Angular フレームワークでは標準的に利用され、React や Vue.js といった他のフロントエンドフレームワークでも活用可能。Node.js によるサーバーサイド開発でも使えます。
    - **特徴:**
      - `Observable` を中心とした非常に豊富な演算子群（おそらくもっとも多機能）。
      - 詳細なドキュメントと活発なコミュニティ。
      - UI イベント処理、非同期データ管理、複雑なユーザーインタラクションの実装に強い。
      - コールド/ホット Observable、Subject、スケジューラなど、高度な概念もサポート。
    - **学習曲線:** 機能が豊富な分、すべての演算子を使いこなすには学習コストがかかるが、基本的な部分から段階的に学べる。

2.  **Project Reactor (Reactor Core):**

    - **エコシステム:** 主に JVM (Java, Kotlin) の世界、とくに Spring Framework 5 以降のリアクティブスタック (Spring WebFlux など) の中核をなすライブラリ。
    - **特徴:**
      - Reactive Streams 仕様に準拠。`Flux` (0..N 要素) と `Mono` (0..1 要素) という二つの主要なリアクティブ型を提供。
      - ノンブロッキング I/O を前提とした、高性能なリアクティブバックエンドシステムの構築に適している。
      - バックプレッシャー制御が組み込まれており、スケーラブルなデータ処理が可能。
      - Spring エコシステムとの統合が非常にスムーズ。
    - **学習曲線:** Spring 開発者にとっては比較的導入しやすい。Reactive Streams の仕様やノンブロッキング I/O の概念の理解が助けになる。

3.  **Akka Streams:**

    - **エコシステム:** 主に JVM (Scala, Java)、Akka ツールキットの一部。
    - **特徴:**
      - これも Reactive Streams 仕様に準拠。非常に強力なバックプレッシャー制御と、柔軟なストリーム処理グラフの構築が可能。
      - Akka Actors との連携が容易で、分散環境でのストリーム処理や、アクターベースのリアクティブシステム構築に強み。
      - 型安全性が高く、Scala の表現力を活かした API。
      - 大量のデータを扱うストリーミング ETL、リアルタイム分析、高性能なネットワークアプリケーションなどに適している。
    - **学習曲線:** Akka やアクターモデルの基本的な理解があるとスムーズ。Scala の関数型プログラミングの知識も活かせる。

4.  **Kotlin Coroutines Flow:**

    - **エコシステム:** Kotlin (JVM, Android, Native, JavaScript)。Kotlin 言語自体に組み込まれたコルーチン機能がベース。
    - **特徴:**
      - `Flow` というコールドストリームの抽象を提供。中断関数 (suspending functions) を使うことで、非同期コードを非常にシンプルかつ直感的に書ける。
      - 構造化された並行性 (Structured Concurrency) により、コルーチンのライフサイクル管理が容易で、キャンセル処理も扱いやすい。
      - バックプレッシャーにも対応。
      - Android 開発において、Google が推奨する非同期処理ソリューションの一つ。
    - **学習曲線:** Kotlin のコルーチンを理解していれば、比較的スムーズに導入できる。RxJava や Reactor に比べると、演算子の種類はまだ少ないが、基本的なものは揃っている。

5.  **System.Reactive (Rx.NET):**
    - **エコシステム:** .NET (C#, F#)。Reactive Extensions の元祖とも言える実装の一つ。
    - **特徴:**
      - `IObservable<T>` と `IObserver<T>` を中心とした API。
      - LINQ (Language Integrated Query) との親和性が非常に高く、クエリ構文を使って宣言的にストリームを操作できる。
      - C# の `async/await` とも連携可能。
      - Windows アプリケーション (WPF, UWP)、Xamarin (モバイル)、ASP.NET バックエンドなど、.NET 環境全般で利用可能。
    - **学習曲線:** .NET 開発者、とくに LINQ に慣れている場合は導入しやすい。

これらのライブラリは、それぞれ異なる強みと適用領域を持っています。プロジェクトの技術スタック、解決したい課題の性質、チームのスキルセットなどを考慮して、適切なものを選択することが重要です。

しかし、どのライブラリを使うにしても、その根底にある**イベントストリーム、演算子による変換・合成、購読、エラーハンドリング、バックプレッシャーといった FRP の基本的な考え方は共通**しています。一つのライブラリでこれらの概念をしっかり理解すれば、他のライブラリへの知識の応用も比較的容易になるでしょう。

## FRP と他のパラダイム（Actor モデル、CSP など）との関係

関数型リアクティブプログラミング (FRP) は、非同期処理や並行処理を扱うための唯一の方法ではありません。「関数型プログラミング：安全な並行・非同期処理の実践」の資料でも触れたように、**Actor モデル**や、**CSP (Communicating Sequential Processes)** といった他の強力な並行処理パラダイムも存在します。

これらのパラダイムは、互いに競合するというよりは、解決しようとしている問題の側面や、提供する抽象化のレベルが異なる場合があり、時には**組み合わせて使われる**こともあります。

- **FRP と Actor モデル:**
  - **Actor モデル**は、状態を持つ独立した「アクター」間の非同期メッセージパッシングによって並行処理を実現します。各アクターは自身の状態をカプセル化し、ロックフリーな並行性を目指します。
  - **FRP** は、時間とともに変化する値の「流れ」を扱い、その流れを変換・合成することに焦点を当てます。
  - **組み合わせの可能性:** たとえば、Akka (Actor モデル) と Akka Streams (FRP) を組み合わせることで、アクターがイベントストリームを生成したり、消費したり、あるいはストリーム処理の各ステージをアクターとして実装したり、といった高度なリアクティブシステムを構築できます。アクターが状態を持ち、ストリームがその状態変化をトリガーしたり、逆にストリームの処理結果をアクターにメッセージとして送ったりするのです。
- **FRP と CSP (Go 言語の Goroutines と Channels など):**
  - **CSP** は、独立して実行されるプロセス（Go の Goroutine など）が、「チャネル」という通信路を通じて明示的にメッセージを同期的に（あるいはバッファ付きで非同期的に）送受信することで協調動作するモデルです。
  - **FRP** のストリームがデータの「流れ」を強調するのに対し、CSP のチャネルはプロセス間の「通信ポイント」を強調する傾向があります。
  - **組み合わせの可能性:** たとえば、チャネルから受信したメッセージをイベントストリームのソースとし、FRP の演算子で処理した後、結果を別のチャネルに送信する、といった連携が考えられます。

重要なのは、これらのパラダイムが提供する**抽象化のレベルと、それが解決しようとしている問題の種類を理解する**ことです。

- **Promise/Future:** 単発の非同期処理の結果。
- **FRP (Observable/Stream):** 非同期的な値の「連続的な流れ」と、その変換・合成。UI イベント、データストリーミングに適している。
- **Actor モデル:** 状態を持つ独立したコンポーネント間の、メッセージベースの疎結合な並行処理。分散システム、耐障害性に強み。
- **CSP:** プロセス間の明示的な同期・非同期通信。

これらのパラダイムは、関数型プログラミングの原則（不変性、副作用の管理など）と組み合わせることで、それぞれの強みをさらに活かすことができます。

## 学習リソースとコミュニティ

関数型リアクティブプログラミングの世界は広大で、常に進化しています。さらに学びを深めたい、あるいは特定のライブラリを使いこなしたい、という方のために、いくつかの学習リソースやコミュニティの方向性を示します。

- **公式ドキュメント:** 各 FRP ライブラリ（RxJS, Project Reactor, Akka Streams, Kotlin Flow, Rx.NET など）の公式サイトには、通常、詳細な API リファレンス、チュートリアル、概念説明が含まれています。これらがもっとも正確で最新の情報源です。
- **書籍:**
  - RxJS に関する書籍（日本語訳もいくつかあります）。
  - Akka に関する書籍（Scala や Java での Actor モデルとストリーム処理）。
  - 特定の言語におけるリアクティブプログラミングや非同期処理に特化した書籍。
  - 関数型プログラミング全般の書籍の中にも、FRP の章が含まれていることがあります。
- **オンラインコース・チュートリアル:**
  - Udemy, Coursera, Pluralsight, egghead.io といったプラットフォームで、FRP や特定のライブラリに関する質の高いコースが見つかることがあります。
  - 各ライブラリのコミュニティが提供するチュートリアルやブログ記事も豊富です。
- **コミュニティ:**
  - Stack Overflow: 特定の疑問点を質問するのに適しています。
  - GitHub: ライブラリの Issue トラッカーや Discussions で開発者と交流したり、コントリビュートしたりできます。
  - Reddit, Discord, Slack などのコミュニティ: 特定のライブラリや技術に関するフォーラムやチャットグループが存在することがあります。
  - カンファレンスやミートアップ: リアクティブプログラミングに関するセッションやワークショップに参加するのも良い刺激になります。

学習の初期段階では、

1. **基本的な概念（Observable, Observer, Subscription, Operator）をしっかり理解する。**
2. **`map`, `filter` といった基本的な演算子から使い始めてみる。**
3. **マーブルダイアグラムに慣れ親しむ。**
4. **小さなサンプルコードをたくさん書いて動かしてみる。**

といったステップを踏むのが効果的です。そして、実際にアプリケーションで使ってみて、そのメリットや課題を体感することが、もっとも深い理解に繋がるでしょう。

# おわりに：イベントの波を乗りこなす、リアクティブな思考へ

この「関数型プログラミング：イベントストリームとリアクティブ処理入門」では、時間とともに変化する非同期的なデータやイベントの流れを、「イベントストリーム（Observable）」という統一された抽象概念で捉え、それらを関数型プログラミングの強力な「演算子」で自在に操る、関数型リアクティブプログラミング (FRP) の基本的な世界を探求してきました。

UI イベントの洪水から必要な情報だけをエレガントに抜き出したり、複数の非同期 API 呼び出しの結果を巧みに組み合わせたり、あるいは複雑なユーザーインタラクションを宣言的なデータの流れとして表現したり…。FRP は、現代のアプリケーションが直面する多くの非同期処理の課題に対して、非常に強力で洗練された解決策を提供してくれます。

最初は、多くの演算子の名前や、コールド/ホットストリームといった概念、そして「すべてがストリームである」という考え方に戸惑うかもしれません。しかし、その根底にあるのは、

- **宣言的なデータフロー:** 「どのように」ではなく「何を」したいかを記述する。
- **合成可能性:** 小さな、再利用可能な部品（演算子）を組み合わせて複雑な処理を構築する。
- **副作用の管理:** 非同期処理やイベント処理における副作用を、より制御しやすく、予測可能な形で扱う。

といった、関数型プログラミングが持つ普遍的な強みです。

この資料が、皆さんがイベントストリームという「非同期の川」を恐れることなく、むしろその流れを楽しみながら、自在に操るための「サーフボード」や「パドル」を手に入れるための一助となれば幸いです。

FRP の学習は、単に新しいライブラリの使い方を覚えることではありません。それは、**時間とともに変化する世界を、どのようにモデル化し、どのようにプログラムとして表現していくか**という、より深いレベルでの「**リアクティブな思考**」を身につけるプロセスです。

ぜひ、ここで学んだ基本的な概念と演算子を、まずは身近なイベント処理や非同期処理の場面で試してみてください。小さな成功体験を積み重ねることで、FRP の持つ力と美しさを実感し、より複雑な課題にも自信を持って挑戦できるようになるはずです。

イベントの波は絶えず押し寄せてきます。関数型リアクティブプログラミングという羅針盤と道具を手に、その波を華麗に乗りこなし、ユーザーにとってより快適で、開発者にとってより保守しやすい、素晴らしいアプリケーションを創造していくことを楽しみにしています。
