---
title: ソフトウェア設計：リファクタリング入門
created: 2025-04-29 06:40:06
updated: 2025-05-08 15:38:40
draft: true
tags:
  - ソフトウェア設計
  - オブジェクト指向
categories:
  - ソフトウェア設計
---

**目次**

- [ソフトウェア設計：リファクタリング入門](#ソフトウェア設計リファクタリング入門)
- [1. はじめに：コードを健康にする習慣、リファクタリング](#1-はじめにコードを健康にする習慣リファクタリング)
  - [1.1 リファクタリングとは何か？](#11-リファクタリングとは何か)
  - [1.2 「機能追加」や「バグ修正」との明確な違い](#12-機能追加やバグ修正との明確な違い)
  - [1.3 なぜリファクタリングが重要なのか？：未来の自分とチームのために](#13-なぜリファクタリングが重要なのか未来の自分とチームのために)
  - [1.4 この資料で学ぶこと：リファクタリングの第一歩を踏み出す](#14-この資料で学ぶことリファクタリングの第一歩を踏み出す)
- [2. リファクタリングの「きっかけ」：コードからのサインを見逃さない](#2-リファクタリングのきっかけコードからのサインを見逃さない)
  - [2.1 「コードの不吉な臭い」とは？：リファクタリングが必要な兆候](#21-コードの不吉な臭いとはリファクタリングが必要な兆候)
  - [2.2 よくある「コードの不吉な臭い」の例](#22-よくあるコードの不吉な臭いの例)
    - [2.2.1 重複したコード (Duplicated Code)](#221-重複したコード-duplicated-code)
    - [2.2.2 長すぎるメソッド (Long Method)](#222-長すぎるメソッド-long-method)
    - [2.2.3 巨大なクラス (Large Class)](#223-巨大なクラス-large-class)
    - [2.2.4 複雑すぎる条件分岐 (Complicated Conditional)](#224-複雑すぎる条件分岐-complicated-conditional)
  - [2.3 「不吉な臭い」を感じたら、改善のチャンス](#23-不吉な臭いを感じたら改善のチャンス)
  - [2.4 いつリファクタリングを行うか？：日々の開発サイクルの中で](#24-いつリファクタリングを行うか日々の開発サイクルの中で)
    - [2.4.1 機能追加・修正の前に：まず動きやすく整える（準備のリファクタリング、『レガシーコードからの脱却』参照）](#241-機能追加修正の前にまず動きやすく整える準備のリファクタリングレガシーコードからの脱却参照)
    - [2.4.2 コードを書いた後に：「ボーイスカウト・ルール」の実践（『Clean Code』より）](#242-コードを書いた後にボーイスカウトルールの実践clean-codeより)
    - [2.4.3 コードレビューの後に：フィードバックを活かす](#243-コードレビューの後にフィードバックを活かす)
    - [2.4.4 コードを理解するために：読みながら整理する](#244-コードを理解するために読みながら整理する)
- [3. 安全第一！リファクタリングを支える技術](#3-安全第一リファクタリングを支える技術)
  - [3.1 もっとも重要な安全網：自動テストの役割](#31-もっとも重要な安全網自動テストの役割)
    - [3.1.1 振る舞いが変わっていないことを保証するテストの力](#311-振る舞いが変わっていないことを保証するテストの力)
    - [3.1.2 テストがないコードのリファクタリングのリスク（『レガシーコードからの脱却』参照）](#312-テストがないコードのリファクタリングのリスクレガシーコードからの脱却参照)
    - [3.1.3 リファクタリングのためのテスト戦略](#313-リファクタリングのためのテスト戦略)
  - [3.2 小さく、着実に進めるステップ](#32-小さく着実に進めるステップ)
  - [3.3 バージョン管理システム (Git) の活用](#33-バージョン管理システム-git-の活用)
- [4. はじめの一歩：基本的なリファクタリング・テクニック集](#4-はじめの一歩基本的なリファクタリングテクニック集)
  - [4.1 名前の改善：意図を明確にする](#41-名前の改善意図を明確にする)
    - [4.1.1 メソッド名の変更 (Rename Method)](#411-メソッド名の変更-rename-method)
    - [4.1.2 変数名の変更 (Rename Variable)](#412-変数名の変更-rename-variable)
  - [4.2 メソッドの整理：責務を明確にする](#42-メソッドの整理責務を明確にする)
    - [4.2.1 メソッドの抽出 (Extract Method)](#421-メソッドの抽出-extract-method)
    - [4.2.2 メソッドのインライン化 (Inline Method)](#422-メソッドのインライン化-inline-method)
  - [4.3 条件分岐の単純化：流れを分かりやすくする](#43-条件分岐の単純化流れを分かりやすくする)
    - [4.3.1 ガード節による入れ子の単純化 (Replace Nested Conditional with Guard Clauses)](#431-ガード節による入れ子の単純化-replace-nested-conditional-with-guard-clauses)
    - [4.3.2 条件記述の分解 (Decompose Conditional)](#432-条件記述の分解-decompose-conditional)
  - [4.4 コードの整理：不要な要素をなくす](#44-コードの整理不要な要素をなくす)
    - [4.4.1 一時変数の削除 (Replace Temp with Query)](#441-一時変数の削除-replace-temp-with-query)
    - [4.4.2 マジックナンバーから定数へ (Replace Magic Number with Symbolic Constant)](#442-マジックナンバーから定数へ-replace-magic-number-with-symbolic-constant)
- [5. リファクタリングの目指す先：より良い設計へ](#5-リファクタリングの目指す先より良い設計へ)
  - [5.1 リファクタリングは設計改善活動である](#51-リファクタリングは設計改善活動である)
  - [5.2 設計原則（SOLID など）はリファクタリングの道しるべ](#52-設計原則solid-などはリファクタリングの道しるべ)
  - [5.3 リファクタリングによってデザインパターンが現れることも](#53-リファクタリングによってデザインパターンが現れることも)
  - [5.4 良い設計を知ることが、効果的なリファクタリングにつながる（『良いコード/悪いコードで学ぶ設計入門』、『Good Code, Bad Code』参照）](#54-良い設計を知ることが効果的なリファクタリングにつながる良いコード悪いコードで学ぶ設計入門good-code-bad-code参照)
- [6. おわりに：リファクタリングを習慣化し、コードと共に成長する](#6-おわりにリファクタリングを習慣化しコードと共に成長する)
  - [6.1 リファクタリングは特別な作業ではない](#61-リファクタリングは特別な作業ではない)
  - [6.2 コードは「書いたら終わり」ではなく、「育てる」もの](#62-コードは書いたら終わりではなく育てるもの)
  - [6.3 学び続ける姿勢と、より良いコードへの探求（『リファクタリング・ウェットウェア』の考え方も参考に）](#63-学び続ける姿勢とより良いコードへの探求リファクタリングウェットウェアの考え方も参考に)

# ソフトウェア設計：リファクタリング入門

# 1. はじめに：コードを健康にする習慣、リファクタリング

ソフトウェア開発の世界へようこそ。皆さんは日々の業務で、要求された機能を実現するためにコードを書き、それが意図した通りに動くことに喜びや達成感を感じていることでしょう。しかし、ソフトウェア開発は「コードが動けば終わり」ではありません。むしろ、ソフトウェアがリリースされてからが、その価値が問われる本当の始まりとも言えます。

ソフトウェアは、多くの場合、長期間にわたって利用され、変化する要求に合わせて機能追加や修正が繰り返されます。時間が経つにつれて、最初はきれいで分かりやすかったコードも、度重なる変更によって複雑になったり、読みにくくなったりしていくことがあります。

## 1.1 リファクタリングとは何か？

そこで重要になるのが「**リファクタリング**」という考え方です。リファクタリングとは、ソフトウェア開発における重要な活動の 1 つで、「**外部から見たときのソフトウェアの振る舞いを変えずに、内部の構造を改善すること**」 を指します。これは、ソフトウェア設計の分野で非常に影響力のある書籍『リファクタリング 第 2 版』で明確に定義されています。

少し難しく聞こえるかもしれませんが、身近なことに例えると分かりやすいかもしれません。

- **部屋の掃除や模様替え:** 部屋にある家具の種類や機能（ベッドで寝る、机で勉強するなど）は変えずに、配置を変えたり、不要なものを捨てたり、散らかったものを片付けたりして、より使いやすく、居心地の良い空間にします。
- **机の引き出しの整理整頓:** 引き出しの中身（文房具など）は同じでも、仕切りを使ったり、種類ごとにまとめたりして、必要なものがすぐに見つかるように整理します。
- **車のエンジンメンテナンス:** 車の基本的な機能（走る、曲がる、止まる）は変えずに、エンジン内部を点検・清掃したり、部品を調整したりして、性能を維持し、故障を防ぎます。

リファクタリングもこれらと同じです。プログラムがユーザーに提供する機能（外部から見た振る舞い）は一切変えずに、コードの書き方、クラスやメソッドの構成、変数名などをより良く「整理整頓」し、「メンテナンス」する作業なのです。目的は、コードを**より理解しやすく**、**より変更しやすく**、そして結果として**より保守しやすい**状態にすることにあります。

## 1.2 「機能追加」や「バグ修正」との明確な違い

ここで大切なのは、リファクタリングと、普段よく行う「機能追加」や「バグ修正」とは、目的が明確に異なるという点です。

- **機能追加:** 新しい振る舞いをソフトウェアに追加することです。外部から見た機能が変わります。
- **バグ修正:** ソフトウェアが意図した通りに動かない箇所（バグ）を直し、期待される正しい振る舞いに変更することです。これも外部から見た振る舞いが変わります（誤った振る舞いから正しい振る舞いへ）。
- **リファクタリング:** 外部から見た振る舞いは変えません。コードの内部構造だけを改善します。

もちろん、機能追加やバグ修正を行う過程で、コードを読みやすくするためにリファクタリングを行うことはよくあります。しかし、「リファクタリング」という活動そのものは、機能を変えずにコードの質を高めることを目的としている、と区別して理解することが重要です。

## 1.3 なぜリファクタリングが重要なのか？：未来の自分とチームのために

「動いているコードを、わざわざ時間をかけて書き直す必要があるの？」と思うかもしれません。しかし、リファクタリングは、長期的に見てソフトウェア開発の効率と品質を大きく向上させる、非常に価値のある投資なのです。

ソフトウェア開発の世界では、「**技術的負債 (Technical Debt)**」という言葉がよく使われます。これは、短期的な開発速度を優先するなどの理由で、設計上の問題やコードの読みにくさを放置した結果、将来の修正や機能追加がどんどん困難になっていく状況を、借金に例えたものです。最初は小さかった負債も、放置すれば利子が膨らむように、ソフトウェアの変更コストを増大させ、最終的には身動きが取れなくなってしまうことさえあります。

リファクタリングは、この「技術的負債」を計画的に返済し、コードを健全な状態に保つための重要な活動です。具体的には、以下のようなメリットがあります。

- **コードの理解度が向上する:** 整理され、意図が明確になったコードは、あとで読み返す自分自身にとっても、チームの他のメンバーにとっても、理解するのにかかる時間を大幅に短縮します。
- **変更が容易になる:** 構造が改善され、依存関係が整理されたコードは、新しい機能を追加したり、仕様変更に対応したりする際の修正箇所を特定しやすく、変更による予期せぬ影響（バグの発生）も抑えやすくなります。
- **バグを発見しやすくなる（そして、生みにくくなる）:** コードを整理する過程で、隠れていたバグが見つかることがあります。また、シンプルで分かりやすいコードは、そもそもバグが入り込む余地を減らします。
- **開発スピードが向上する:** 短期的にはリファクタリングに時間がかかるように見えても、長期的には、理解しやすく変更しやすいコードベースによって、開発全体のスピードは向上します。技術的負債が少ない状態を維持することが、持続可能な開発速度につながります。
- **チーム開発が円滑になる:** 読みやすく、一貫性のあるコードは、チームメンバー間の認識のずれを減らし、コードレビューや共同作業をスムーズにします。

リファクタリングは、単なる自己満足のための「きれいなコード」作りではありません。それは、未来の開発効率を守り、ソフトウェアの品質を維持し、そして私たち開発者自身が気持ちよく、生産的に仕事を進めるための、プロフェッショナルとして不可欠な技術なのです。

## 1.4 この資料で学ぶこと：リファクタリングの第一歩を踏み出す

この資料は、新入社員や若手エンジニアである皆さんが、「リファクタリング」という重要な習慣と考え方を身につけるための第一歩となることを目指しています。

具体的には、以下の内容を扱います。

- リファクタリングを行うべき「サイン」となるコードの特徴（コードの臭い）。
- リファクタリングを安全に進めるための準備と心構え（とくにテストの重要性）。
- すぐに実践できる基本的なリファクタリングのテクニック。
- リファクタリングが目指す、より良い設計との関係性。

リファクタリングの技術は奥深く、すべてのテクニックを一度に習得することはできません。この資料を通じて、まずは「リファクタリングとは何か」「なぜ重要なのか」を理解し、「どうやって安全に進めるか」という基礎を固め、そして「簡単な改善から始めてみよう」と思えるようになることを目標としています。

『Clean Code』で提唱されている「ボーイスカウト・ルール」（キャンプ場は、来たときよりもきれいにして立ち去る）のように、日々の開発の中で少しずつでもコードを良くしていく意識を持つことが大切です。この資料が、皆さんのコードをより良く育てていくための、最初のきっかけとなれば幸いです。

# 2. リファクタリングの「きっかけ」：コードからのサインを見逃さない

前の章で、リファクタリングがコードを健康に保つための重要な活動であることを学びました。では、具体的に「いつ」リファクタリングを始めるべきなのでしょうか？もちろん、日々の開発の中で常にコードを改善する意識を持つことは大切ですが、とくにリファクタリングの必要性を示唆する「サイン」があります。

## 2.1 「コードの不吉な臭い」とは？：リファクタリングが必要な兆候

ソフトウェア開発の世界では、プログラムコードの中に潜む「何か問題がありそうな箇所」「改善の余地がありそうな設計上の兆候」のことを、「**コードの不吉な臭い (Code Smells)**」と呼ぶことがあります。これは、マーティン・ファウラー氏の著書『リファクタリング 第 2 版』で広く紹介された考え方で、リファクタリングを始めるべききっかけを見つけるための重要なヒントとなります。

「不吉な臭い」という言葉から、少しネガティブな印象を受けるかもしれませんが、これは必ずしも「バグがある」とか「間違っている」ということを直接的に意味するわけではありません。むしろ、「この部分は、もっとシンプルにできるかもしれない」「将来、変更が必要になったときに苦労しそうだ」「他の人が読んだときに理解しにくいかもしれない」といった、**潜在的な問題や改善の可能性を示唆するサイン**と捉えるのが適切です。

たとえば、キッチンで少し生ゴミの臭いがし始めたら、「そろそろゴミを出す時期だな」とか「どこか汚れている場所があるのかもしれない」と考えますよね。コードの臭いもそれと同じで、コードから何らかの「臭い」を感じたら、それは「ちょっと立ち止まって、この部分のコードを見直してみませんか？」というプログラムからのメッセージなのです。

**なぜ「コードの不吉な臭い」に気づくことが重要か？**

「不吉な臭い」に気づき、それに対処する（つまりリファクタリングを行う）ことには、以下のような意義があります。

- **問題の早期発見:** 小さな「不吉な臭い」のうちに対処しておけば、将来それが大きな問題（深刻なバグ、修正困難な構造）に発展するのを防ぐことができます。
- **設計改善の指針:** どの部分をどのように改善すればよいか、リファクタリングの具体的な「ターゲット」と「方向性」を見つける手がかりになります。『リファクタリング 第 2 版』では、それぞれの「不吉な臭い」に対して、それを解消するための具体的なリファクタリング手法が関連付けられています。
- **コード品質への意識向上:** 「不吉な臭い」を意識するようになると、自然と「どうすればもっと良いコードになるか？」と考える習慣が身につき、コード全体の品質に対する感度が高まります。

コードの「不吉な臭い」は、経験を積むことで徐々に嗅ぎ分けられるようになっていきます。最初は見つけるのが難しいかもしれませんが、これから紹介するような典型的な「不吉な臭い」のパターンを知っておくことは、その第一歩として非常に役立ちます。

次のセクションでは、若手エンジニアの皆さんがとくに出会いやすい、代表的な「不吉な臭い」の例をいくつか見ていきましょう。

## 2.2 よくある「コードの不吉な臭い」の例

コードの「不吉な臭い」にはさまざまな種類がありますが、ここでは皆さんが日々の開発で比較的遭遇しやすい、代表的なものをいくつか紹介します。これらの「不吉な臭い」は、『リファクタリング 第 2 版』でも重要な改善対象として取り上げられています。

### 2.2.1 重複したコード (Duplicated Code)

- **どんな臭いか？**  
  まったく同じコード、あるいは非常によく似たコードの断片が、プログラムの複数の場所に存在している状態です。「コピー＆ペースト」でコードを増やしたときによく発生します。
- **なぜ問題なのか？**
  - **修正漏れの温床:** もしその重複したコードにバグが見つかったり、仕様変更で修正が必要になったりした場合、すべての重複箇所を見つけ出して、漏れなく正確に修正しなければなりません。一箇所でも修正を忘れると、バグや予期せぬ動作の原因となります。これは「プログラミング基礎」で学んだ DRY (Don't Repeat Yourself) 原則に反する状態です。
  - **コード量の増加:** 単純にコード全体の量が増え、読みにくくなります。
  - **意図の不明確化:** 似ているけれど微妙に違うコードが点在すると、「なぜここは少し違うのだろう？」と読む人を混乱させ、理解を妨げます。
- **どう改善するか？**  
  もっとも基本的な解決策は、重複しているコードブロックを共通のメソッド（または関数）として抽出し、元の各箇所からそのメソッドを呼び出すように変更することです。これにより、ロジックが一箇所に集約され、DRY 原則を満たすことができます。修正が必要な場合も、抽出されたメソッドのみを修正すれば済みます。
  クラス間でコードが重複している場合は、親クラスを抽出して共通の振る舞いを移譲する、あるいは委譲を利用して共通機能を別クラスに持たせ、それを利用するなどのアプローチが考えられます。これらはオブジェクト指向の設計原則に基づいた改善策となります。

### 2.2.2 長すぎるメソッド (Long Method)

- **どんな臭いか？**  
  1 つのメソッド（あるいは関数）の中に、非常に多くの処理が詰め込まれていて、何十行、場合によっては何百行にもなっている状態です。
- **なぜ問題なのか？**
  - **理解が困難:** メソッドが長いと、その処理全体を一度に把握するのが難しく、何をしているのか、どこで何が行われているのかを理解するのに時間がかかります。
  - **責務の混在:** 長いメソッドは、多くの場合、複数の異なる責任（やること）を 1 つのメソッド内で無理やり行おうとしています。これは**単一責任の原則 (SRP)** に反しがちです。
  - **再利用性の低下:** メソッドの一部だけを再利用したいと思っても、メソッド全体が大きすぎると、その部分だけを切り離して使うことができません。
  - **テストが困難:** メソッドが長くて複雑だと、すべての処理経路を網羅するテストを書くのが難しくなります。
- **どう改善するか？**  
  メソッド内の処理を論理的な単位に分割し、それぞれをより小さな、責務が明確なメソッドとして抽出するのが一般的な解決策です。抽出された新しいメソッドには、その処理内容を正確に表す名前を付けます。元のメソッドは、抽出されたメソッド群を適切な順序で呼び出す、より上位の抽象度を持つメソッドとなります。

### 2.2.3 巨大なクラス (Large Class)

- **どんな臭いか？**  
  1 つのクラスが、あまりにも多くのインスタンス変数（フィールド、属性）やメソッドを持ち、肥大化している状態です。
- **なぜ問題なのか？**
  - **責務の過多:** 巨大なクラスは、多くの場合、1 つのクラスにあまりにも多くの責任を持たせすぎているサインです。これは**単一責任の原則 (SRP)** に明確に違反しており、クラスの目的が曖昧になります。
  - **凝集度の低下:** クラス内の要素（変数やメソッド）間の関連性が薄れ、クラスとしてのまとまり（凝集度）が低くなります。関係のないコードが同じクラスに混在することで、理解や修正が困難になります。
  - **変更への影響大:** クラスが多くの責任を持っているため、少しの変更でも影響範囲が広くなりやすく、修正によるバグのリスクが高まります。
  - **テストが困難:** クラスが大きすぎると、テストに必要な設定が複雑になったり、テストすべきケースが多くなったりします。
- **どう改善するか？**  
  クラスが持つ責務を分析し、関連性の高い責務やデータを特定します。そして、関連性の高いフィールドとメソッドをグループ化し、それらを新しいクラスとして抽出します。元のクラスは、抽出された新しいクラスへの参照を持ち、関連する処理をそのクラスに委譲するように変更します。
  場合によっては、共通のインターフェースや振る舞いを親クラスとして抽出したり、特定の種類のインスタンスに共通する部分を子クラスとして抽出したりすることも有効です。

### 2.2.4 複雑すぎる条件分岐 (Complicated Conditional)

- **どんな臭いか？**  
  `if-else if-else` 文や `switch` 文が何重にもネスト（入れ子）していたり、条件式 (`if` のカッコの中) が非常に長くて複雑だったりする状態です。「矢印コード (Arrow Code)」と呼ばれるような、インデントが深くなりすぎているコードもこの一種です。
- **なぜ問題なのか？**
  - **可読性の著しい低下:** 処理の流れを追うのが非常に困難になり、コードを読む人の認知的な負荷が大きくなります。
  - **バグの温床:** 条件分岐が複雑だと、どの条件でどの処理が実行されるのかを正確に把握するのが難しく、ロジックの誤りや考慮漏れによるバグが潜みやすくなります。
  - **テストが困難:** すべての条件の組み合わせ（分岐経路）をテストするのが非常に大変になります。
  - **変更への抵抗:** 条件分岐の一部を変更しようとすると、他の部分への影響を慎重に確認する必要があり、修正が困難でリスクも高くなります。
- **どう改善するか？**  
  複雑な条件分岐を単純化するには、状況に応じていくつかの手法があります。
  - **ガード節の導入:** ネストが深い場合、メソッドの冒頭で異常系や特殊ケースを判定し、早期リターンさせます。これにより、主となる正常系の処理のネストを解消し、コードの見通しを良くします。
  - **条件式のメソッド抽出:** `if`文の条件式自体が複雑で読みにくい場合、その条件判定ロジックを、意味のある名前を持つ`boolean`型を返すメソッドとして抽出します。これにより、条件式の意図が明確になります。
  - **条件ブロックのメソッド抽出:** `if`や`else`ブロック内の処理が長い場合、その処理の塊をメソッドとして抽出します。元の`if`文は、条件に応じて適切なメソッドを呼び出すだけになり、全体の構造が把握しやすくなります。
  - **条件分岐をポリモーフィズムで置き換える:** オブジェクトの状態や種類によって振る舞いが変わる場合、**State パターン**や **Strategy パターン**などのデザインパターンを適用し、条件分岐そのものをなくすことを目指します（「デザインパターン入門」参照）。

---

ここで紹介した「不吉な臭い」はほんの一例です。『リファクタリング 第 2 版』には、さらに多くのコードの臭いとその対処法がカタログとしてまとめられています。

大切なのは、これらの「不吉な臭い」はあくまで**リファクタリングを検討するきっかけ**であり、必ずしも絶対的な悪ではない、ということです。状況によっては、あえて特定の「不吉な臭い」を残す判断が合理的な場合もあります。しかし、これらのサインに気づけるようになることは、コードの品質を継続的に改善していく上で非常に重要なスキルです。

次のセクションでは、これらの「不吉な臭い」に気づいたとき、あるいは他のきっかけで、実際にリファクタリングを「いつ」行うのが効果的かについて見ていきましょう。

## 2.3 「不吉な臭い」を感じたら、改善のチャンス

前のセクションで、いくつかの代表的な「コードの臭い」を紹介しました。重複したコード、長すぎるメソッド、巨大なクラス、複雑な条件分岐… これらは、プログラムが「もっと良くできるかもしれない」と私たちに教えてくれるサインです。

しかし「不吉な臭い」は、必ずしも即座に修正しなければならない致命的な欠陥ではありません。むしろ、それは「このコード、もっと分かりやすくするにはどうすればいいかな？」「将来、ここに変更が加わるとしたら、どういう問題が起きそうかな？」といった、**より良いコード、より良い設計について考えるきっかけを与えてくれる貴重なヒント**なのです。

『リファクタリング・ウェットウェア』では、プログラマがコードの「感覚」を磨き、改善点に気づく能力を高めることの重要性が語られています。コードの臭いを嗅ぎ分ける能力は、まさにこの「コード感覚」の一部と言えるでしょう。

**「不吉な臭い」を感じた後のアクション**

コードから「不吉な臭い」を感じたら、すぐに修正に取り掛かる前に、いくつか考えてみることがあります。

1. **本当に問題か？を考える**  
   その「不吉な臭い」は、現時点で、あるいは近い将来において、具体的にどのような問題（読みにくさ、変更のしにくさ、バグのリスクなど）を引き起こす可能性があるでしょうか？もし、現時点ではほとんど問題がなく、将来的な変更の可能性も低いのであれば、無理にリファクタリングを行う必要はないかもしれません。リファクタリングにもコスト（時間と労力）がかかることを忘れてはいけません。
2. **原因を探る**  
   なぜその「不吉な臭い」が発生したのでしょうか？設計段階での考慮不足か、度重なる機能追加の結果か、あるいは単なるコーディングスタイルの問題か。原因を理解することで、より根本的な解決策を見つけやすくなります。
3. **改善方法を検討する**  
   その「不吉な臭い」を取り除くためには、どのようなリファクタリング手法（第 4 章で紹介します）が適用できるでしょうか？複数の改善策が考えられる場合は、それぞれのメリット・デメリットを比較検討します。
4. **影響範囲を確認する**  
   リファクタリングを行うことで、他のコード部分にどのような影響が出る可能性があるかを確認します。とくに、そのコードが他の多くの場所から利用されている場合（依存されている場合）は、慎重な判断が必要です。
5. **テストの有無を確認する**  
   安全にリファクタリングを行うためには、変更対象のコードの振る舞いを保証する自動テストが不可欠です（詳しくは第 3 章で述べます）。もしテストがなければ、リファクタリングの前にテストを作成することを優先すべきです。

「不吉な臭い」を感じることは、コードに対する深い理解と、品質への意識が高まっている証拠でもあります。それを無視せずに、改善の機会として捉え、より良いコードを目指して学び、実践していく姿勢が、エンジニアとしての成長に繋がります。

次のセクションでは、具体的にどのようなタイミングでリファクタリングを行うのが効果的かについて、日々の開発サイクルの中での実践方法を見ていきましょう。

## 2.4 いつリファクタリングを行うか？：日々の開発サイクルの中で

コードの「不吉な臭い」に気づき、改善の必要性を感じたとして、では実際にいつリファクタリング作業を行うのが良いのでしょうか？「あとで時間があるときにまとめてやろう」と考えてしまいがちですが、大規模なリファクタリングはリスクも高く、なかなか実行に移せないことが多いものです。

むしろ、リファクタリングは**日々の開発サイクルの中に自然に組み込み、継続的に少しずつ行う**ことが、もっとも効果的であり、推奨されるアプローチです。ここでは、開発プロセスにおけるリファクタリングの具体的なタイミングを見ていきましょう。

### 2.4.1 機能追加・修正の前に：まず動きやすく整える（準備のリファクタリング、『レガシーコードからの脱却』参照）

新しい機能を追加したり、既存の機能を修正したりする必要が出てきたとき、まず対象となるコードを読んで理解しようとしますよね。その際、もしコードが読みにくかったり、変更を加えにくい構造になっていたりしたら、**いきなり機能追加や修正に取り掛かるのではなく、まず先にリファクタリングを行ってコードを整理する**ことを検討しましょう。

これは「**準備のリファクタリング (Preparatory Refactoring)**」とも呼ばれ、『レガシーコードからの脱却』などの書籍でその重要性が強調されています。目的は、これから行う変更作業を**より安全に、より簡単に**できるように、コードの「下地」を整えることです。

たとえば、

- 変更を加えたいメソッドが長すぎるなら、まず**メソッドの抽出 (Extract Method)** で短く分割する。
- 理解しにくい変数名があれば、**変数名の変更 (Rename Variable)** で分かりやすくする。
- 複雑な条件分岐が変更の妨げになりそうなら、**ガード節**などを導入して単純化する。

このように、本格的な変更作業に入る前にコードをクリーンにしておくことで、変更内容そのものに集中でき、バグを混入させるリスクを減らし、結果的に作業全体の効率が向上します。

### 2.4.2 コードを書いた後に：「ボーイスカウト・ルール」の実践（『Clean Code』より）

コードを書き終えて、機能が期待通りに動作することを確認した後も、リファクタリングの良いタイミングです。とくに、ロバート・C・マーティン氏が『Clean Code』で提唱している「**ボーイスカウト・ルール**」は、日々のリファクタリングを習慣化するための素晴らしい指針となります。

> **キャンプ場は、来たときよりもきれいにして立ち去るべし。**

これをソフトウェア開発に当てはめると、「**チェックアウト（変更前）したときよりも、少しでもきれいなコードにしてチェックイン（変更後）する**」という意味になります。

自分が担当した機能追加やバグ修正の範囲内で、たとえ小さなことでも構いません。

- 少し分かりにくい名前を見つけたら、より良い名前に変える。
- ちょっとした重複コードを見つけたら、共通化する。
- コメントを少し追加・修正して、意図を明確にする。

このように、コードに触れるたびに、少しずつでも改善を加えていく習慣を持つことで、コードベース全体の品質が徐々に向上し、将来の「技術的負債」が積み重なるのを防ぐことができます。一度に完璧を目指すのではなく、継続的な小さな改善が大きな力になるのです。

### 2.4.3 コードレビューの後に：フィードバックを活かす

コードレビューは、他の開発者から客観的な視点でコードを見てもらい、改善のためのフィードバックを得る貴重な機会です。レビューで指摘された点、たとえば「ここの変数名は分かりにくい」「このロジックはもっとシンプルに書けるのでは？」といったコメントは、リファクタリングの良いきっかけとなります。

レビューでの指摘を真摯に受け止め、それを反映させるためにリファクタリングを行うことは、コードの品質を高めるだけでなく、自身の設計スキルやコーディングスキルを向上させる上でも非常に有効です。レビュアーがなぜそのような指摘をしたのか、その背景にある設計原則や懸念点を理解しようと努めることが、学びを深める鍵となります。

### 2.4.4 コードを理解するために：読みながら整理する

他人が書いたコードや、あるいは数ヶ月前に自分が書いたコードを理解しようとするとき、コードが複雑だったり読みにくかったりすると、内容を把握するのに苦労しますよね。そんなとき、**コードを理解するプロセスの一部としてリファクタリングを行う**ことも有効です。

たとえば、

- 処理の流れを追いやすくするために、長いメソッドを小さなメソッドに分割してみる。
- 変数の役割を明確にするために、名前を変更してみる。
- 複雑な式を一時変数に置き換えて、意味を分かりやすくしてみる。

このように、コードを読みながら、少しずつ整理・改善していくことで、そのコードの構造や意図に対する理解が深まります。もちろん、変更を加える前にはテストが重要ですし、最終的に元のコードに戻す可能性も考慮に入れますが、「理解のためのリファクタリング」は、能動的なコード読解の方法として役立ちます。

---

このように、リファクタリングは特別なイベントとして計画するだけでなく、**日々の開発活動のさまざまな場面に組み込む**ことができます。「準備として」「仕上げとして」「レビューを受けて」「理解するために」といったタイミングで、意識的にリファクタリングを取り入れる習慣を身につけることが、コードを常に健康な状態に保ち、持続可能なソフトウェア開発を実現するための鍵となります。

次の章では、リファクタリングを安全かつ効果的に進めるために不可欠な技術、とくに自動テストの重要性について詳しく見ていきましょう。

# 3. 安全第一！リファクタリングを支える技術

前の章では、リファクタリングを行う「きっかけ」と「タイミング」について学びました。コードをより良く改善していくことは非常に重要ですが、同時に細心の注意も必要です。なぜなら、リファクタリングの定義は「**外部から見たときのソフトウェアの振る舞いを変えずに**、内部の構造を改善すること」だからです。もし、改善の過程で意図せずプログラムの動作を変えてしまい、新しいバグを生み出してしまったら、元も子もありません。

この章では、リファクタリングを安全かつ自信を持って進めるために不可欠な「安全網」となる技術について解説します。

## 3.1 もっとも重要な安全網：自動テストの役割

リファクタリングを行う上で、**もっとも重要な技術**と言っても過言ではないのが、「**自動テスト (Automated Testing)**」、とくに「**単体テスト (Unit Testing)**」です。自動テストとは、プログラムの一部（たとえば特定のメソッドやクラス）が期待通りに動作するかどうかを、別のプログラム（テストコード）を使って自動的に検証する仕組みのことです。

### 3.1.1 振る舞いが変わっていないことを保証するテストの力

なぜ自動テストがリファクタリングにとって不可欠なのでしょうか？それは、**自動テストが「ソフトウェアの振る舞いが、変更前後で変わっていないこと」を客観的かつ迅速に保証するための、もっとも信頼できる手段**だからです。

リファクタリングを行う前に対象コードに対する自動テストが整備されていれば、以下のような強力なサポートを得られます。

1. **変更前の状態を記録**  
   既存のテストは、リファクタリング前のコードがどのような振る舞いをすべきかを示す「生きた仕様書」の役割を果たします。
2. **変更による影響の検知**  
   リファクタリング作業中にコードを少し変更したら、すぐにテストを実行します。もしテストが失敗すれば（「赤」になれば）、それは加えた変更が意図せず外部の振る舞いを変えてしまった（バグを混入させた）可能性が高いことを即座に示してくれます。
3. **自信を持って変更できる安心感**  
   すべてのテストが成功している（「緑」である）限り、「少なくともテストでカバーされている範囲の振る舞いは、以前と同じである」という確信を持つことができます。これにより、開発者は安心して、より大胆にコードの改善に取り組むことができます。

手動でプログラムを実行して動作を確認する方法（手動テスト）も時には必要ですが、リファクタリングのように頻繁にコードを変更し、そのたびに動作を確認する必要がある場合、手動テストでは時間もかかり、見落としも発生しやすくなります。自動テストがあれば、ボタン 1 つで何度でも、網羅的に、かつ瞬時に動作確認ができるのです。

### 3.1.2 テストがないコードのリファクタリングのリスク（『レガシーコードからの脱却』参照）

もし、リファクタリングしたいコードに対して自動テストが存在しない場合、状況は一変します。そのコードを変更することが、**非常に危険な行為**となる可能性があるのです。

マイケル・フェザーズ氏の著書『レガシーコードからの脱却』では、「**テストで保護されていないコードはレガシーコードである**」という考え方が提示されています。テストがないコードは、たとえ昨日書かれたばかりのコードであっても、安全に変更を加えることが難しい、という意味です。

テストがない状態でリファクタリングを行うことには、以下のような深刻なリスクが伴います。

- **デグレード（機能低下）の発生:** リファクタリングによって、既存の機能が意図せず壊れてしまう（デグレードする）リスクが非常に高くなります。
- **バグ混入の恐怖:** 変更が正しく行われたかを客観的に確認する手段がないため、開発者は常に「何か壊してしまったのではないか？」という不安を抱えながら作業することになります。この恐怖心が、本来行うべき改善への意欲を削いでしまうことにもつながります。
- **変更箇所の特定困難:** 問題が発生した場合でも、どの変更が原因なのかを特定するのが難しくなります。
- **手戻りのコスト増大:** リファクタリング後に問題が発覚した場合、原因究明や修正に多大な時間とコストがかかる可能性があります。

したがって、**テストコードが存在しない、あるいは不十分なコードに対して大規模なリファクタリングを行うことは、原則として避けるべき**です。もしそのようなコードを改善したいのであれば、最初にやるべきことは、そのコードの**現在の振る舞いを保証するためのテストコードを書くこと**なのです。

### 3.1.3 リファクタリングのためのテスト戦略

では、リファクタリングを安全に進めるためには、どのようなテストを、どのように用意すればよいのでしょうか？

- **単体テスト (Unit Test) を中心に**  
  リファクタリングは主にコードの内部構造の変更であるため、個々のクラスやメソッドといった比較的小さな単位の振る舞いを検証する「単体テスト」がもっとも適しています。単体テストは実行速度が速く、問題発生時の原因特定も容易です。
- **カバレッジ（網羅率）を意識する**  
  テストが対象コードのどの部分をカバーしているか（カバレッジ）を意識し、重要なロジックや複雑な分岐がテストされていることを確認します。ただし、カバレッジ 100% を機械的に目指すのではなく、リスクの高い箇所や重要な機能を優先的にテストすることが現実的です。
- **既存の振る舞いを固定するテストを**  
  テストがないレガシーコードにテストを追加する場合、まずは「現在のコードが実際にどのように動いているか」を確認し、その振る舞いを固定するようなテスト（**ベースラインテスト** と呼ばれることもあります）を書くことから始めます。たとえ現在の振る舞いが完全に正しくないとしても、リファクタリングによって意図せず現状の振る舞いが変わらないことを保証することが目的です。
- **テストしやすい設計を心がける**  
  日頃からテスト容易性を意識した設計（たとえば、依存性の注入(DI)を活用して依存関係を疎にするなど、「オブジェクト指向設計入門」参照）を心がけることで、リファクタリングも行いやすくなります。

テストを書くこと自体にも学習と慣れが必要ですが、それはリファクタリングを安全かつ効果的に行うための、そして高品質なソフトウェアを開発するための、必要不可欠な投資です。『リファクタリング 第 2 版』でも、テストの重要性は繰り返し強調されており、リファクタリングの各手順においてテストの実行が前提とされています。

次のセクションでは、テストという安全網を確保した上で、リファクタリングをどのように「小さく、着実に」進めていくか、そのステップについて見ていきましょう。

## 3.2 小さく、着実に進めるステップ

自動テストという強力な安全網が用意できたら、いよいよリファクタリングの作業に入ります。しかし、ここで焦って一度に多くの変更を加えようとするのは得策ではありません。安全かつ効果的にリファクタリングを進めるための秘訣は、「**小さく、着実に進めること**」にあります。

これは、登山に例えるなら、一気に山頂を目指すのではなく、一歩一歩足元を確認しながら、休憩を挟みつつ着実に登っていくイメージです。各ステップが小さければ、もし途中で道に迷ったり、足を滑らせたりしても、すぐに気づいて元の場所に戻り、安全なルートを選び直すことができます。

リファクタリングにおける「小さなステップ」とは、具体的に以下のような進め方を指します。

1. **一度に 1 つの「不吉な臭い」に集中する**  
   コードを眺めていると、「ここも気になる」「あそこも直したい」と、複数の改善点が見つかるかもしれません。しかし、一度の作業では、まず**1 つの特定の「不吉な臭い」や改善点にターゲットを絞り**、それに対するリファクタリングだけを行うように心がけましょう。たとえば、「このメソッドが長すぎるから分割する」と決めたら、まずはその作業に集中し、他の気になる点（変数名が悪いなど）は、次のステップで行うか、別途記録しておきます。
2. **適用するリファクタリング手法を 1 つずつ**  
   ターゲットを絞ったら、それを改善するための具体的なリファクタリング手法（第 4 章で紹介するような「メソッドの抽出」や「変数名の変更」など）を**1 つだけ**適用します。複数のリファクタリングを同時に行おうとすると、もしテストが失敗した場合に、どの変更が原因なのかを特定するのが難しくなります。
3. **変更したら、すぐにテストを実行**  
   1 つのリファクタリング手法を適用し、コードを少し変更したら、**すぐに自動テストを実行**します。ここでテストがすべて成功すれば（「緑」になれば）、加えた変更が（少なくともテストの範囲では）外部の振る舞いを壊していないことが確認でき、次のステップに進む自信が得られます。もしテストが失敗したら（「赤」になれば）、その直前の変更に問題があったことがすぐに分かります。原因を特定して修正するか、あるいは一旦変更を元に戻して、別の方法を試すことができます。
4. **テストが通ったら、こまめにコミット**  
   テストが成功し、意図した改善が行われたことを確認できたら、その変更内容をバージョン管理システムにコミットします。コミットメッセージには、どのようなリファクタリングを行ったかを簡潔に記述しておくと、後で変更履歴を確認する際に役立ちます。こまめにコミットしておくことで、もし後続の作業で問題が発生した場合でも、最後にテストが成功していた安全な状態に簡単に戻ることができます。

**この「変更 → テスト → 確認 → コミット」という短いサイクルを、何度も繰り返すこと**が、安全なリファクタリングの基本リズムです。『リファクタリング 第 2 版』で紹介されている多くのリファクタリング手法も、この小さなステップで安全に進められるように考えられています。

時間は少しかかるように感じるかもしれませんが、この地道な進め方が、結果的に問題を早期に発見し、手戻りを最小限に抑え、最終的にはより早く、より安全にコードの改善を達成することにつながります。焦らず、ひとつひとつのステップを確認しながら進めることが、リファクタリング成功の鍵なのです。

次のセクションでは、この「小さく、着実に進める」アプローチを支えるもう 1 つの重要なツールである、バージョン管理システム（Git）の活用について見ていきましょう。

## 3.3 バージョン管理システム (Git) の活用

自動テストと並んで、リファクタリングを安全かつ効率的に進める上で欠かせないツールが、「**バージョン管理システム (Version Control System, VCS)**」、とくに現代の開発で広く使われている「**Git**」です。Git は、ファイルの変更履歴を記録し、管理するためのシステムであり、リファクタリング作業において強力なセーフティネットと作業記録の役割を果たします。

前のセクションで述べた「小さく、着実に進めるステップ」を実践する上で、Git を活用することには以下のような大きなメリットがあります。

1. **いつでも元に戻せる安心感 (Undo)**  
   リファクタリング作業は、時に予期せぬ問題を引き起こす可能性があります。テストが失敗して原因がすぐには分からない場合や、試してみた改善が思ったような効果をもたらさなかった場合など、「やっぱり元の状態に戻したい」と思う場面が出てくるかもしれません。
   Git を使っていれば、こまめに変更内容をコミットしておくことで、**いつでも過去の特定のコミット時点の状態にコードを正確に戻す**ことができます。この「いつでも安全な場所に戻れる」という保証は、開発者が安心してリファクタリングに挑戦するための心理的な支えとなります。大きな変更を加える前には、まず現在の安定した状態をコミットしておく、という習慣をつけると良いでしょう。
2. **変更履歴の明確な記録**  
   リファクタリングで行った変更は、「なぜ」「何を」「どのように」改善したのかを後から理解できるように、**意味のある単位でコミット**し、**分かりやすいコミットメッセージ**を記述しておくことが重要です。
   たとえば、「`Refactor: Extract method calculateTotalPrice from processOrder`」（リファクタリング: processOrder から calculateTotalPrice メソッドを抽出）のようなメッセージです。良いコミットメッセージは、以下のような点で役立ちます。
   - **未来の自分へのメモ:** 後日、なぜこの変更が行われたのかを思い出す手助けになります。
   - **チームメンバーとのコミュニケーション:** 他のメンバーがコードの変更履歴を見たときに、リファクタリングの意図を理解しやすくなります。コードレビューの際にも役立ちます。
   - **問題発生時の原因調査:** もしリファクタリング後に問題が見つかった場合、どのコミットで問題が混入したのかを追跡する（たとえば `git bisect` を使う）のに役立ちます。
3. **段階的な変更の管理**  
   「小さく、着実に進める」というリファクタリングのリズムは、Git のコミット単位と非常に相性が良いです。1 つのリファクタリングを行い、テストが成功したら、その変更だけを 1 つのコミットとして記録します。次に別のリファクタリングを行い、テストが成功したら、また別のコミットとして記録します。このように、**意味のある変更単位でコミットを積み重ねていく**ことで、リファクタリングのプロセス全体が、後から追いやすい明確なステップとして記録されます。
4. **ブランチの活用 (応用)**  
   比較的大規模なリファクタリングを行う場合や、他の開発作業と並行してリファクタリングを進めたい場合には、**専用のブランチ (branch)** を作成して作業を行うのが良いプラクティスです。これにより、リファクタリング中の不安定な状態がメインのコードライン（`main` や `master` ブランチ）に影響を与えるのを防ぐことができます。リファクタリングが完了し、テストで安全性が確認できたら、そのブランチをメインラインに統合（マージ）します。

Git の基本的な使い方を習得することは、リファクタリングだけでなく、現代のソフトウェア開発全般において必須のスキルです。（「プログラミング基礎」資料の「バージョン管理システム (Git) の基本とベストプラクティスについて」も参照してください）。

自動テストとバージョン管理システムという 2 つの強力なツールを使いこなすことで、リファクタリングは決して怖い作業ではなく、コードを継続的に改善していくための安全で効果的な手段となります。

次の章では、いよいよ具体的なリファクタリングのテクニックについて、基本的なものをいくつか紹介します。

# 4. はじめの一歩：基本的なリファクタリング・テクニック集

安全なリファクタリングの進め方を学んだところで、いよいよ具体的な改善テクニックを見ていきましょう。リファクタリングの手法は数多く存在しますが、ここでは若手エンジニアの皆さんが最初に取り組むのに適した、基本的かつ効果の高いテクニックをいくつか紹介します。

これらのテクニックは、『リファクタリング 第 2 版』で紹介されているカタログに基づいています。各テクニックについて、「どんな時に使うか（動機）」「どのように行うか（手順の概要）」「簡単なコード例」を示します。

## 4.1 名前の改善：意図を明確にする

ソフトウェア開発において「名前」は非常に重要です。変数名、メソッド名、クラス名などが、その役割や意図を正確に伝えていれば、コードは格段に読みやすく、理解しやすくなります。逆に、不適切だったり曖昧だったりする名前は、混乱や誤解を招き、バグの原因にさえなりかねません。

「プログラミング基礎」の「命名について」でも触れましたが、良い名前を付けることは、もっとも簡単で、かつ効果の高いリファクタリングの 1 つです。

### 4.1.1 メソッド名の変更 (Rename Method)

- **どんな時に使うか？（動機）**  
  メソッドの名前が、そのメソッドが実際に何をしているのかを正確に表していない場合。あるいは、名前が曖昧で、複数の意味に解釈できてしまう場合。良いメソッド名は、通常「動詞」または「動詞 + 目的語」の形を取り、その処理内容を具体的に示します。
- **どのように行うか？（手順の概要）**
  1. より分かりやすく、処理内容を正確に反映する新しいメソッド名を考えます。
  2. メソッドの宣言部分の名前を変更します。
  3. そのメソッドを呼び出している箇所すべてを探し出し、新しい名前に修正します。
     （多くの統合開発環境(IDE)には、このリネーム作業を自動かつ安全に行う機能があります）
  4. テストを実行し、変更によって振る舞いが変わっていないことを確認します。
- **コード例:**

  ```java
  // Before: メソッド名が曖昧
  class Customer {
      private String name;
      private String address;

      // ... constructor ...

      // "get" という名前だけでは、何を取得するのか不明瞭
      public String get() {
          return name + " (" + address + ")";
      }
  }
  ```

  ```java
  // After: 処理内容が明確な名前に変更
  class Customer {
      private String name;
      private String address;

      // ... constructor ...

      // メソッドの処理内容（名前と住所を整形して返す）が名前から分かる
      public String getFormattedNameAndAddress() {
          return name + " (" + address + ")";
      }
  }

  // 利用側も変更
  // String customerInfo = customer.get();
  String customerInfo = customer.getFormattedNameAndAddress();
  ```

### 4.1.2 変数名の変更 (Rename Variable)

- **どんな時に使うか？（動機）**  
  変数（ローカル変数、パラメータ、フィールド変数）の名前が、その変数が保持しているデータや役割を明確に示していない場合。`i`, `j`, `k` (短いループカウンタを除く)、`tmp`, `val`, `data` のような、意味のない、あるいは曖昧な名前が使われている場合。
- **どのように行うか？（手順の概要）**
  1. 変数が表す内容や目的が明確に伝わる、より具体的な新しい名前を考えます。
  2. 変数が宣言されている箇所と、その変数が使用されている箇所すべての名前を変更します。
     （これも IDE のリファクタリング機能を使うと安全かつ効率的です）
  3. その変数が使われているスコープが広い場合（たとえばクラスのフィールド変数など）は、とくに注意深く影響範囲を確認します。
  4. テストを実行し、変更によって振る舞いが変わっていないことを確認します。
- **コード例:**

  ```java
  // Before: 変数名が曖昧
  public double calculateTotal(double price, int quantity, double taxRate) {
      double val = price * quantity; // "val" は何の値か不明瞭
      double tax = val * taxRate;    // "tax" は税額だと推測できるが…
      return val + tax;
  }
  ```

  ```java
  // After: 変数の意味が明確な名前に変更
  public double calculateTotal(double price, int quantity, double taxRate) {
      double subtotal = price * quantity; // 小計であることが明確
      double taxAmount = subtotal * taxRate; // 税額であることが明確
      return subtotal + taxAmount;
  }
  ```

---

名前の変更は、一見地味なリファクタリングに見えるかもしれませんが、コードの可読性を向上させる上で絶大な効果を発揮します。『Clean Code』や『リーダブルコード』でも、命名の重要性は繰り返し強調されています。分かりにくい名前を見つけたら、ためらわずに、より良い名前を付けることを習慣にしましょう。IDE のリファクタリング機能を活用すれば、これらの作業は比較的安全かつ簡単に行えます。

次のセクションでは、メソッドの構造を改善するための基本的なリファクタリング・テクニックを見ていきます。

## 4.2 メソッドの整理：責務を明確にする

メソッド（または関数）は、プログラムの基本的な構成要素の 1 つです。メソッドの責務が明確で、適切な長さであれば、コードは理解しやすく、テストや再利用もしやすくなります。しかし、開発が進むにつれて、メソッドが長くなりすぎたり、逆に細かく分けすぎて分かりにくくなったりすることもあります。ここでは、メソッドの構造を整理し、責務を明確にするための基本的なリファクタリング・テクニックを紹介します。

### 4.2.1 メソッドの抽出 (Extract Method)

- **どんな時に使うか？（動機）**
  - **メソッドが長すぎる (Long Method):** 1 つのメソッドが多くの処理を行い、数十行以上に及んでいる場合。これは「コードの不吉な臭い」の代表例です。
  - **コードにコメントが多い:** コードのある部分に「ここから〇〇の処理」のようなコメントがたくさん付いている場合、それは独立したメソッドとして切り出せるサインかもしれません。メソッド名がコメントの代わりになります。
  - **コードの塊を再利用したい:** メソッド内の一部分のロジックを、他の場所でも使いたい場合。
  - **責務を分離したい:** 1 つのメソッドが複数の異なる関心事（たとえば、データの取得、計算、表示など）を扱っており、それらを分離したい場合。
- **どのように行うか？（手順の概要）**
  1. 元のメソッドの中から、論理的にまとまっているコードの断片（特定の目的を持つ一連の処理）を見つけ出します。
  2. そのコード断片を、新しい独立したメソッドとして切り出します。
  3. 新しいメソッドに、その処理内容を明確に表す名前を付けます。
  4. 元のコード断片が必要としていたローカル変数やパラメータを特定し、それらを新しいメソッドの引数として渡します。
  5. 元のコード断片が結果を計算していた場合、その結果を新しいメソッドの戻り値として返します。
  6. 元のメソッド内で、切り出したコード断片があった場所に、新しいメソッドの呼び出しを挿入します。
  7. テストを実行し、振る舞いが変わっていないことを確認します。
     （IDE のリファクタリング機能を使えば、これらの手順の多くを自動化できます）
- **コード例:**

  ```java
  // Before: 注文情報を表示するメソッドが長い
  void printOrderDetails(Order order) {
      // ヘッダー出力
      System.out.println("*************************");
      System.out.println("****** 注文詳細 ******");
      System.out.println("*************************");

      // 顧客情報出力
      System.out.println("顧客名: " + order.getCustomerName());
      System.out.println("住所: " + order.getCustomerAddress());

      // 注文明細出力
      double total = 0.0;
      for (Item item : order.getItems()) {
          System.out.println("  商品名: " + item.getName());
          System.out.println("  単価: " + item.getPrice());
          System.out.println("  数量: " + item.getQuantity());
          total += item.getPrice() * item.getQuantity();
      }

      // 合計金額出力
      System.out.println("-------------------------");
      System.out.println("合計金額: " + total);
      System.out.println("*************************");
  }
  ```

  ```java
  // After: 処理の塊をメソッドとして抽出
  void printOrderDetails(Order order) {
      printHeader(); // ヘッダー出力メソッドを抽出
      printCustomerInfo(order); // 顧客情報出力メソッドを抽出
      printLineItems(order); // 注文明細出力メソッドを抽出 (合計計算も含む場合あり)
      // もしくは:
      // double total = calculateTotal(order); // 合計計算を抽出
      // printLineItemsWithoutTotal(order);
      // printTotal(total); // 合計出力メソッドを抽出
  }

  // 抽出されたメソッド群
  private void printHeader() {
      System.out.println("*************************");
      System.out.println("****** 注文詳細 ******");
      System.out.println("*************************");
  }

  private void printCustomerInfo(Order order) {
      System.out.println("顧客名: " + order.getCustomerName());
      System.out.println("住所: " + order.getCustomerAddress());
  }

  private void printLineItems(Order order) { // 例: 合計計算も含む場合
      double total = 0.0;
      System.out.println("--- 注文明細 ---");
      for (Item item : order.getItems()) {
          System.out.println("  商品名: " + item.getName());
          // ... (単価、数量の出力) ...
          total += item.getPrice() * item.getQuantity();
      }
      System.out.println("-------------------------");
      System.out.println("合計金額: " + total); // ここで合計も出力
      System.out.println("*************************");
  }
  // (合計計算や合計出力をさらに別メソッドに抽出することも可能)
  ```

  「メソッドの抽出」は、おそらくもっとも頻繁に使われ、かつ効果的なリファクタリング手法の 1 つです。これにより、コードが部品化され、それぞれの部品（メソッド）が持つ責任が明確になり、コード全体の可読性と保守性が劇的に向上します。『リファクタリング 第 2 版』でも、その重要性が強調されています。

### 4.2.2 メソッドのインライン化 (Inline Method)

- **どんな時に使うか？（動機）**
  - **メソッドの処理内容が、そのメソッド名と同じくらい自明で短い場合:** メソッド呼び出しという間接層が、かえってコードを読みにくくしていると感じる場合。
  - **メソッドの責務が不明確、あるいは名前が悪い:** メソッドの内容が単純すぎて、良い名前を付けるのが難しい、または現在の名前が誤解を招く場合。
  - **リファクタリングの途中経過:** 他のリファクタリング（たとえば、不要になったメソッドを削除する前段階）として、一時的にインライン化を行う場合。
- **どのように行うか？（手順の概要）**
  1. インライン化したいメソッドを呼び出している箇所を探します。
  2. 各呼び出し箇所を、そのメソッドの実際の処理内容（コード本体）で置き換えます。
  3. メソッド本体で使われているパラメータやローカル変数と、呼び出し側の変数の名前が衝突しないかなどを確認します。
  4. すべての呼び出し箇所を置き換えたら、元のメソッド定義を削除します。
  5. テストを実行し、振る舞いが変わっていないことを確認します。
     （これも IDE の機能で安全に行えることが多いです）
- **コード例:**

  ```java
  // Before: メソッドが単純すぎる
  class Order {
      private double amount;
      // ...
      public boolean isLargeOrder() {
          // メソッドの内容が非常に単純
          return amount > 10000;
      }
  }

  // 利用側
  if (order.isLargeOrder()) { // メソッド呼び出し
      applyDiscount(order);
  }
  ```

  ```java
  // After: メソッド呼び出しを本体のコードで置き換え
  class Order {
      private double amount;
      // ...
      // isLargeOrder() メソッドは削除される
  }

  // 利用側 (メソッド呼び出しをインライン化)
  if (order.amount > 10000) { // 直接条件を記述
      applyDiscount(order);
  }
  ```

  メソッドのインライン化は、「メソッドの抽出」とは逆方向のリファクタリングです。メソッドを抽出しすぎると、かえってコードの断片化が進み、処理の流れを追いにくくなることもあります。インライン化は、そのような**不必要な間接層を取り除き、コードをより直接的にする**ために使われます。ただし、インライン化によって呼び出し元のメソッドが長くなりすぎる場合は、別のリファクタリング（たとえば、インライン化後に再度、より適切な形でメソッドを抽出するなど）を検討する必要があります。

---

「メソッドの抽出」と「メソッドのインライン化」は、メソッドの粒度や責務を調整するための基本的なツールです。どちらの手法も、コードの可読性と保守性を向上させるという共通の目的を持っています。状況に応じて適切に使い分けることが、クリーンなコードを維持する上で重要です。

次のセクションでは、複雑になりがちな条件分岐を整理するためのリファクタリング・テクニックを見ていきます。

## 4.3 条件分岐の単純化：流れを分かりやすくする

プログラムにおいて、条件によって処理の流れを変える `if` 文や `switch` 文は不可欠な要素です。しかし、これらの条件分岐が複雑に絡み合ったり、何重にもネスト（入れ子）したりすると、コードは急速に理解しにくくなり、バグの温床にもなりかねません。ここでは、複雑な条件分岐を単純化し、コードの流れをスムーズにするための代表的なリファクタリング・テクニックを紹介します。

### 4.3.1 ガード節による入れ子の単純化 (Replace Nested Conditional with Guard Clauses)

- **どんな時に使うか？（動機）**
  - `if-else` 文が深くネストしていて、正常系の処理がどこにあるのか分かりにくい場合（「**矢印コード (Arrow Code)**」と呼ばれるインデントが深くなる形）。
  - メソッドの大部分が、特定の条件を満たした場合（正常系）にのみ実行され、それ以外の条件（異常系や特殊ケース）ではすぐに処理を終了したい場合。
- **どのように行うか？（手順の概要）**
  1. ネストした `if` 文の中から、異常系や特殊な条件（処理を続行しない条件）を見つけ出します。
  2. その条件をメソッドの先頭に移動させ、条件に合致した場合にはすぐに `return` (または `throw` や `break`, `continue` など、状況に応じて) するように記述します。この早期リターンする部分を「**ガード節 (Guard Clause)**」と呼びます。
  3. すべてのガード節を記述したら、残りのコード（主となる正常系の処理）はネストが浅くなり、インデントも減って読みやすくなります。
  4. テストを実行し、振る舞いが変わっていないことを確認します。
- **コード例:**

  ```java
  // Before: if-else のネストが深い
  double getAdjustedCapital(Client client) {
      double result = 0.0;
      if (client != null) { // null チェック
          if (client.getCapital() > 0) { // 資本チェック
              if (client.getInterestRate() > 0 && client.getDuration() > 0) { // 利率と期間チェック
                  // 正常系の計算処理 (深いネストの中にある)
                  result = (client.getIncome() / client.getDuration()) * client.getAdjustmentFactor();
                  result += client.getCapital() * (1 + client.getInterestRate());
                  // ... さらに処理が続く ...
              } else {
                  // 利率または期間が不正な場合
                  System.err.println("利率または期間が無効です。");
                  result = -1.0; // エラーを示す値
              }
          } else {
              // 資本が 0 以下の場合
              System.err.println("資本が 0 以下です。");
              result = -1.0;
          }
      } else {
          // client が null の場合
          System.err.println("クライアントが null です。");
          result = -1.0;
      }
      return result;
  }
  ```

  ```java
  // After: ガード節を使ってネストを解消
  double getAdjustedCapitalRefactored(Client client) {
      // ガード節1: null チェック
      if (client == null) {
          System.err.println("クライアントが null です。");
          return -1.0; // 早期リターン
      }
      // ガード節2: 資本チェック
      if (client.getCapital() <= 0) {
          System.err.println("資本が 0 以下です。");
          return -1.0; // 早期リターン
      }
      // ガード節3: 利率と期間チェック
      if (client.getInterestRate() <= 0 || client.getDuration() <= 0) {
          System.err.println("利率または期間が無効です。");
          return -1.0; // 早期リターン
      }

      // すべてのガード節を通過したら、ここが正常系の処理
      // ネストがなくなり、インデントも浅く、読みやすい！
      double result = (client.getIncome() / client.getDuration()) * client.getAdjustmentFactor();
      result += client.getCapital() * (1 + client.getInterestRate());
      // ... さらに処理が続く ...

      return result;
  }
  ```

  ガード節を使うことで、異常系や前提条件のチェックをメソッドの冒頭にまとめ、主となる処理の流れを非常にすっきりとさせることができます。これは可読性向上に大きく貢献するテクニックです。『リーダブルコード』や『Clean Code』でも推奨されています。

### 4.3.2 条件記述の分解 (Decompose Conditional)

- **どんな時に使うか？（動機）**
  - `if`, `else if`, `else` のブロック内や、`switch` の `case` 内で行われている処理が複雑で長い場合。
  - 条件式 (`if (...)` のカッコの中) 自体が非常に長く、読みにくい場合。
- **どのように行うか？（手順の概要）**
  1. `if`, `else if`, `else` の各ブロック内の処理の塊を、それぞれ独立したメソッドとして抽出します。抽出したメソッドには、その処理内容を表す分かりやすい名前を付けます。
  2. もし条件式自体が複雑な場合は、その条件式を評価するロジックを、真偽値 (`boolean`) を返す説明的な名前を持つメソッドとして抽出します。
  3. 元の `if` 文は、抽出されたメソッドを呼び出すだけの、よりシンプルで意図が明確な形になります。
  4. テストを実行し、振る舞いが変わっていないことを確認します。
- **コード例:**

  ```java
  // Before: 条件式と処理ブロックが複雑
  void processPayment(Payment payment, User user) {
      if (user.isActive() && payment.getAmount() > 0 && payment.getDueDate().isAfter(LocalDate.now())) {
          // 正常な支払い処理 (複雑なロジック)
          System.out.println("支払い処理を実行します...");
          connectToPaymentGateway(payment.getCredentials());
          TransactionResult result = chargeAmount(payment.getAmount());
          updatePaymentStatus(payment, result.getStatus());
          sendPaymentConfirmation(user.getEmail(), payment.getId());
          System.out.println("支払い処理完了。");
      } else {
          // エラー処理 (これもいくつかのステップがあるかもしれない)
          System.out.println("支払い処理エラー:");
          if (!user.isActive()) {
              logError("ユーザーが無効です: " + user.getId());
              notifyUserOfInactiveAccount(user.getEmail());
          } else if (payment.getAmount() <= 0) {
              logError("支払い金額が無効です: " + payment.getId());
          } else {
              logError("支払い期限切れです: " + payment.getId());
              sendOverdueNotice(user.getEmail(), payment.getId());
          }
          updatePaymentStatus(payment, PaymentStatus.FAILED);
      }
  }
  ```

  ```java
  // After: 条件式と処理ブロックをメソッドに抽出
  void processPaymentRefactored(Payment payment, User user) {
      if (isPaymentValid(payment, user)) { // ★ 条件式をメソッドに抽出
          executePaymentProcessing(payment, user); // ★ 正常系の処理をメソッドに抽出
      } else {
          handlePaymentError(payment, user); // ★ エラー処理をメソッドに抽出
      }
  }

  // 抽出されたメソッド群
  private boolean isPaymentValid(Payment payment, User user) {
      // 条件式の意図がメソッド名で明確になる
      return user.isActive() && payment.getAmount() > 0 && payment.getDueDate().isAfter(LocalDate.now());
  }

  private void executePaymentProcessing(Payment payment, User user) {
      // 正常系の処理がまとまって読みやすい
      System.out.println("支払い処理を実行します...");
      connectToPaymentGateway(payment.getCredentials());
      TransactionResult result = chargeAmount(payment.getAmount());
      updatePaymentStatus(payment, result.getStatus());
      sendPaymentConfirmation(user.getEmail(), payment.getId());
      System.out.println("支払い処理完了。");
  }

  private void handlePaymentError(Payment payment, User user) {
      // エラー処理がまとまって読みやすい
      System.out.println("支払い処理エラー:");
      if (!user.isActive()) {
          logError("ユーザーが無効です: " + user.getId());
          notifyUserOfInactiveAccount(user.getEmail());
      } else if (payment.getAmount() <= 0) {
          logError("支払い金額が無効です: " + payment.getId());
      } else { // 期限切れ
          logError("支払い期限切れです: " + payment.getId());
          sendOverdueNotice(user.getEmail(), payment.getId());
      }
      updatePaymentStatus(payment, PaymentStatus.FAILED);
  }
  ```

  条件記述の分解を行うことで、元の `if` 文は「もし支払いが有効なら、支払い処理を実行する。そうでなければ、エラー処理を行う」という、非常に高い抽象度で意図を表現できるようになります。複雑な条件式や処理の詳細は、抽出されたメソッドの中に隠蔽され、コード全体の可読性が大きく向上します。

---

ガード節と条件記述の分解は、複雑な条件分岐に立ち向かうための強力な武器です。これらを適切に使いこなすことで、コードの流れをよりスムーズにし、理解しやすく、保守しやすい状態に保つことができます。

次のセクションでは、コード内に散らばりがちな一時変数やマジックナンバーを整理するためのリファクタリング・テクニックを見ていきましょう。

## 4.4 コードの整理：不要な要素をなくす

コードを書いていると、計算の途中結果を保持するためだけに一時的な変数を使ったり、特定の意味を持つ数値をそのままコード内に記述したりすることがあります。これらは一見些細なことのように思えますが、積み重なるとコードの理解を妨げ、変更を難しくする要因となり得ます。ここでは、このような不要な要素を整理し、コードをよりクリーンにするためのリファクタリング・テクニックを紹介します。

### 4.4.1 一時変数の削除 (Replace Temp with Query)

- **どんな時に使うか？（動機）**
  - メソッド内で、ある計算結果を一時的に保持するためだけに使われているローカル変数（一時変数、Temp）があり、その変数がその後変更されることなく参照されている場合。
  - その一時変数が、メソッド内の他の部分の理解を助けるどころか、かえってノイズになっていると感じる場合。
  - 同じ計算がメソッド内の複数箇所で行われており、それを一時変数で共通化しようとしているが、その計算ロジック自体をメソッドとして切り出した方が良い場合。
- **どのように行うか？（手順の概要）**
  1. 一時変数に値を代入している計算式（または一連の処理）を見つけます。
  2. その計算処理を、新しいメソッドとして抽出します。この新しいメソッドは、計算結果を返すようにします。このメソッドは「**問い合わせメソッド (Query Method)**」とも呼ばれます。
  3. 一時変数を宣言している箇所と、その変数に値を代入している箇所を削除します。
  4. 一時変数を参照していた箇所すべてを、新しいメソッドの呼び出しに置き換えます。
  5. テストを実行し、振る舞いが変わっていないことを確認します。
- **コード例:**

  ```java
  // Before: 割引計算に一時変数を使用
  double calculateDiscountedPrice(int quantity, double itemPrice) {
      // 基本価格を計算して一時変数 basePrice に格納
      double basePrice = quantity * itemPrice;
      // 割引率を計算 (例: 1000円以上で10%割引)
      double discountFactor;
      if (basePrice > 1000) {
          discountFactor = 0.90; // 10%割引
      } else {
          discountFactor = 0.95; // 5%割引 (例)
      }
      // 割引後の価格を計算して返す (一時変数 basePrice を参照)
      return basePrice * discountFactor;
  }
  ```

  ```java
  // After: 一時変数 basePrice を問い合わせメソッドに置き換え
  double calculateDiscountedPriceRefactored(int quantity, double itemPrice) {
      // 割引率を計算 (getBasePrice()メソッドを呼び出す)
      double discountFactor;
      if (getBasePrice(quantity, itemPrice) > 1000) { // ★ メソッド呼び出しに置換
          discountFactor = 0.90;
      } else {
          discountFactor = 0.95;
      }
      // 割引後の価格を計算 (getBasePrice()メソッドを呼び出す)
      return getBasePrice(quantity, itemPrice) * discountFactor; // ★ メソッド呼び出しに置換
  }

  // ★ 抽出された問い合わせメソッド (Query Method)
  private double getBasePrice(int quantity, double itemPrice) {
      return quantity * itemPrice;
  }
  ```

  このリファクタリングにより、`basePrice` という一時変数がなくなりました。その代わりに、基本価格を計算する責務を持つ `getBasePrice()` メソッドができました。これにより、元のメソッド `calculateDiscountedPriceRefactored` は、割引率の決定と最終価格の計算という、より上位のロジックに集中できるようになり、可読性が向上します。また、基本価格の計算ロジックが `getBasePrice()` メソッドにカプセル化されたため、もし計算方法を変更する必要が出ても、修正箇所はこのメソッドだけで済みます。

  ただし、注意点として、抽出する計算処理が非常に重い場合、それをメソッドとして何度も呼び出すとパフォーマンスに影響が出る可能性があります。そのような場合は、計算結果をキャッシュするなどの工夫が必要になることもあります。（しかし、多くの場合、このリファクタリングによるパフォーマンスへの影響は無視できる程度です。）

### 4.4.2 マジックナンバーから定数へ (Replace Magic Number with Symbolic Constant)

- **どんな時に使うか？（動機）**
  - コードの中に、数値リテラル（例: `10`, `3.14`, `9.8` など）が直接書かれており、その数値が特定の意味を持っているのに、その意味がコード上から読み取れない場合。このような「意味を持つが、由来が不明な数値」を「**マジックナンバー (Magic Number)**」と呼びます。
  - 同じマジックナンバーが、プログラムの複数箇所で使われている場合。
- **なぜ問題なのか？**
  - **意図が不明:** その数値が何を表しているのか、コードを読んだだけでは理解できません（例: `if (status == 2)` の `2` は何を意味する？）。
  - **変更が困難:** もしその数値の意味が変わった場合（たとえば、消費税率が 8% から 10% に変わるなど）、コード内にハードコードされたすべての箇所を見つけ出して修正する必要があり、修正漏れのリスクがあります。
  - **タイプミスの可能性:** 同じ数値を複数箇所で手入力すると、タイプミスをする可能性があります。
- **どのように行うか？（手順の概要）**
  1. コード内のマジックナンバーを見つけます。
  2. その数値が持つ意味を表す、分かりやすい名前を考えます。
  3. その名前を持つ定数を宣言し、マジックナンバーをその定数の値として定義します。（Java であれば `private static final` など、言語に応じた定数の宣言方法を用います）。
  4. コード内でマジックナンバーが使われている箇所すべてを、宣言した定数に置き換えます。
  5. テストを実行し、振る舞いが変わっていないことを確認します。
- **コード例:**

  ```java
  // Before: マジックナンバーが使われている
  double calculateCircleArea(double radius) {
      // 3.14159 が円周率であることは推測できるが、明示されていない
      return 3.14159 * radius * radius;
  }

  void checkStatus(int statusCode) {
      // 8 や 9 が何を意味するのか、これだけでは分からない
      if (statusCode == 8 || statusCode == 9) {
          System.out.println("処理を継続できません。");
          // ...
      }
  }
  ```

  ```java
  // After: マジックナンバーを意味のある定数に置き換え
  // 定数をクラス内などで宣言
  private static final double PI = 3.14159;
  private static final int STATUS_ERROR_NETWORK = 8;
  private static final int STATUS_ERROR_DATABASE = 9;

  double calculateCircleAreaRefactored(double radius) {
      // 定数を使うことで、値の意味が明確になる
      return PI * radius * radius;
  }

  void checkStatusRefactored(int statusCode) {
      // 定数名によって、条件の意味が読み取れるようになる
      if (statusCode == STATUS_ERROR_NETWORK || statusCode == STATUS_ERROR_DATABASE) {
          System.out.println("処理を継続できません。");
          // ...
      }
  }
  ```

  マジックナンバーを意味のある名前を持つ定数に置き換えることは、コードの可読性と保守性を大きく向上させる、非常に基本的で重要なリファクタリングです。数値だけでなく、文字列リテラル（例: `"processed"`, `"error"` など）が特定の意味を持つ場合も、同様に定数化することを検討しましょう。

---

一時変数やマジックナンバーの整理は、コードをよりクリーンにし、意図を明確にするための基礎的なステップです。これらの小さな改善を積み重ねることが、読みやすく、保守しやすいコードベースを維持するために繋がります。

次の章では、リファクタリングが目指す「より良い設計」とは何か、設計原則やデザインパターンとの関係性について見ていきましょう。

# 5. リファクタリングの目指す先：より良い設計へ

これまでの章で、リファクタリングの「なぜ（Why）」「いつ（When）」「どのように（How）」について学んできました。基本的なテクニックを使えば、コードの臭いを取り除き、読みやすさや安全性を向上させることができます。しかし、リファクタリングの価値は、単にコードをきれいにすることだけにとどまりません。その本質は、**ソフトウェアの内部構造、すなわち「設計」そのものを改善していく活動**にあるのです。

## 5.1 リファクタリングは設計改善活動である

リファクタリングを行う過程で、私たちは自然とコードの構造について深く考えることになります。

- 「このメソッドは長すぎる」と感じれば、「このメソッドは複数の責任を持っているのではないか？どう分割すれば責務が明確になるか？」と考えます。（→ **メソッドの抽出**、**単一責任の原則**）
- 「このクラスは大きすぎる」と感じれば、「このクラスの責任範囲はどこまでが適切か？関連性の薄い部分を別のクラスにできないか？」と考えます。（→ **クラスの抽出**、**凝集度**、**単一責任の原則**）
- 「重複したコードがある」と感じれば、「この共通ロジックはどこに置くのが一番自然か？どうすれば再利用しやすくなるか？」と考えます。（→ **メソッドの抽出**、**親クラスの抽出**、**DRY 原則**）
- 「複雑な条件分岐がある」と感じれば、「この条件分岐の本質は何だろうか？もっとシンプルに表現できないか？状態や戦略として分離できないか？」と考えます。（→ **ガード節**、**ポリモーフィズムによる条件分岐の置き換え**、**State/Strategy パターン**）

このように、リファクタリングの各テクニックを適用しようとするとき、私たちは無意識のうちに、より**モジュール性が高く（部品化され）、凝集度が高く（関連するものがまとまり）、結合度が低く（依存関係が疎で）、理解しやすく、変更しやすい**、つまり「**より良い設計**」を目指しているのです。

リファクタリングは、最初から完璧な設計を行うのが難しいという現実に対する、実践的なアプローチでもあります。ソフトウェア開発は、常に変化する要求や新しい発見の中で進んでいきます。最初に立てた設計が、後になって最適ではないと気づくことは珍しくありません。リファクタリングによって、**設計を継続的に見直し、改善していく**ことが可能になります。

## 5.2 設計原則（SOLID など）はリファクタリングの道しるべ

では、「より良い設計」とは具体的にどのようなものでしょうか？その問いに対する指針を与えてくれるのが、「オブジェクト指向設計入門」で紹介した **SOLID 原則**のような、先人たちが体系化した**設計原則**です。

- **単一責任の原則 (SRP):** クラスやメソッドの責任を 1 つに保つ。 → 長いメソッドや巨大なクラスを分割するリファクタリングの動機となる。
- **オープン/クローズドの原則 (OCP):** 拡張には開いて、修正には閉じていなければならない。 → 条件分岐をポリモーフィズムで置き換えるなど、変更に強い構造を目指すリファクタリングの方向性を示す。
- **リスコフの置換原則 (LSP):** 子クラスは親クラスと置換可能でなければならない。 → 不適切な継承関係を見直し、修正するリファクタリングの必要性を示唆する。
- **インターフェース分離の原則 (ISP):** 不要なメソッドへの依存を強制しない。 → 大きなインターフェースを分割するリファクタリングの指針となる。
- **依存性逆転の原則 (DIP):** 抽象に依存し、具象には依存しない。 → 依存性の注入 (DI) を導入するなど、依存関係を整理するリファクタリングの方向性を示す。

これらの設計原則は、リファクタリングを行う際の「なぜこの改善が必要なのか？」「どのような状態を目指すべきなのか？」という問いに対する答えを与えてくれます。設計原則を理解していると、コードの不吉な臭いから問題の本質を見抜き、より効果的なリファクタリングを選択するための「道しるべ」となります。

## 5.3 リファクタリングによってデザインパターンが現れることも

興味深いことに、リファクタリングを進めていくと、結果的に「デザインパターン入門」で学んだような**デザインパターン**がコードの中に現れることがあります。

たとえば、

- 複雑な条件分岐を解消するためにリファクタリング（条件分岐をポリモーフィズムで置き換える）を行った結果、Strategy パターンや State パターンの構造ができ上がる。
- オブジェクトの生成ロジックを分離するためにリファクタリング（メソッドの抽出、クラスの抽出）を行った結果、Factory Method パターンや Builder パターンに近い形になる。
- サブシステムへのアクセスを単純化するためにリファクタリングを行った結果、Facade パターンが適用される。

これは、デザインパターン自体が、特定の設計問題を解決するための「実証済みの良い設計」の型であるためです。リファクタリングを通じてコードを改善していくプロセスが、自然とこれらの良い設計パターンへと収束していくことがあるのです。

このことから、デザインパターンは、リファクタリングの「目標地点」や「お手本」として機能するとも言えます。コードの不吉な臭いを感じたときに、「この問題を解決するには、〇〇パターンが適用できるかもしれない」と考え、そのパターン構造を目指してリファクタリングを進める、というアプローチも有効です。

## 5.4 良い設計を知ることが、効果的なリファクタリングにつながる（『良いコード/悪いコードで学ぶ設計入門』、『Good Code, Bad Code』参照）

結局のところ、効果的なリファクタリングを行うためには、**「何が良い設計なのか」を知っている**ことが非常に重要です。設計原則やデザインパターン、あるいは『良いコード/悪いコードで学ぶ設計入門』や『Good Code, Bad Code』といった書籍で解説されているような、変更しやすく、理解しやすく、バグを生みにくいコード構造に関する知識がなければ、どこを目指してコードを改善すればよいのか分かりません。

リファクタリングは、単なるテクニックの適用ではなく、**設計スキルそのもの**と密接に結びついています。良い設計を学ぶことは、リファクタリングの質を高めることに直結します。そして逆に、リファクタリングを実践することは、設計原則やパターンの理解を深め、設計スキルを向上させるための最良の方法の 1 つなのです。

リファクタリングを通じて、目の前のコードを改善すると同時に、より良い設計とは何かを探求し続ける姿勢を持つことが、エンジニアとしての成長に繋がります。

次の最終章では、リファクタリングを日々の習慣とし、コードと共に成長していくための心構えについてまとめます。

# 6. おわりに：リファクタリングを習慣化し、コードと共に成長する

この「リファクタリング入門」資料では、リファクタリングの基本的な考え方から、その重要性、安全な進め方、そして具体的なテクニックのいくつかを見てきました。皆さんがこれからプロフェッショナルなソフトウェアエンジニアとして歩んでいく上で、リファクタリングは非常に強力な武器となり得るスキルです。

## 6.1 リファクタリングは特別な作業ではない

まず心に留めておいていただきたいのは、リファクタリングは、特別なイベントや、問題が深刻化してから行う「大掃除」のようなものではない、ということです。もちろん、時には集中的な改善が必要になる場面もありますが、理想的には、リファクタリングは**日々のコーディング活動に織り込まれるべき、ごく自然な習慣**であるべきです。

「機能追加・修正の前に少し整える」「コードを書いた後に少しきれいにする」「レビューの指摘を反映させる」といった、日々の小さな改善の積み重ねが、コードベース全体の健全性を維持し、将来の大きな問題を未然に防ぐことに繋がります。ボーイスカウト・ルール「来たときよりもきれいにして去る」を、ぜひ皆さんの行動指針の 1 つに加えてみてください。

## 6.2 コードは「書いたら終わり」ではなく、「育てる」もの

ソフトウェアは、一度完成したら変化しない静的なものではありません。ビジネスの変化、技術の進歩、ユーザーからのフィードバックなど、さまざまな要因によって、ソフトウェアは常に進化し続ける「生き物」のような側面を持っています。

したがって、私たちが書くコードも、「一度書いたら終わり」ではなく、継続的に手を入れ、世話をし、より良く「育てていく」 対象として捉えることが大切です。リファクタリングは、まさにこの「コードを育てる」ための基本的な技術なのです。愛情を持ってコードと向き合い、その成長を見守る姿勢は、開発という仕事のやりがいにも繋がるでしょう。

## 6.3 学び続ける姿勢と、より良いコードへの探求（『リファクタリング・ウェットウェア』の考え方も参考に）

リファクタリングの技術、そしてその背景にある「良い設計」の考え方は、非常に奥深く、常に進化しています。この資料で紹介した内容は、その広大な世界への入り口にすぎません。

- **より多くのリファクタリング手法を学ぶ**  
  『リファクタリング 第 2 版』には、さらに多くの具体的なテクニックがカタログ化されています。
- **設計原則やデザインパターンへの理解を深める**  
  なぜそのリファクタリングが良いのか、どのような設計を目指すべきなのか、その根拠となる知識を深めましょう。
- **自動テストのスキルを磨く**  
  安全なリファクタリングの基盤となるテスト技術は、それ自体が重要な学習分野です。
- **コードを読む習慣をつける**  
  他の人が書いた優れたコード（あるいは改善の余地があるコード）を読むことは、多くの学びを与えてくれます。
- **経験から学ぶ**  
  実際にリファクタリングを試してみて、うまくいったこと、いかなかったことから学びを得ることが、何よりも重要です。『リファクタリング・ウェットウェア』で語られているように、知識だけでなく、経験を通じて直感や「コード感覚」を磨いていくことも大切です。

リファクタリングを習慣化し、より良いコード、より良い設計を常に探求し続ける姿勢を持つこと。それは、皆さんがエンジニアとして成長し続け、変化の激しいソフトウェア開発の世界で長く活躍していくための、もっとも確かな道の 1 つです。

この資料が、皆さんのリファクタリングへの第一歩を後押しし、コードと向き合う楽しさ、そしてそれを改善していく喜びを感じるきっかけとなれば、幸いです。
