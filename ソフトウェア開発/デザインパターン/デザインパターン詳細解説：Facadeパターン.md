---
title: デザインパターン詳細解説：Facade パターン
created: 2025-05-05 02:52:38
updated: 2025-05-07 13:52:30
draft: true
tags:
  - ソフトウェア設計
  - オブジェクト指向
  - デザインパターン
categories:
  - ソフトウェア設計
---

**目次**

- [デザインパターン詳細解説：Facade パターン](#デザインパターン詳細解説facade-パターン)
- [1. Facade パターンとは？ ～目的と解決したい問題～](#1-facade-パターンとは-目的と解決したい問題)
  - [1.1 このパターンを一言で言うと？（核心的な目的）](#11-このパターンを一言で言うと核心的な目的)
  - [1.2 なぜ Facade パターンが必要なのか？（動機と背景）](#12-なぜ-facade-パターンが必要なのか動機と背景)
    - [1.2.1 サブシステムの複雑さと利用の困難さ](#121-サブシステムの複雑さと利用の困難さ)
    - [1.2.2 クライアントとサブシステムの密結合](#122-クライアントとサブシステムの密結合)
    - [1.2.3 シンプルな利用インターフェースの必要性](#123-シンプルな利用インターフェースの必要性)
  - [1.3 このパターンで解決できること（メリットの要約）](#13-このパターンで解決できることメリットの要約)
- [2. パターンの構造と実装 ～どのように実現するか～](#2-パターンの構造と実装-どのように実現するか)
  - [2.1 登場人物とその役割（クラス図と解説）](#21-登場人物とその役割クラス図と解説)
  - [2.2 実装のポイント：隠蔽と委譲](#22-実装のポイント隠蔽と委譲)
  - [2.3 コード例：具体的なシナリオでの実装](#23-コード例具体的なシナリオでの実装)
    - [2.3.1 シナリオ設定（例：オンライン注文処理）](#231-シナリオ設定例オンライン注文処理)
    - [2.3.2 サンプルコード（Java での例）](#232-サンプルコードjava-での例)
    - [2.3.3 コードのポイント解説](#233-コードのポイント解説)
- [3. Facade パターンの利点 ～採用するメリット～](#3-facade-パターンの利点-採用するメリット)
  - [3.1 サブシステムの利用単純化](#31-サブシステムの利用単純化)
  - [3.2 クライアントとサブシステムの疎結合](#32-クライアントとサブシステムの疎結合)
  - [3.3 サブシステムの内部構造の隠蔽（カプセル化）](#33-サブシステムの内部構造の隠蔽カプセル化)
  - [3.4 システムの階層化（レイヤリング）の促進](#34-システムの階層化レイヤリングの促進)
- [4. 注意点とトレードオフ ～適用前に考えるべきこと～](#4-注意点とトレードオフ-適用前に考えるべきこと)
  - [4.1 Facade の肥大化リスク（神クラス化）](#41-facade-の肥大化リスク神クラス化)
  - [4.2 不要な抽象化・過剰設計](#42-不要な抽象化過剰設計)
  - [4.3 サブシステムへの直接アクセスの必要性](#43-サブシステムへの直接アクセスの必要性)
  - [4.4 Facade が状態を持つ場合の注意](#44-facade-が状態を持つ場合の注意)
- [5. 実装上のヒントと考慮事項 ～より良く使うために～](#5-実装上のヒントと考慮事項-より良く使うために)
  - [5.1 Facade とサブシステムのインスタンス管理](#51-facade-とサブシステムのインスタンス管理)
  - [5.2 Facade をインターフェースにするか、具象クラスにするか](#52-facade-をインターフェースにするか具象クラスにするか)
  - [5.3 エラーハンドリングと例外処理](#53-エラーハンドリングと例外処理)
  - [5.4 Facade の命名規則](#54-facade-の命名規則)
- [6. 他のパターンとの関連 ～比較と組み合わせ～](#6-他のパターンとの関連-比較と組み合わせ)
  - [6.1 似ているパターンとの比較](#61-似ているパターンとの比較)
  - [6.2 組み合わせると効果的なパターン](#62-組み合わせると効果的なパターン)
- [7. リファクタリング：いつ Facade パターンを導入するか](#7-リファクタリングいつ-facade-パターンを導入するか)
  - [7.1 導入のきっかけとなる「コードの不吉な臭い」](#71-導入のきっかけとなるコードの不吉な臭い)
  - [7.2 段階的なリファクタリング手順（概要）](#72-段階的なリファクタリング手順概要)
- [8. まとめ ～ Facade パターンの本質～](#8-まとめ--facade-パターンの本質)

# デザインパターン詳細解説：Facade パターン

# 1. Facade パターンとは？ ～目的と解決したい問題～

## 1.1 このパターンを一言で言うと？（核心的な目的）

Facade パターンは、「**複雑なサブシステム（複数のクラスやインターフェースからなる機能群）に対して、シンプルで統一された利用窓口（インターフェース）を提供する**」ためのデザインパターンです。内部の複雑さを隠蔽し、利用を容易にします。

## 1.2 なぜ Facade パターンが必要なのか？（動機と背景）

ソフトウェアシステムは、機能が増え、規模が大きくなるにつれて、内部が**多数のクラスやモジュール、サブシステム**から構成されるようになります。これらの構成要素が互いに連携しあって、システム全体の機能を実現しています。

### 1.2.1 サブシステムの複雑さと利用の困難さ

たとえば、オンライン書店の注文処理システムを考えてみましょう。ユーザーが「注文確定」ボタンを押すと、内部では「認証サブシステム」「在庫サブシステム」「決済サブシステム」「配送サブシステム」「メール通知サブシステム」といった、複数のサブシステムが連携して動作する必要があるかもしれません。

もし、この注文機能を利用するクライアント（例: Web アプリケーションの注文処理ハンドラ）が、これらの**サブシステムの内部クラスや、それらの間の複雑な連携手順をすべて知っていて、直接操作しなければならない**としたら、クライアント側のコードは非常に複雑になります。クライアントは、サブシステムの内部構造を深く理解する必要があり、実装の負担が大きくなります。

### 1.2.2 クライアントとサブシステムの密結合

クライアントがサブシステム内の多数のクラスに直接依存している状態は、**密結合**と呼ばれます。密結合な状態では、以下のような問題が生じやすくなります。

- **変更の影響波及:** サブシステムの内部実装やクラス構成が変更された場合、その変更が直接クライアントコードに影響し、クライアント側の修正が必要になる可能性が高まります。
- **保守性の低下:** サブシステムの変更がクライアントに影響を与えやすいため、サブシステム自体の改善やリファクタリングが困難になることがあります。
- **理解の困難さ:** クライアントコードを読む際に、サブシステムの詳細な知識がないと、処理の流れを理解するのが難しくなります。

### 1.2.3 シンプルな利用インターフェースの必要性

多くの場合、クライアントはサブシステムのすべての機能を必要としているわけではなく、いくつかの**典型的な利用パターン（ユースケース）**を実行できれば十分です。サブシステムの詳細な機能をすべて公開するのではなく、これらの**よく使われる機能に対して、シンプルで分かりやすい高レベルなインターフェース**を提供することで、クライアントの利便性を大幅に向上させることができます。

Facade パターンは、これらの課題、すなわち「サブシステムの複雑性」「クライアントとの密結合」「シンプルなインターフェースの欠如」を解決するために考案されました。

## 1.3 このパターンで解決できること（メリットの要約）

Facade パターンを適用することで、以下のようなメリットが期待できます。

- サブシステムの**利用を単純化**し、クライアントの実装負担を軽減する。
- クライアントとサブシステムの間の**結合度を低下**させ、疎結合な設計を実現する。
- サブシステムの**内部実装を隠蔽**し、内部変更の影響をクライアントから隔離する。
- システムを**レイヤー（層）に分割**する際の、レイヤー間のインターフェースとして機能する。

---

# 2. パターンの構造と実装 ～どのように実現するか～

Facade パターンは、その目的が「単純な窓口の提供」であるため、構造自体は非常にシンプルです。複雑なサブシステムと、それを利用するクライアントの間に、Facade という単一のクラス（またはインターフェースとその実装）を配置します。

## 2.1 登場人物とその役割（クラス図と解説）

Facade パターンの主要な登場人物は以下の通りです。

- **`Facade`（ファサード、窓口クラス）:**
  - **役割:** サブシステムへの**シンプルで統一されたインターフェース**を提供します。これがクライアントが主にやり取りする相手となります。
  - **実装:**
    - 内部に、連携する**サブシステム内のクラスへの参照**を持ちます。（これらのサブシステムオブジェクトは、Facade 自身が生成・管理する場合も、外部から注入される場合もあります）
    - クライアントからの要求（Facade のメソッド呼び出し）を受け取ります。
    - その要求を満たすために、**内部でサブシステム内の適切なクラスのメソッドを呼び出し、必要な連携処理を実行**します。サブシステムの複雑な使い方や連携手順は、この Facade クラス内にカプセル化されます。
- **サブシステムクラス群 (Subsystem classes):**
  - **役割:** 実際のビジネスロジックや機能を提供する、1 つまたは複数のクラス群です。それぞれが特定の責務を持っています。
  - **実装:** サブシステムとしての機能を実装しますが、**Facade クラスの存在を知る必要はありません**。Facade から利用されるだけで、Facade には依存しません。

```mermaid
classDiagram
    %% FacadeのシンプルなAPIのみを利用。\nサブシステムの複雑さを知らない。
    class Client
    %% シンプルなAPIを提供し、\n内部でサブシステムを呼び出す窓口
    class Facade {
        - subsystemA: SubsystemClassA
        - subsystemB: SubsystemClassB
        # other subsystems...
        %% Constructor might initialize subsystems
        + Facade()
        %% High-level interface method
        + simpleOperation1()
        %% Another high-level interface method
        + simpleOperation2()
    }
    %% 実際の機能を持つクラス群の一つ。\nFacadeのことは知らない。
    class SubsystemClassA {
        + complexOperationA1()
        + complexOperationA2()
    }
    class SubsystemClassB {
        + complexOperationB1()
    }
    class SubsystemClassC {
        + complexOperationC1()
    }
    ' ... other subsystem classes ...

    Client --> Facade : uses
    Facade --> SubsystemClassA : uses / delegates to
    Facade --> SubsystemClassB : uses / delegates to
    Facade --> SubsystemClassC : uses / delegates to
    ' Facade uses other subsystems...
```

_図: Facade パターンのクラス図_

## 2.2 実装のポイント：隠蔽と委譲

- **複雑性の隠蔽:** Facade クラスのもっとも重要な役割は、サブシステムの内部構造やクラス間の複雑な連携手順をクライアントから**隠蔽**することです。クライアントは、Facade が提供するシンプルなメソッドを呼び出すだけで、目的の機能を実行できます。
- **処理の委譲:** Facade クラス自身がすべてのロジックを持つわけではありません。クライアントからの要求に応じて、**実際の処理はサブシステム内の適切なクラスに委譲**します。Facade はあくまで「窓口」であり、「調整役」として機能します。
- **サブシステムへのアクセス:** Facade はサブシステムの利用を簡単にしますが、クライアントが **Facade を介さずにサブシステムクラスに直接アクセスすることを妨げるものではありません**。より高度な機能や細かい制御が必要な場合、クライアントは直接サブシステムを利用することも可能です。Facade はあくまで便利な「近道」を提供するものです。
- **Facade の粒度:** Facade をどの程度の粒度で作成するか（1 つの巨大な Facade か、機能ごとにある程度の Facade を設けるか）は設計判断となります。あまりに多くの責務を 1 つの Facade に持たせると、Facade 自体が「神クラス」となり、保守性を損なう可能性があります。

## 2.3 コード例：具体的なシナリオでの実装

### 2.3.1 シナリオ設定（例：オンライン注文処理）

オンラインショッピングサイトで、注文を確定する処理を考えます。この処理には、「在庫確認 (InventorySystem)」、「支払い処理 (PaymentSystem)」、「配送手配 (ShippingSystem)」という 3 つのサブシステムが関わるとします。クライアント（Web アプリケーションなど）は、これらのサブシステム連携を意識せずに、簡単に注文処理を行えるようにしたいとします。

### 2.3.2 サンプルコード（Java での例）

```java
// --- サブシステムクラス群 ---
class InventorySystem {
    public boolean checkStock(String productId, int quantity) {
        System.out.println("在庫確認: 商品 " + productId + ", 数量 " + quantity);
        // ... 実際の在庫確認ロジック ...
        return true; // 簡単のため常に在庫ありとする
    }
    public void decreaseStock(String productId, int quantity) {
        System.out.println("在庫引当: 商品 " + productId + ", 数量 " + quantity);
        // ... 実際の在庫引当ロジック ...
    }
}

class PaymentSystem {
    public boolean processPayment(String userId, double amount) {
        System.out.println("支払い処理: ユーザー " + userId + ", 金額 " + amount);
        // ... 実際の決済ロジック ...
        return true; // 簡単のため常に成功とする
    }
}

class ShippingSystem {
    public void arrangeShipping(String userId, String address, String orderId) {
        System.out.println("配送手配: ユーザー " + userId + ", 住所 " + address + ", 注文ID " + orderId);
        // ... 実際の配送手配ロジック ...
    }
}

// --- Facade クラス ---
class OrderProcessingFacade {
    // Facade はサブシステムへの参照を持つ
    private InventorySystem inventory;
    private PaymentSystem payment;
    private ShippingSystem shipping;

    // サブシステムのインスタンスを生成または注入
    public OrderProcessingFacade() {
        this.inventory = new InventorySystem();
        this.payment = new PaymentSystem();
        this.shipping = new ShippingSystem();
    }
     // DIコンテナを使う場合はコンストラクタで注入する方が良い
    // public OrderProcessingFacade(InventorySystem inv, PaymentSystem pay, ShippingSystem ship) {
    //     this.inventory = inv; this.payment = pay; this.shipping = ship;
    // }

    // シンプルな注文処理インターフェースを提供
    public boolean placeOrder(String userId, String productId, int quantity, double amount, String shippingAddress) {
        System.out.println("\n--- 注文処理開始 (Facade経由) ---");
        boolean success = true;

        // 1. 在庫確認 (InventorySystem を利用)
        if (!inventory.checkStock(productId, quantity)) {
            System.out.println("エラー: 在庫がありません。");
            success = false;
        } else {
            // 2. 支払い処理 (PaymentSystem を利用)
            if (!payment.processPayment(userId, amount)) {
                System.out.println("エラー: 支払い処理に失敗しました。");
                success = false;
            } else {
                // 3. 在庫引当 (InventorySystem を利用)
                inventory.decreaseStock(productId, quantity);
                // 4. 配送手配 (ShippingSystem を利用)
                String orderId = "ORD-" + System.currentTimeMillis(); // 簡単な注文ID生成
                shipping.arrangeShipping(userId, shippingAddress, orderId);
            }
        }

        if (success) {
            System.out.println("--- 注文処理成功 (Facade経由) ---");
        } else {
             System.out.println("--- 注文処理失敗 (Facade経由) ---");
        }
        return success;
    }
}

// --- Client (利用側) ---
public class FacadeClient {
    public static void main(String[] args) {
        // Client は Facade オブジェクトを生成するだけ
        OrderProcessingFacade facade = new OrderProcessingFacade();

        // Facade が提供するシンプルなメソッドを呼び出す
        boolean result = facade.placeOrder("user123", "prodABC", 2, 5000.0, "東京都...");

        if (result) {
            System.out.println("\nクライアント: 注文が正常に完了しました。");
        } else {
            System.out.println("\nクライアント: 注文処理中に問題が発生しました。");
        }

        // Client は InventorySystem, PaymentSystem, ShippingSystem の
        // 存在や連携手順を全く意識する必要がない。
    }
}
```

### 2.3.3 コードのポイント解説

- `InventorySystem`, `PaymentSystem`, `ShippingSystem` が、それぞれ独立した機能を提供するサブシステムクラスです。
- `OrderProcessingFacade` クラスが Facade として機能します。内部に各サブシステムへの参照を持ちます。
- `placeOrder` メソッドが、クライアントに提供されるシンプルなインターフェースです。このメソッド内部で、在庫確認、支払い、在庫引当、配送手配というサブシステム間の複雑な連携処理がカプセル化されています。
- クライアント (`FacadeClient`) は `OrderProcessingFacade` の `placeOrder` メソッドを呼び出すだけで、サブシステムの詳細を知る必要がありません。

このように、Facade パターンはサブシステムの利用を劇的に単純化し、クライアントとサブシステムの間の結合度を効果的に下げることができます。

---

# 3. Facade パターンの利点 ～採用するメリット～

Facade パターンを導入することは、とくに複雑なサブシステムやライブラリを扱う際に、多くの設計上のメリットをもたらします。

## 3.1 サブシステムの利用単純化

これが Facade パターンのもっとも直接的で大きなメリットです。クライアント（利用者）は、サブシステムの内部構造や、多数のクラス・メソッド、それらの複雑な連携手順を理解する必要がなくなります。

Facade が提供する**シンプルで高レベルなインターフェース（窓口メソッド）**を呼び出すだけで、サブシステムの主要な機能を利用できるようになります。これにより、クライアント側の**実装負担が大幅に軽減**され、開発者はサブシステムの詳細ではなく、クライアント自身の本来のロジックに集中できます。

## 3.2 クライアントとサブシステムの疎結合

Facade パターンは、クライアントとサブシステムの間の**結合度を効果的に低下**させます。クライアントは Facade クラス（またはインターフェース）にのみ依存し、サブシステム内の個々のクラスには直接依存しなくなります（あるいは依存度を大幅に減らせます）。

これにより、**サブシステムの内部実装が変更されても、Facade のインターフェースが変わらない限り、クライアントコードへの影響を最小限に抑える**ことができます。たとえば、サブシステム内で使用しているクラス構成が変わったり、連携方法が変更されたりしても、Facade がその変更を吸収してくれるため、クライアント側は修正不要となる場合が多いです。これは、システムの**保守性**を大きく向上させます。

## 3.3 サブシステムの内部構造の隠蔽（カプセル化）

Facade は、サブシステムの内部構造をクライアントから**隠蔽 (カプセル化)** する役割を果たします。クライアントは、サブシステムがどのように構成され、どのように動作しているかの詳細を知る必要がありません。

これにより、サブシステムの開発者は、クライアントへの影響を過度に心配することなく、**内部実装の改善やリファクタリングを自由に行いやすく**なります。インターフェース（Facade）を安定させておけば、内部は柔軟に変更できるのです。

## 3.4 システムの階層化（レイヤリング）の促進

ソフトウェアシステム全体を、いくつかの**レイヤー (層)** に分割して設計する場合、Facade パターンはレイヤー間のインターフェースとして非常に有効です。

各レイヤー（例: プレゼンテーション層、ビジネスロジック層、データアクセス層）が、自身の機能を利用するための Facade を提供することで、**レイヤー間の依存関係を Facade に限定**できます。これにより、各レイヤーの独立性が高まり、システム全体の構造が整理され、見通しが良くなります。あるレイヤーの内部変更が、他のレイヤーに波及しにくくなります。

これらのメリットにより、Facade パターンは、複雑なシステムをより扱いやすく、変更に強く、保守しやすいものにするための、非常に実用的で価値の高いデザインパターンと言えます。

---

# 4. 注意点とトレードオフ ～適用前に考えるべきこと～

Facade パターンはシンプルで強力ですが、適用する際にはいくつかの注意点や考慮すべきトレードオフがあります。これらを理解せずに適用すると、期待した効果が得られなかったり、新たな問題を引き起こしたりする可能性もあります。

## 4.1 Facade の肥大化リスク（神クラス化）

Facade パターンを適用する上でもっとも注意すべき点の 1 つが、**Facade クラス自身が巨大で複雑になってしまう**リスクです。「サブシステムの窓口」として多くの機能を提供しようとしすぎると、Facade クラスがサブシステムのあらゆる処理の知識を持ち、非常に多くのメソッドを抱える「**神クラス (God Class)**」になってしまう可能性があります。

神クラス化した Facade は、それ自体が**単一責任の原則 (SRP)** に反し、**理解や修正が困難**になり、結局は保守性を低下させる原因となりかねません。

**対策:**

- Facade が提供するインターフェースは、**よく使われる典型的なユースケースに絞り込む**ことを意識します。
- サブシステムの機能領域が広い場合は、**単一の巨大な Facade ではなく、より小さな、特定の関心事に特化した複数の Facade に分割**することを検討します。
- Facade はあくまで「窓口」であり、複雑なビジネスロジックはサブシステム内の適切なクラスに**委譲**することを徹底します。

## 4.2 不要な抽象化・過剰設計

サブシステム自体が非常にシンプルで、クラス数も少なく、クライアントからの利用方法も単純な場合に Facade パターンを導入すると、**単に間接層を一つ増やすだけ**となり、かえって**設計が複雑になる**可能性があります。

パターンはあくまで問題を解決するための手段です。解決すべき明確な問題（複雑性の隠蔽、疎結合化など）が存在しない場合にまで、パターンを適用する必要はありません。**シンプルさが保てるのであれば、Facade を導入しない方が良い**場合もあります。

## 4.3 サブシステムへの直接アクセスの必要性

Facade はサブシステムの利用を単純化しますが、クライアントによっては Facade が提供する高レベルなインターフェースだけでは不十分で、サブシステムが持つ**より低レベルな機能や、細かい制御**を行いたい場合があります。

Facade パターンは、原則として**サブシステムへの直接アクセスを禁止するものではありません**。設計によっては、Facade を提供しつつも、クライアントが直接サブシステムクラスを利用するパスも残しておくことが可能です。

ただし、直接アクセスを許可するかどうか、許可する場合にどの範囲までを許容するかは、システムの設計方針やカプセル化の度合いに応じて慎重に決定する必要があります。無制限な直接アクセスは、Facade を導入したメリット（疎結合など）を損なう可能性もあります。

## 4.4 Facade が状態を持つ場合の注意

通常、Facade オブジェクト自体は状態を持たず（ステートレス）、単に要求をサブシステムに委譲するだけのことが多いです。しかし、場合によっては Facade が何らかの状態（たとえば、設定情報やセッション情報など）を持つことも考えられます。

Facade が状態を持つ場合、とくに複数のクライアントから共有されるような状況では、スレッドセーフティなどの**並行性に関する問題**に注意が必要になる場合があります。

これらの注意点を理解し、Facade パターンを適用するメリットが、導入に伴うコストや潜在的な問題を上回るかを評価することが重要です。

---

# 5. 実装上のヒントと考慮事項 ～より良く使うために～

Facade パターンを実装する際に、いくつかのヒントや考慮事項を知っておくと、より効果的で洗練された設計にできます。

## 5.1 Facade とサブシステムのインスタンス管理

`Facade` クラスは、内部で利用するサブシステムクラスのインスタンスへの参照を持つ必要があります。これらのサブシステムインスタンスをどのように生成・管理するかは、いくつかの選択肢があります。

- **Facade 内部での生成:**
  ```java
  public class OrderProcessingFacade {
      private InventorySystem inventory = new InventorySystem();
      private PaymentSystem payment = new PaymentSystem();
      // ...
  }
  ```
  もっとも単純な方法ですが、`Facade` とサブシステムの具象クラスが密結合になります。サブシステムのクラスを差し替える（たとえばテストダブルを使う）のが難しくなります。
- **コンストラクタでの注入 (Dependency Injection):**
  ```java
  public class OrderProcessingFacade {
      private final InventorySystem inventory;
      private final PaymentSystem payment;
      // ...
      public OrderProcessingFacade(InventorySystem inv, PaymentSystem pay, /*...*/) {
          this.inventory = inv;
          this.payment = pay;
          // ...
      }
  }
  ```
  外部（クライアントや DI コンテナ）からサブシステムのインスタンスを注入する方式です。**テスト容易性が大幅に向上**し、サブシステムの実装を柔軟に切り替えられるため、**一般的に推奨される方法**です。依存するサブシステムはインターフェースとして定義するのが理想的です。
- **Service Locator パターンの利用 (注意が必要):**
  `Facade` が内部で Service Locator（サービス（サブシステム）の場所を知っているオブジェクト）に問い合わせて、必要なサブシステムのインスタンスを取得する方法。DI に比べて、依存関係がコード上で見えにくくなるなどの欠点も指摘されており、DI の方が好まれる傾向にあります。

どの方法を選択するかは、システムの規模、テスト容易性の要求度、DI コンテナの利用有無などによって判断します。

## 5.2 Facade をインターフェースにするか、具象クラスにするか

`Facade` 自体をインターフェースとして定義し、その実装クラスを作成することも考えられます。

```mermaid
classDiagram
    class Client
    class IFacade {
        <<interface>>
        + simpleOperation1()
        + simpleOperation2()
    }
    class ConcreteFacade {
        - subsystemA: SubsystemClassA
        // ...
        + simpleOperation1()
        + simpleOperation2()
    }
    class SubsystemClassA { /* ... */ }
    // ... other subsystems ...

    Client --> IFacade : uses
    ConcreteFacade ..|> IFacade : implements
    ConcreteFacade --> SubsystemClassA : uses
    // ...
```

**インターフェースにする利点:**

- クライアントは具象クラスではなくインターフェースに依存するため、Facade の実装を（たとえばテスト用に）差し替えることが可能になります。
- 複数の異なる Facade 実装（たとえば、本番用とスタブ用）を提供しやすくなります。

**具象クラスのままでも良い場合:**

- Facade の実装が 1 種類しかなく、差し替える必要性が低い場合。
- サブシステムのインスタンス生成を Facade 内部で行うシンプルな構成の場合。

インターフェースを導入すると抽象度が上がりますが、クラス数も増えます。必要性がなければ、具象クラスのままでも十分な場合が多いです。

## 5.3 エラーハンドリングと例外処理

`Facade` はサブシステム間の連携を行うため、サブシステムから発生する可能性のあるエラーや例外をどのように処理し、クライアントにどのように伝えるかを設計する必要があります。

- **Facade で集約・変換:** 各サブシステムがスローする可能性のあるさまざまな種類の例外を Facade でキャッチし、クライアントにとってより分かりやすい、抽象化された独自の例外に変換して再スローする。
- **そのまま伝搬:** サブシステムからの例外をそのままクライアントに伝搬させる（ただし、クライアントがサブシステムの例外を知る必要が出てくる）。
- **戻り値で通知:** 処理の成否やエラーコードを Facade メソッドの戻り値として返す。

どの方法が良いかは、アプリケーションのエラーハンドリング方針によりますが、Facade がサブシステムの詳細を隠蔽するという目的を考えると、例外を集約・変換する方法がしばしば有効です。

## 5.4 Facade の命名規則

Facade クラスの名前は、それが「何に対する窓口」なのかが明確にわかるように命名するのが良いでしょう。一般的には `〇〇Facade`、`〇〇Service`、`〇〇Manager` といった名前が使われることが多いです。

これらの実装上のヒントを考慮することで、Facade パターンをより効果的に設計・実装できます。

---

# 6. 他のパターンとの関連 ～比較と組み合わせ～

Facade パターンは、他のデザインパターンと比較されたり、連携して使われたりすることで、その役割や適用範囲がより明確になります。

## 6.1 似ているパターンとの比較

Facade パターンと目的や構造が似ている、あるいは比較されることのあるパターンについて見ていきましょう。

- **Adapter パターン:**
  - **違い:** Adapter は、**互換性のないインターフェース間**を接続し、**適合させる**ことを目的とします。既存のクラスのインターフェースを、クライアントが期待する別のインターフェースに変換します。一方、Facade は既存のサブシステムのインターフェースを**単純化・統一化**することを目的とします。インターフェースの変換が主目的ではありません。
- **Mediator パターン:**
  - **違い:** Mediator は、**複数のオブジェクト（Colleague）間の複雑な相互作用（コミュニケーション）を一手に引き受け、仲介する**ことを目的とします。これにより、Colleague 同士の直接的な依存関係をなくします。一方、Facade は、クライアントからサブシステムへの**一方向のシンプルなインターフェース**を提供することに焦点を当てます。サブシステム内のオブジェクト間の相互作用を仲介することが主目的ではありません。（ただし、Facade が内部で Mediator のような役割を一部担うことも考えられます。）
- **Abstract Factory パターン:**
  - **違い:** Abstract Factory は、**関連するオブジェクトのファミリーを生成するためのインターフェース**を提供することに焦点を当てます。オブジェクトの「生成」が目的です。Facade は既存のオブジェクト（サブシステム）の「利用」を単純化することが目的です。
  - **連携:** Facade が、特定のサブシステム群（たとえば、特定の OS や DB に依存するクラス群）を利用する場合、そのサブシステム群の生成を Abstract Factory に任せ、Facade はその Factory から取得したオブジェクトを利用する、という組み合わせは考えられます。

## 6.2 組み合わせると効果的なパターン

Facade パターンは、他のパターンと効果的に組み合わせることができます。

- **Singleton パターン:**
  - **連携:** サブシステム全体で唯一のアクセスポイント（窓口）を提供したい場合、Facade クラスを Singleton として実装することがあります。これにより、Facade のインスタンスが 1 つだけ存在することを保証できます。ただし、Singleton パターンの利用には注意点（テスト容易性の低下など）もあるため、慎重に検討する必要があります。
- **Abstract Factory パターン / Factory Method パターン:**
  - **連携:** Facade が内部で利用するサブシステムオブジェクトの生成を、直接 `new` するのではなく、Factory パターン（Abstract Factory や Factory Method）に委譲できます。これにより、Facade が依存する具体的なサブシステムクラスを、Factory の実装を切り替えることで柔軟に変更できるようになります。
- **Dependency Injection (DI) コンテナ:**
  - **連携:** 現代的な開発では、Facade が依存するサブシステムオブジェクトの生成と注入を、DI コンテナに管理させることが一般的です。Facade クラスはコンストラクタなどで必要なサブシステム（のインターフェース）を受け取るように設計し、DI コンテナが適切なインスタンスを注入します。これにより、Facade とサブシステムの結合度がさらに低下し、テスト容易性が向上します。

これらのパターンとの関係性を理解することで、Facade パターンをより大きな設計コンテキストの中で適切に位置づけ、他のパターンと組み合わせてより強力なソリューションを構築できます。

---

# 7. リファクタリング：いつ Facade パターンを導入するか

Facade パターンは、システムの初期設計段階から導入されることもありますが、開発が進むにつれてシステムの複雑さが増し、既存コードの保守性や理解しやすさに問題が出てきた際に、**リファクタリング**によって導入することも非常に有効です。

## 7.1 導入のきっかけとなる「コードの不吉な臭い」

既存のコードベースに以下のような兆候（コードの不吉な臭い）が見られた場合、Facade パターンの導入を検討する良い機会となります。

- **クライアントとサブシステムの密結合:**
  - **症状:** クライアントコードが、ある機能を実現するために、**多数のサブシステムクラスを直接**知り、それらを**複雑な順序で呼び出して**いる。クライアントコードのあちこちに、サブシステムとの連携ロジックが分散している。
  - **問題:** クライアントがサブシステムの内部構造に過度に依存しています。サブシステムの変更が直接クライアントに影響し、修正コストが増大します。クライアントコードの本来の責務が見えにくくなります。
  - **解決策:** Facade パターンを導入し、クライアントとサブシステムの間にシンプルな窓口を設けます。クライアントは Facade にのみ依存するように変更し、サブシステムとの複雑な連携ロジックは Facade 内部に移動させます。
- **サブシステムの利用の難しさ:**
  - **症状:** サブシステムを利用するための手順が複雑で、多くのクラスやメソッドを正しい順序で呼び出す必要があり、利用方法を習得するのが難しい。あるいは、よく使われる一連の操作が定型的なのに、毎回クライアント側でその手順を記述する必要がある。
  - **問題:** サブシステムの利用効率が悪く、開発者の負担が大きくなります。誤った使い方によるバグも発生しやすくなります。
  - **解決策:** Facade パターンを導入し、よく使われる利用パターンや定型的な操作シーケンスを、シンプルなメソッドとして Facade に提供します。クライアントは Facade のメソッドを呼び出すだけで、簡単にサブシステムを利用できるようになります。
- **レイヤー間の不適切な依存:**
  - **症状:** レイヤードアーキテクチャを採用しているシステムで、上位レイヤー（例: プレゼンテーション層）が、下位レイヤー（例: データアクセス層）の**内部的なクラスにまで直接アクセス**してしまっている。
  - **問題:** レイヤー間の境界が曖昧になり、各レイヤーの独立性が損なわれ、変更の影響がレイヤーを越えて波及しやすくなります。
  - **解決策:** 各レイヤーが他のレイヤーに公開するためのインターフェースとして Facade を導入します。レイヤー間のやり取りは、原則として Facade を通じてのみ行うように制限することで、レイヤー間の結合度を下げ、構造を明確にします。

これらの「臭い」は、システムの構造が複雑化し、モジュール間の結合度が高くなっているサインです。Facade パターンは、このような状況を改善するための有効なリファクタリング手法となり得ます。

## 7.2 段階的なリファクタリング手順（概要）

既存のコードに Facade パターンを導入する際の、大まかなリファクタリング手順は以下のようになります。（テストによる安全確保が前提です）

1. **Facade インターフェースの特定:**
   - クライアントがサブシステムを利用する際の、**主要なユースケースや典型的な操作シーケンス**を特定します。これらが Facade が提供すべきシンプルなインターフェース（メソッド）の候補となります。
   - サブシステムのどの部分を Facade で隠蔽し、どの部分は（必要であれば）直接アクセスの余地を残すかを決定します。
2. **Facade クラスの作成:**
   - 特定したインターフェースを持つ新しい `Facade` クラスを作成します。
3. **サブシステムへの参照の追加:**
   - `Facade` クラス内に、連携する必要のあるサブシステムクラスへの参照（フィールド）を追加します。これらのサブシステムインスタンスをどのように取得するか（内部生成か注入か）も決定します。（DI が推奨されます）
4. **連携ロジックの移動:**
   - クライアントコード内に分散していた、サブシステムとの複雑な連携ロジック（メソッド呼び出しの順序、データの準備など）を、**`Facade` クラスの対応するメソッド内に移動 (またはコピー)** します。
5. **クライアントコードの修正:**
   - クライアントコードがサブシステムクラスを直接呼び出していた箇所を修正し、代わりに**作成した `Facade` クラスのメソッドを呼び出す**ように変更します。クライアントは `Facade` クラス（またはそのインターフェース）のみに依存するようにします。
6. **テスト:** 各ステップの後、および最終的に、テストを実行してリファクタリングによって外部から見た振る舞いが変わっていないこと、そしてクライアントコードが Facade を通じて正しく機能することを確認します。

このリファクタリングにより、クライアントコードは大幅に単純化され、サブシステムの複雑さから隔離されます。また、サブシステム自体の内部変更も行いやすくなります。

---

# 8. まとめ ～ Facade パターンの本質～

**Facade パターン**は、**複雑なサブシステム（多くのクラスやインターフェースからなる機能の集まり）に対して、シンプルで高レベルな、統一された利用インターフェース（窓口）を提供する**構造に関するデザインパターンです。

このパターンを適用することで、

- サブシステムの**利用方法が大幅に単純化**され、クライアントの実装負担が軽減される。
- クライアントとサブシステムの間の**結合度が低下**し、疎結合な設計が促進される。
- サブシステムの**内部構造や複雑さが隠蔽**され、内部変更がクライアントに影響しにくくなる。
- システムを**レイヤー（層）に分割**する際の、明確な境界とインターフェースを提供できる。

といった、ソフトウェアの**保守性、拡張性、理解しやすさ**を高める上で重要なメリットが得られます。

その本質は、「**複雑さの隠蔽**」と「**シンプルな窓口の提供**」にあります。多くの部品や手順が必要な処理であっても、Facade という「玄関」を通れば、利用者は簡単なリクエストだけで目的を達成できるようにする、という考え方です。Facade は内部で必要な処理を適切に**委譲**し、調整する役割を果たします。

ただし、Facade 自体が多くの責務を抱え込み**肥大化**しないように注意が必要です。また、サブシステムが単純な場合には**過剰設計**になる可能性もあります。Facade はサブシステム利用の便利な「近道」を提供するものであり、必要に応じてクライアントがサブシステムに**直接アクセスする余地**を残す設計も考慮されます。

Facade パターンは、ライブラリやフレームワークの利用時、あるいは自身が大規模なシステムを設計・リファクタリングする際に、複雑さを管理し、より扱いやすい構造を作り出すための、非常に実用的で効果的なパターンです。この「シンプルな窓口」という考え方を理解し活用することで、よりクリーンで保守性の高いソフトウェア設計を目指しましょう。
