---
title: ソフトウェア設計：デザインパターン入門
created: 2025-04-28 14:38:59
updated: 2025-05-06 09:06:47
draft: false
tags:
  - ソフトウェア設計
  - オブジェクト指向
  - デザインパターン
categories:
  - ソフトウェア設計
---

**目次**

- [ソフトウェア設計：デザインパターン入門 ～定石を知り、設計力を高める～](#ソフトウェア設計デザインパターン入門-定石を知り設計力を高める)
- [1. はじめに：なぜデザインパターンを学ぶのか？](#1-はじめになぜデザインパターンを学ぶのか)
  - [1.1 ソフトウェア設計における「よくある悩み」](#11-ソフトウェア設計におけるよくある悩み)
  - [1.2 デザインパターン：課題解決の「定石」を知る](#12-デザインパターン課題解決の定石を知る)
  - [1.3 学ぶことのメリット：設計力・コミュニケーション力・読解力の向上](#13-学ぶことのメリット設計力コミュニケーション力読解力の向上)
  - [1.4 この資料と「詳細解説」の位置づけ：学びのステップ](#14-この資料と詳細解説の位置づけ学びのステップ)
- [2. デザインパターンとは何か？ ～全体像をつかむ～](#2-デザインパターンとは何か-全体像をつかむ)
  - [2.1 パターンの構成要素（名前、問題、解決策、結果など）](#21-パターンの構成要素名前問題解決策結果など)
  - [2.2 パターンの分類：目的と重要度による整理](#22-パターンの分類目的と重要度による整理)
    - [2.2.1 GoF による 3 つの分類：生成・構造・振る舞い](#221-gof-による-3-つの分類生成構造振る舞い)
    - [2.2.2 実践的な分類：Core, Creation, Peripheral, Other](#222-実践的な分類core-creation-peripheral-other)
    - [2.2.3 なぜ分類を知ることが役立つのか？](#223-なぜ分類を知ることが役立つのか)
- [3. デザインパターンを学ぶ上での心構えとヒント](#3-デザインパターンを学ぶ上での心構えとヒント)
  - [3.1 パターンは「銀の弾丸」ではない：適用する目的を見失わない](#31-パターンは銀の弾丸ではない適用する目的を見失わない)
  - [3.2 シンプルさを忘れずに：パターン中毒を避ける (YAGNI, KISS)](#32-シンプルさを忘れずにパターン中毒を避ける-yagni-kiss)
  - [3.3 「問題」からパターンを探す視点：解決したい課題は何か？](#33-問題からパターンを探す視点解決したい課題は何か)
  - [3.4 パターン選択の難しさ：比較検討とトレードオフの理解](#34-パターン選択の難しさ比較検討とトレードオフの理解)
  - [3.5 チームでの共通言語としての活用と注意点](#35-チームでの共通言語としての活用と注意点)
  - [3.6 実践とリファクタリングを通じた習得](#36-実践とリファクタリングを通じた習得)
- [4. 代表的なパターン紹介：どんな問題を解決するのか？](#4-代表的なパターン紹介どんな問題を解決するのか)
  - [【Core パターン編】](#core-パターン編)
    - [4.1 \[振る舞い\] アルゴリズムを交換可能にしたい (Strategy パターン)](#41-振る舞い-アルゴリズムを交換可能にしたい-strategy-パターン)
    - [4.2 \[振る舞い\] 処理の骨組みを固定し、一部だけ変えたい (Template Method パターン)](#42-振る舞い-処理の骨組みを固定し一部だけ変えたい-template-method-パターン)
    - [4.3 \[振る舞い\] コレクションの中身を隠してアクセスしたい (Iterator パターン)](#43-振る舞い-コレクションの中身を隠してアクセスしたい-iterator-パターン)
    - [4.4 \[構造\] 「部分」と「全体」を同じように扱いたい (Composite パターン)](#44-構造-部分と全体を同じように扱いたい-composite-パターン)
    - [4.5 \[構造\] 複雑なシステムを簡単な窓口で使いたい (Facade パターン)](#45-構造-複雑なシステムを簡単な窓口で使いたい-facade-パターン)
    - [4.6 \[構造\] オブジェクトへのアクセスを制御したい (Proxy パターン)](#46-構造-オブジェクトへのアクセスを制御したい-proxy-パターン)
    - [4.7 \[振る舞い\] オブジェクトの状態に応じて振る舞いを変えたい (State パターン)](#47-振る舞い-オブジェクトの状態に応じて振る舞いを変えたい-state-パターン)
    - [4.8 \[振る舞い\] 操作をオブジェクトとして扱いたい (Command パターン)](#48-振る舞い-操作をオブジェクトとして扱いたい-command-パターン)
  - [【Creation パターン編】](#creation-パターン編)
    - [4.9 \[生成\] どのクラスを作るか、サブクラスに任せたい (Factory Method パターン)](#49-生成-どのクラスを作るかサブクラスに任せたい-factory-method-パターン)
    - [4.10 \[生成\] 複雑なオブジェクトを段階的に作りたい (Builder パターン)](#410-生成-複雑なオブジェクトを段階的に作りたい-builder-パターン)
    - [4.11 \[生成\] コピーしてオブジェクトを作りたい (Prototype パターン)](#411-生成-コピーしてオブジェクトを作りたい-prototype-パターン)
    - [4.12 \[原則\] 依存関係を疎にしてテストしやすくしたい (Dependency Injection: DI)](#412-原則-依存関係を疎にしてテストしやすくしたい-dependency-injection-di)
  - [【Peripheral パターン編（一部紹介）】](#peripheral-パターン編一部紹介)
    - [4.13 \[構造\] 動的に機能を追加したい (Decorator パターン)](#413-構造-動的に機能を追加したい-decorator-パターン)
    - [4.14 \[振る舞い\] オブジェクト間の複雑なやりとりを仲介したい (Mediator パターン)](#414-振る舞い-オブジェクト間の複雑なやりとりを仲介したい-mediator-パターン)
    - [4.15 \[その他\] オブジェクトの「種類」をデータとして扱いたい (Type Object パターン)](#415-その他-オブジェクトの種類をデータとして扱いたい-type-object-パターン)
    - [4.16 \[その他\] 「何もない」ことをオブジェクトで表現したい (Null Object パターン)](#416-その他-何もないことをオブジェクトで表現したい-null-object-パターン)
- [5. おわりに：デザインパターンの学習を続けよう](#5-おわりにデザインパターンの学習を続けよう)
  - [5.1 設計の「引き出し」を増やすことの価値](#51-設計の引き出しを増やすことの価値)
  - [5.2 詳細解説資料や参考文献へ](#52-詳細解説資料や参考文献へ)
  - [5.3 継続的な学習と実践の勧め](#53-継続的な学習と実践の勧め)

# ソフトウェア設計：デザインパターン入門 ～定石を知り、設計力を高める～

# 1. はじめに：なぜデザインパターンを学ぶのか？

ソフトウェア開発の世界へようこそ。皆さんはオブジェクト指向設計の基礎を学び、クラスやオブジェクトを使ってソフトウェアの構造を組み立てることに挑戦していることでしょう。日々の開発業務において、コードを書き進める中で、ふと立ち止まってしまうような設計上の課題に直面することはありませんか？

## 1.1 ソフトウェア設計における「よくある悩み」

たとえば、こんな悩みや疑問を感じたことはないでしょうか。

- 「機能を追加したいけれど、既存のコードをたくさん修正しないといけなさそうだ…もっと**変更に強く**できないかな？」
- 「このクラス、なんだか色々なことをやりすぎていて**複雑**だ。どう分割すれば分かりやすくなるだろう？」
- 「似たような処理が複数の場所にある。これを**うまく共通化**して、コードをすっきりさせたい。」
- 「オブジェクト同士が直接やり取りしすぎていて、**依存関係**が絡み合っている気がする。もっとシンプルに連携できないか？」
- 「このオブジェクト、作るのが少し**面倒**だ。もっと簡単に、そして安全に生成する方法はないだろうか？」

これらは、特定のプロジェクトやプログラミング言語に限らず、オブジェクト指向でソフトウェアを構築しようとするときに、多くの開発者が経験する可能性のある、いわば「**よくある悩み**」です。ソフトウェアが成長し、複雑になるにつれて、これらの課題はより顕著になってきます。

## 1.2 デザインパターン：課題解決の「定石」を知る

幸いなことに、ソフトウェア開発の長い歴史の中で、私たちの先輩にあたる多くのエンジニアたちが同じような課題に繰り返し取り組み、試行錯誤を重ねてきました。そして、その中で、特定の状況下で繰り返し発生する「典型的な問題」に対して、**効果的で再利用可能な「解決策の型」**が見出されてきました。

これが「**デザインパターン**」と呼ばれるものです。

デザインパターンは、特定のアルゴリズムや完成されたコードそのものではありません。それは、設計上の問題を解決するための**考え方、構造、そしてオブジェクト間の関係性を示した「設計の青写真」や「定石（じょうせき）」**のようなものです。ちょうど、将棋や囲碁に定石があるように、ソフトウェア設計にも、特定の状況で有効とされる「型」が存在するのです。

この概念を体系化し、広く普及させたのが、エーリヒ・ガンマ、リチャード・ヘルム、ラルフ・ジョンソン、ジョン・ブリシディースの 4 人（通称 **Gang of Four, GoF**）です。彼らの著書『オブジェクト指向における再利用のためのデザインパターン 改訂版』では、当時発見されていた 23 の基本的なパターンが整理・解説されており、今日のデザインパターンの議論の基礎となっています。

デザインパターンを学ぶことは、ゼロから独力で解決策を模索するのではなく、**先人たちが積み重ねてきた知恵と経験（実績のある解決策）**を借りて、より効率的に、そしてより質の高い設計を行うための、強力なアプローチと言えます。

## 1.3 学ぶことのメリット：設計力・コミュニケーション力・読解力の向上

デザインパターンを学ぶことには、皆さんのエンジニアとしての成長に繋がる、具体的なメリットがたくさんあります。

- **設計力の向上**  
  デザインパターンは、再利用性、保守性、拡張性といった「良い設計」の特性を備えた構造を提供します。パターンを知ることで、より洗練された、変更に強く、理解しやすいソフトウェアを設計するための「引き出し」が増えます。
- **コミュニケーション力の向上**  
  各デザインパターンには固有の名前が付いています（例: Strategy, Factory Method）。これにより、チームメンバー間で設計について議論する際に、「ここは Strategy パターンで実装しよう」のように、**共通言語**を使ってアイデアを簡潔かつ正確に伝え合うことができます。認識のずれを防ぎ、円滑なコミュニケーションを促進します。
- **コード読解力の向上**  
  デザインパターンの知識は、他の人が書いたコードや、フレームワーク、ライブラリのソースコードを読む際にも役立ちます。コードの中に適用されているパターンを見抜くことができれば、「なぜこのような構造になっているのか」「どのような意図で設計されたのか」を素早く理解する助けになります。

## 1.4 この資料と「詳細解説」の位置づけ：学びのステップ

この「デザインパターン入門」資料は、皆さんがデザインパターンという広大な世界への第一歩を踏み出すための**入門編**として位置づけられています。目的は、デザインパターンとは何か、なぜ重要なのか、どのような種類があるのか、そして代表的なパターンが解決しようとする問題の概要を理解することです。

各パターンの詳細な解説（構造、実装例、利点・注意点、他のパターンとの関連など）については、この入門資料とは別に、「**デザインパターン詳細解説：〇〇パターン**」という形式で、パターンごとに独立した資料を用意する構成になっています。

まずはこの入門資料で全体像を掴み、興味を持ったパターンや、実際の開発で直面している課題に関連しそうなパターンについて、対応する「詳細解説」資料を読み進めていく、というステップで学習を進めることをオススメします。

次の章では、デザインパターンの全体像をより詳しく理解するために、パターンの構成要素や分類について見ていきましょう。

---

# 2. デザインパターンとは何か？ ～全体像をつかむ～

前の章では、デザインパターンがソフトウェア設計における「よくある悩み」に対する「定石」であり、学ぶことに多くのメリットがあることを見ました。この章では、デザインパターンというものが、具体的にどのような要素で構成され、どのように分類されるのか、その全体像をより詳しく見ていきましょう。

## 2.1 パターンの構成要素（名前、問題、解決策、結果など）

GoF の書籍『オブジェクト指向における再利用のためのデザインパターン 改訂版』では、各デザインパターンを説明するために、標準的なフォーマットが用いられています。このフォーマットを知っておくと、パターンカタログを読む際に内容を理解しやすくなります。主要な構成要素は以下の通りです。

- **パターン名 (Pattern Name) と分類 (Classification):** パターンを識別するための名前と、そのパターンが属する分類（生成、構造、振る舞いなど）。名前はパターンに関する語彙の中核となります。
- **目的 (Intent):** そのパターンが**何を目的としているのか**、**どのような設計課題を解決するのか**を簡潔に述べたもの。パターンの核心を一文で理解するための要約です。
- **動機 (Motivation):** パターンが解決しようとする具体的な**問題シナリオ**と、パターンを適用することでその問題がどのように解決されるかを示す例。パターンの必要性を理解する上で重要です。
- **適用可能性 (Applicability):** そのパターンが**どのような状況で有効に利用できるか**を示す具体的な条件。パターンを選択する際の判断基準となります。
- **構造 (Structure):** パターンを構成するクラスやオブジェクト、それらの役割と関係性を図（通常は UML クラス図など）で示したもの。パターンの静的な構造を理解するのに役立ちます。
- **登場人物 (Participants):** パターンの構造図に登場するクラスやオブジェクトが、それぞれどのような**役割や責務**を持っているかの説明。
- **協調 (Collaborations):** パターンの登場人物たちが、**どのように相互作用し、連携して**目的を達成するかの説明。パターンの動的な振る舞いを理解するのに役立ちます。
- **結果 (Consequences):** そのパターンを適用することによって得られる**利点（メリット）**と、考慮すべき**欠点やトレードオフ（デメリット）**。パターン採用の判断において非常に重要です。
- **実装 (Implementation):** パターンを実装する際に考慮すべき点、言語固有のヒント、実装上の注意点など。
- **サンプルコード (Sample Code):** パターンがどのようにコードで実現されるかを示す具体的な例。
- **既知の利用例 (Known Uses):** 実際のソフトウェアやフレームワークで、そのパターンがどのように利用されているかの実例。
- **関連するパターン (Related Patterns):** そのパターンと関連性の深い、あるいは比較対象となる他のパターン。パターン間の関係性を理解するのに役立ちます。

すべてのパターン解説がこのフォーマットに厳密にしたがっているわけではありませんが、これらの要素を意識することで、各パターンの本質をより深く、体系的に理解できます。

## 2.2 パターンの分類：目的と重要度による整理

デザインパターンは数多く存在するため、それらを理解しやすくするために、いくつかの観点から分類されています。

### 2.2.1 GoF による 3 つの分類：生成・構造・振る舞い

もっとも古典的で広く知られているのが、GoF による目的別の分類です。

- **生成に関するパターン (Creational Patterns)**  
  オブジェクトの**生成プロセス**を扱います。どのようにオブジェクトが作られるかを柔軟にし、生成プロセスと利用側のコードを分離します。（例: Factory Method, Abstract Factory, Builder, Prototype, Singleton）
- **構造に関するパターン (Structural Patterns)**  
  クラスやオブジェクトを**組み合わせて、より大きな構造を作る**方法を扱います。継承や委譲（コンポジション）を用いて、柔軟で効率的な構造を目指します。（例: Adapter, Bridge, Composite, Decorator, Facade, Flyweight, Proxy）
- **振る舞いに関するパターン (Behavioral Patterns)**  
  オブジェクト間の**責務の割り当て**、**アルゴリズム**、**相互作用**のパターンを扱います。オブジェクト同士がどのように連携・協調するかを定義します。（例: Chain of Responsibility, Command, Interpreter, Iterator, Mediator, Memento, Observer, State, Strategy, Template Method, Visitor）

この分類は、パターンの大まかな目的を理解するのに役立ちます。

### 2.2.2 実践的な分類：Core, Creation, Peripheral, Other

GoF の分類に加えて、実際の開発現場での利用頻度や重要度を考慮した、より実践的な分類も参考になります。（参考: Joshua Kerievsky 氏の記事など）

- **Core パターン (中心となるパターン)**  
  日常的なオブジェクト指向開発で**頻繁に利用され、基本となる**パターン群。コードの柔軟性や保守性を高める上で直接的に役立ちます。  
  （例: Strategy, Template Method, Iterator, Composite, Facade, Proxy, State, Command など）
- **Creation パターン (生成に関するパターン)**  
  オブジェクトの**生成**に特化したパターン群。GoF の生成パターンの一部と、DI など現代的に重要な概念を含みます。  
  （例: Factory Method, Builder, Prototype, Dependency Injection など）
- **Peripheral パターン (周辺的なパターン)**  
  Core や Creation ほど頻繁ではないものの、**特定の設計問題を解決するために有用**なパターン群。必要に応じて学ぶと良いでしょう。  
  （例: Decorator, Observer, Visitor, Mediator, Adapter など）
- **Other パターン (その他のパターン)**  
  上記以外のパターンや、特定の文脈（例: 並行処理、分散システム）で使われるパターン。

この資料では、とくに **Core パターン** と **Creation パターン** を中心に紹介します。これらをマスターすることが、オブジェクト指向設計スキル向上のための重要な基礎となります。

### 2.2.3 なぜ分類を知ることが役立つのか？

パターンの分類を知っておくことには、以下のような利点があります。

- **全体像の把握:** 数多くのパターンが、どのような目的や性質を持っているのか、その全体像を把握しやすくなります。
- **パターンの選択支援:** 解決したい設計課題がどのカテゴリ（生成、構造、振る舞い）に属するかを考えることで、適切なパターンを見つけやすくなります。
- **学習の道しるべ:** どのパターンから学ぶべきか、学習の優先順位をつける際の参考になります（例: まずは Core パターンから）。

次の章では、これらのパターンを学ぶ上での心構えや、効果的な学習方法について見ていきます。

---

# 3. デザインパターンを学ぶ上での心構えとヒント

デザインパターンは、より良いソフトウェア設計のための強力な武器となり得ますが、その知識を効果的に活用するためには、いくつかの心構えと学習のヒントを知っておくことが重要です。パターンを単なる知識として詰め込むのではなく、実践的なスキルとして身につけるためのポイントを見ていきましょう。

## 3.1 パターンは「銀の弾丸」ではない：適用する目的を見失わない

まずもっとも大切なことは、**デザインパターンは万能の解決策（銀の弾丸）ではない**、と理解することです。パターンを知っているからといって、あらゆる問題に無理やりパターンを当てはめようとするのは間違いです。

パターンを適用すること自体が目的になってしまうと、

- **過剰な設計 (Over-engineering):** 本来はシンプルな解決策で十分なところに、不必要に複雑なパターンを導入してしまう。
- **誤った適用:** パターンが意図していない問題に対して適用してしまい、かえってコードを分かりにくくしたり、保守性を低下させたりする。

といった弊害を生む可能性があります。

デザインパターンは、あくまで**特定の設計問題を解決するための「手段」**です。常に「**なぜこのパターンを使うのか？**」「**これによって本当に解決したい問題は何か？**」「**パターンを導入することで得られるメリットは、複雑さの増加というコストに見合うか？**」という問いを自問自答し、**本来の目的**を見失わないようにしましょう。

## 3.2 シンプルさを忘れずに：パターン中毒を避ける (YAGNI, KISS)

前項とも関連しますが、設計においては常に**シンプルさ**を心がけることが基本です。

- **KISS (Keep It Simple, Stupid):** 「シンプルにしておけ、余計なことをするな」という原則です。まずは要求を満たす、もっとも単純で直接的な方法を考えましょう。
- **YAGNI (You Ain't Gonna Need It):** 「（将来）必要になるかもしれない」という予測だけで、複雑な機能や設計（パターン適用を含む）を前もって実装するのはやめましょう、という原則です。本当に必要になったときに、リファクタリングなどによって対応すれば十分な場合が多いです。

デザインパターンを学び始めると、さまざまなパターンを使ってみたくなるかもしれません。しかし、「ハンマーを持つとすべてが釘に見える」状態、いわゆる「**パターン中毒 (Pattern Happy / Pattern Obsessed)**」に陥らないように注意が必要です。パターンは必要に応じて適用するものであり、シンプルさを犠牲にしてまで導入すべきではありません。

## 3.3 「問題」からパターンを探す視点：解決したい課題は何か？

デザインパターンを学ぶ際には、パターンのカタログ（名前や構造）から入るだけでなく、「**どのような設計上の『問題』を解決したいのか？**」という視点を持つことが非常に重要です。

日々の開発で直面する設計上の課題、たとえば、

- 「ここの `if-else` が複雑すぎる…」
- 「このクラス、変更の影響範囲が広すぎる…」
- 「オブジェクトの作り方が一貫しない…」
- 「この処理、他の場所でも再利用したい…」

といった具体的な「問題」や「コードの不吉な臭い」を認識し、「**この問題を解決するために使えるパターンはないだろうか？**」と考えるアプローチが、パターンの実践的な理解と適切な選択につながります。問題解決の手段としてパターンを探すことで、パターンを使うこと自体が目的化するのを防ぐことができます。

## 3.4 パターン選択の難しさ：比較検討とトレードオフの理解

ある設計問題に対して、適用できそうなパターンが複数存在する場合もあります。たとえば、「振る舞いを切り替えたい」という問題に対して、Strategy パターンと State パターンのどちらを使うべきか、といった状況です。

このような場合、**各パターンの意図、構造、そして結果（メリットとデメリット、トレードオフ）を正確に理解し、比較検討する**ことが重要になります。

- それぞれのパターンが解決しようとしている問題の**本質的な違い**は何か？
- それぞれのパターンを適用した場合の**クラス構造の複雑さ**はどうなるか？
- **将来的な変更の可能性**を考慮した場合、どちらがより柔軟に対応できるか？
- **パフォーマンス**への影響はどうか？

単純に「どちらが優れているか」ではなく、「**現在の状況と目的に対して、どちらがより『適切』か**」という視点で判断する必要があります。この判断力は、経験を積むことで徐々に養われていきます。

## 3.5 チームでの共通言語としての活用と注意点

デザインパターンは、チーム内の**コミュニケーションを円滑にする共通言語**として非常に有効です。設計について議論する際に、「ここでは Observer パターンを使おう」と言えば、多くの情報を効率的に伝えることができます。

しかし、この共通言語が機能するためには、**チームメンバー間でパターンに対する共通の理解**が必要です。もし知識レベルに差がある場合、パターン名をただ使うだけでは意図が伝わらなかったり、誤解を生んだりする可能性もあります。

チームでデザインパターンを活用する際には、

- パターンについて学ぶ機会を設ける。
- 設計レビューなどで、なぜそのパターンを選択したのか、その意図を説明し、認識を合わせる。
- チーム内でよく使うパターンや、特定の状況で推奨されるパターンについて、ある程度の共通認識やガイドラインを持つ。

といった配慮が有効です。

## 3.6 実践とリファクタリングを通じた習得

最終的に、デザインパターンを本当に理解し、使いこなせるようになるためには、**実践**が不可欠です。

- **学んだパターンを実際に使ってみる:** 小さな機能や個人の学習プロジェクトでも構いません。実際にコードに落とし込んでみることで、理解が深まります。
- **リファクタリングで適用する:** 既存のコードを改善する過程で、「ここにあのパターンを適用できるかもしれない」と考えて試してみることは、非常に効果的な学習方法です。リファクタリングを通じて、パターンがどのようにコードを改善するのかを体感できます。
- **コードレビューで学ぶ:** 他の人が書いたパターン適用の例を見たり、自分のコードに対してパターン適用の観点からフィードバックをもらったりすることで、実践的な知見が得られます。

デザインパターンの学習は、知識のインプットと実践のアウトプットを繰り返すことで、徐々にスキルとして定着します。焦らず、継続的に取り組んでいきましょう。

次の章では、いよいよ代表的なデザインパターンを、「どんな問題を解決するのか？」という視点から紹介します。

---

# 4. 代表的なパターン紹介：どんな問題を解決するのか？

この章では、第 2 章で紹介した分類に基づき、代表的なデザインパターンをいくつか取り上げます。ここでは各パターンの詳細な解説（構造や実装例）には深入りせず、**「そのパターンが、いったいどのような設計上の『悩み』や『問題』を解決するために役立つのか？」** という点に焦点を当てて紹介します。

それぞれのパターンについて、「こんなことで困っていませんか？」という問題提起を通じて、パターンの存在意義と目的を理解することを最初の目標とします。詳細な解決策や使い方については、各項目で示す「詳細解説資料」を参照してください。

---

## 【Core パターン編】

まずは、日々の開発で頻繁に遭遇し、オブジェクト指向設計の基本となる Core パターンから見ていきましょう。

---

### 4.1 [振る舞い] アルゴリズムを交換可能にしたい (Strategy パターン)

#### 4.1.1 こんな問題ありませんか？ (Problem の紹介)

- 「支払い方法をクレジットカード、銀行振込、代引きで切り替えたい」
- 「データのソート方法を、状況に応じてクイックソートやマージソートから選びたい」
- 「ユーザーの種類（無料会員、有料会員）によって、適用する割引計算ルールを変えたい」

このように、**同じ目的を達成するための「やり方（アルゴリズム、戦略）」が複数あり、それをプログラム実行中や設定によって柔軟に切り替えたい**、ということはよくあります。

しかし、これを素直に `if-else` や `switch` で実装すると、新しい「やり方」が増えるたびに条件分岐を修正する必要があり、コードがどんどん複雑になってしまいます。また、アルゴリズムの選択ロジックと、それを利用する側の本来の処理が混ざり合ってしまい、見通しも悪くなりがちです。

#### 4.1.2 👉 解決策の詳細は「デザインパターン詳細解説：Strategy パターン」へ

この問題をエレガントに解決するのが **Strategy パターン** です。アルゴリズムをオブジェクトとして独立させ、交換可能にする方法について、詳細は別資料で確認してください。

[デザインパターン詳細解説：Strategy パターン](デザインパターン/デザインパターン詳細解説：Strategyパターン.md)

---

### 4.2 [振る舞い] 処理の骨組みを固定し、一部だけ変えたい (Template Method パターン)

#### 4.2.1 こんな問題ありませんか？ (Problem の紹介)

- 「レポートを生成する手順は、データ取得 → 加工 → 整形 → 出力、と決まっているが、データの取得方法や加工方法だけがレポートの種類によって違う」
- 「Web アプリケーションのリクエスト処理の流れ（認証 → 入力検証 → 業務処理 → レスポンス生成）は共通化したいが、業務処理の部分だけは各機能で実装したい」
- 「複数のクラスで、ほとんど同じような処理の流れのコードが重複して書かれている」

このように、**ある処理を行う際の「大まかな手順（アルゴリズムの骨組み）」は共通しているが、その中の「特定のステップ」だけが状況によって異なる**、というケースがあります。共通部分をあちこちにコピー＆ペーストすると、修正があったときに大変です。

#### 4.2.2 👉 解決策の詳細は「デザインパターン詳細解説：Template Method パターン」へ

この問題を解決し、処理の骨組みを共通化しつつ部分的なカスタマイズを可能にするのが **Template Method パターン** です。継承を利用してこれを実現する方法について、詳細は別資料で確認してください。

[デザインパターン詳細解説：Template Method パターン](<デザインパターン/デザインパターン詳細解説：Template Methodパターン.md>)

---

### 4.3 [振る舞い] コレクションの中身を隠してアクセスしたい (Iterator パターン)

#### 4.3.1 こんな問題ありませんか？ (Problem の紹介)

- 「リストや配列、自作のデータ構造など、さまざまな『データの集まり（コレクション）』があるが、それぞれの中身を順番に見ていく方法がバラバラで使いにくい」
- 「コレクションを利用する側には、その内部が配列なのかリストなのか、といった実装の詳細を知られたくない」
- 「コレクションの要素を順番に処理するロジックを、コレクション本体のクラスから分離したい」

プログラムでは、データの集まりを扱うことが非常に多いですが、その内部構造に依存した形で要素にアクセスするコードを書いていると、コレクションの種類が変わったときに修正が必要になり、柔軟性が失われます。

#### 4.3.2 👉 解決策の詳細は「デザインパターン詳細解説：Iterator パターン」へ

この問題を解決し、コレクションの内部構造にかかわらず、統一的な方法で要素に順番にアクセスできるようにするのが **Iterator パターン** です。多くの言語の標準ライブラリでも使われている重要なパターンです。詳細は別資料で確認してください。

[デザインパターン詳細解説：Iterator パターン](デザインパターン/デザインパターン詳細解説：Iteratorパターン.md)

---

### 4.4 [構造] 「部分」と「全体」を同じように扱いたい (Composite パターン)

#### 4.4.1 こんな問題ありませんか？ (Problem の紹介)

- 「ファイルシステムのディレクトリ（ファイルや他のディレクトリを含む）とファイル（末端）を、同じように扱って再帰的に処理したい」
- 「GUI の部品（ボタンなど）と、部品をまとめる容器（パネルなど）を、区別せずに描画やイベント処理を行いたい」
- 「組織図のように、部署（部下や他の部署を含む）と個々の従業員を、階層構造として統一的に扱いたい」

このように、**個別の要素（葉: Leaf）**と、**それらをまとめたグループ（枝: Composite）**が混在する**木構造（ツリー構造）**を扱う際に、葉と枝で処理を `if` 文などで分けていると、コードが複雑になりがちです。

#### 4.4.2 👉 解決策の詳細は「デザインパターン詳細解説：Composite パターン」へ

この問題を解決し、葉と枝を同じインターフェースで透過的に扱えるようにするのが **Composite パターン** です。再帰的な構造をシンプルに表現・操作する方法について、詳細は別資料で確認してください。

[デザインパターン詳細解説：Composite パターン](デザインパターン/デザインパターン詳細解説：Compositeパターン.md)

---

### 4.5 [構造] 複雑なシステムを簡単な窓口で使いたい (Facade パターン)

#### 4.5.1 こんな問題ありませんか？ (Problem の紹介)

- 「利用したいライブラリやサブシステムの内部が非常に複雑で、たくさんのクラスやメソッドを正しい順序で呼び出す必要があり、使うのが大変だ」
- 「システムの内部構造を、利用する側（クライアント）から隠蔽したい」
- 「よく使われる一連の操作を、もっと簡単な手順で実行できるようにしたい」

複雑なシステムを直接利用しようとすると、利用側のコードが複雑になり、システム内部への依存度も高まってしまいます。

#### 4.5.2 👉 解決策の詳細は「デザインパターン詳細解説：Facade パターン」へ

この問題を解決し、複雑なサブシステムに対してシンプルで分かりやすい**統一的な窓口**を提供するのが **Facade パターン** です。システムの利用を簡単にし、疎結合を促進する方法について、詳細は別資料で確認してください。

[デザインパターン詳細解説：Facade パターン](デザインパターン/デザインパターン詳細解説：Facadeパターン.md)

---

### 4.6 [構造] オブジェクトへのアクセスを制御したい (Proxy パターン)

#### 4.6.1 こんな問題ありませんか？ (Problem の紹介)

- 「オブジェクトの生成にすごく時間がかかるので、本当に必要になるまで作りたくない（**遅延初期化**）」
- 「ユーザーの権限によって、オブジェクトの特定の操作を許可したり禁止したりしたい（**アクセス制御**）」
- 「ネットワーク越しにあるオブジェクトを、まるでローカルにあるかのように使いたい（**リモートアクセス**）」
- 「オブジェクトのメソッドが呼ばれる前後に、ログを記録するなどの**追加処理**を入れたい」

オブジェクトに直接アクセスする代わりに、何らかの**間接的な処理や制御**を加えたい、という要求はさまざまあります。

#### 4.6.2 👉 解決策の詳細は「デザインパターン詳細解説：Proxy パターン」へ

この問題を解決するために、本物のオブジェクトの「**代理人**」を立ててアクセスを仲介させるのが **Proxy パターン** です。さまざまな種類の Proxy がどのようにアクセスを制御・代替するのか、詳細は別資料で確認してください。

[デザインパターン詳細解説：Proxy パターン](デザインパターン/デザインパターン詳細解説：Proxyパターン.md)

---

### 4.7 [振る舞い] オブジェクトの状態に応じて振る舞いを変えたい (State パターン)

#### 4.7.1 こんな問題ありませんか？ (Problem の紹介)

- 「自動販売機の状態（待機中、金額投入済み、売り切れなど）によって、ボタンを押したときの動作が変わるのを、`if-else` だらけにならずに実装したい」
- 「ネットワーク接続の状態（接続中、切断、エラー）に応じて、データの送受信処理の挙動を変えたい」
- 「オブジェクトが取りうる『状態』が多く、状態遷移のルールも複雑で、管理が大変だ」

オブジェクトの内部状態によって振る舞いが大きく変わる場合、そのロジックを 1 つのクラス内に条件分岐で実装すると、非常に複雑で保守しにくいコードになりがちです。

#### 4.7.2 👉 解決策の詳細は「デザインパターン詳細解説：State パターン」へ

この問題を解決し、状態とその状態における振る舞いを独立したオブジェクトとして扱い、状態遷移を管理しやすくするのが **State パターン** です。振る舞いを状態オブジェクトに委譲する方法について、詳細は別資料で確認してください。

[デザインパターン詳細解説：State パターン](デザインパターン/デザインパターン詳細解説：Stateパターン.md)

---

### 4.8 [振る舞い] 操作をオブジェクトとして扱いたい (Command パターン)

#### 4.8.1 こんな問題ありませんか？ (Problem の紹介)

- 「GUI の『元に戻す (Undo)』機能を実装したい」
- 「一連の操作を記録して、あとでまとめて実行（マクロ）したり、順番を入れ替えたりしたい」
- 「操作の要求だけをキューに溜めておいて、別のスレッドで非同期に実行したい」
- 「ボタンやメニュー項目といった『要求元』と、実際に処理を実行する『実行者』を分離したい」

単にメソッドを呼び出すだけでなく、その「**操作（コマンド）**」自体をオブジェクトとして扱えると、上記のような柔軟な操作管理が可能になります。

#### 4.8.2 👉 解決策の詳細は「デザインパターン詳細解説：Command パターン」へ

この問題を解決するために、操作要求に関する情報をオブジェクトとしてカプセル化するのが **Command パターン** です。操作の実行、取り消し、キューイングなどを実現する方法について、詳細は別資料で確認してください。

[デザインパターン詳細解説：Command パターン](デザインパターン/デザインパターン詳細解説：Commandパターン.md)

---

## 【Creation パターン編】

次に、オブジェクトの「生成」プロセスに関わる Creation パターンの中から、代表的なものを紹介します。オブジェクトをどのように作るかは、ソフトウェアの柔軟性や保守性に大きな影響を与えます。

---

### 4.9 [生成] どのクラスを作るか、サブクラスに任せたい (Factory Method パターン)

#### 4.9.1 こんな問題ありませんか？ (Problem の紹介)

- 「アプリケーションフレームワークを作っていて、フレームワーク利用者が独自にカスタマイズしたオブジェクトを生成できるようにしたい」
- 「ログ出力先（コンソール、ファイル、DB）に応じて、異なる種類の Logger オブジェクトを生成したいが、利用側コードは具体的な Logger クラスを知りたくない」
- 「オブジェクトを生成する際に、どの具体的なクラスのインスタンスを作るかの決定を、利用する側（スーパークラス）ではなく、それを拡張する側（サブクラス）に委ねたい」

オブジェクトを生成するクラスが、生成されるオブジェクトの具体的なクラス名に依存してしまうと、新しい種類のオブジェクトを追加する際に、生成側のクラスも修正する必要が出てきてしまいます。

#### 4.9.2 👉 解決策の詳細は「デザインパターン詳細解説：Factory Method パターン」へ

この問題を解決し、オブジェクト生成の責任をサブクラスに委譲（遅延）するのが **Factory Method パターン** です。インスタンス化の判断をサブクラスに任せる方法について、詳細は別資料で確認してください。

[デザインパターン詳細解説：Factory Method パターン](<デザインパターン/デザインパターン詳細解説：Factory Methodパターン.md>)

---

### 4.10 [生成] 複雑なオブジェクトを段階的に作りたい (Builder パターン)

#### 4.10.1 こんな問題ありませんか？ (Problem の紹介)

- 「ユーザー設定オブジェクトを作るのに、コンストラクタの引数が 10 個もあって、どれがどの設定か分かりにくいし、間違いやすい」
- 「多くのオプション項目を持つオブジェクトを生成したいが、Setter メソッドをたくさん呼び出すのは面倒だし、設定途中の不完全な状態で使われてしまうのが心配だ」
- 「一度生成したら値が変わらない『不変（Immutable）』なオブジェクトを、安全かつ分かりやすく生成したい」

多くのパーツや設定項目から構成される複雑なオブジェクトを、コンストラクタや Setter だけで扱おうとすると、コードが読みにくくなったり、安全性が損なわれたりすることがあります。

#### 4.10.2 👉 解決策の詳細は「デザインパターン詳細解説：Builder パターン」へ

この問題を解決し、複雑なオブジェクトの**構築プロセス**を、その表現から分離し、ステップ・バイ・ステップで安全に生成できるようにするのが **Builder パターン** です。読みやすく、柔軟なオブジェクト構築方法について、詳細は別資料で確認してください。

[デザインパターン詳細解説：Builder パターン](デザインパターン/デザインパターン詳細解説：Builderパターン.md)

---

### 4.11 [生成] コピーしてオブジェクトを作りたい (Prototype パターン)

#### 4.11.1 こんな問題ありませんか？ (Problem の紹介)

- 「データベースから読み込んだ設定情報など、生成にコストがかかるオブジェクトがあり、毎回生成するのではなく、一度作ったものをコピーして使いたい」
- 「たくさんの種類のオブジェクトがあり、それぞれに合わせた `new ClassName()` を書くのが煩雑だ。既存の『見本』をコピーするだけで新しいオブジェクトを作れないか？」
- 「特定の状態を持つオブジェクトのインスタンスを、複数、効率的に生成したい」

クラスから `new` でインスタンス化する以外の方法でオブジェクトを生成したい、とくに**既存のオブジェクトを複製**したい場合に有効な方法が求められます。

#### 4.11.2 👉 解決策の詳細は「デザインパターン詳細解説：Prototype パターン」へ

この問題を解決するために、**複製元となるオブジェクト自身にコピー機能を持たせる**のが **Prototype パターン** です。`clone()` メソッド等を利用して効率的にインスタンスを生成する方法について、詳細は別資料で確認してください。

[デザインパターン詳細解説：Prototype パターン](デザインパターン/デザインパターン詳細解説：Prototypeパターン.md)

---

### 4.12 [原則] 依存関係を疎にしてテストしやすくしたい (Dependency Injection: DI)

#### 4.12.1 こんな問題ありませんか？ (Problem の紹介)

- 「クラス A がクラス B を内部で `new` しているので、クラス A のユニットテストをするときに、本物のクラス B が動いてしまい、テストがしにくい」
- 「データベース接続の処理を、テストの時だけファイルアクセスに差し替えたいが、コードの修正が必要になってしまう」
- 「クラス間の依存関係が複雑に絡み合っていて、変更の影響範囲が分かりにくい」

クラスが必要な「部品（依存オブジェクト）」を自身で直接生成・管理していると、クラス間の結合度が高くなり、テスト容易性や柔軟性が損なわれがちです。

#### 4.12.2 👉 解決策の詳細は「デザインパターン詳細解説：Dependency Injection」へ

この問題を解決するための重要な**設計原則でありテクニック**が **Dependency Injection (DI)** です。クラスが必要とする依存オブジェクトを**外部から注入する**ことで、クラス間の**疎結合**を実現し、**テスト容易性**や**柔軟性**を劇的に向上させる方法について、詳細は別資料で確認してください。（DI は厳密には GoF パターンではありませんが、生成・依存関係の文脈で極めて重要です）

[デザインパターン詳細解説：Dependency Injection](<デザインパターン/デザインパターン詳細解説：Dependency Injection.md>)

---

## 【Peripheral パターン編（一部紹介）】

Core パターンや Creation パターンほど頻繁ではありませんが、特定の設計問題を解決するために知っておくと役立つパターンも存在します。ここではその一部を紹介します。

---

### 4.13 [構造] 動的に機能を追加したい (Decorator パターン)

#### 4.13.1 こんな問題ありませんか？ (Problem の紹介)

- 「テキストビューにスクロールバーや枠線を、後から自由に追加・削除できるようにしたい」
- 「機能の組み合わせ（例: 暗号化＋圧縮）ごとにサブクラスを作っていたら、クラス数が大変なことになってしまった」

既存のオブジェクトの**中身を変更せずに**、**実行時に**機能（装飾）を**動的に追加**していきたい、という要求があります。継承では、組み合わせの数が多くなると対応が困難です。

#### 4.13.2 👉 解決策の詳細は「デザインパターン詳細解説：Decorator パターン」へ

この問題を解決し、オブジェクトを「飾り付け」するように機能を追加するのが **Decorator パターン** です。詳細は別資料で確認してください。

[デザインパターン詳細解説：Decorator パターン](デザインパターン/デザインパターン詳細解説：Decoratorパターン.md)

---

### 4.14 [振る舞い] オブジェクト間の複雑なやりとりを仲介したい (Mediator パターン)

#### 4.14.1 こんな問題ありませんか？ (Problem の紹介)

- 「ダイアログの複数の部品（ボタン、リスト、テキスト欄）が、互いに直接状態を参照したり、メソッドを呼び出したりしていて、関係が複雑すぎる」
- 「あるオブジェクトを変更したら、他のたくさんのオブジェクトに影響が及んでしまう。依存関係を整理したい」

多くのオブジェクトが互いに直接通信し合うと、システム全体の**結合度が高く**なり、変更や保守が困難になります。

#### 4.14.2 👉 解決策の詳細は「デザインパターン詳細解説：Mediator パターン」へ

この問題を解決するために、オブジェクト間のコミュニケーションを**一元管理する「調停者」**を導入するのが **Mediator パターン** です。詳細は別資料で確認してください。

[デザインパターン詳細解説：Mediator パターン](デザインパターン/デザインパターン詳細解説：Mediatorパターン.md)

---

### 4.15 [その他] オブジェクトの「種類」をデータとして扱いたい (Type Object パターン)

#### 4.15.1 こんな問題ありませんか？ (Problem の紹介)

- 「ゲームに登場するモンスターの種類が数百種類あり、それぞれクラスを作るのは大変だ」
- 「アイテムの種類やパラメータを、実行時に設定ファイルやデータベースから読み込んで動的に定義したい」
- 「同じ種類のオブジェクト（例: スライム）が共通して持つ基本データ（HP, 攻撃力）を、インスタンスごとではなく『種類』レベルで管理したい」

オブジェクトの「種類」自体を、クラス定義ではなく、**データとして柔軟に扱いたい**場合があります。

#### 4.15.2 👉 解決策の詳細は「デザインパターン詳細解説：Type Object パターン」へ

この問題を解決するために、「型」情報を別のオブジェクトとして定義・管理する **Type Object パターン** が有効です。詳細は別資料で確認してください。

[デザインパターン詳細解説：Type Object パターン](<デザインパターン/デザインパターン詳細解説：Type Objectパターン.md>)

---

### 4.16 [その他] 「何もない」ことをオブジェクトで表現したい (Null Object パターン)

#### 4.16.1 こんな問題ありませんか？ (Problem の紹介)

- 「メソッドが `null` を返す可能性があり、呼び出し側で毎回 `if (result != null)` のようなチェックが必要でコードが冗長だ」
- 「`null` チェックを忘れて `NullPointerException` が発生してしまうのを防ぎたい」
- 「オブジェクトが存在しない場合に『何もしない』というデフォルトの振る舞いをさせたいが、そのための `if` 文をあちこちに書きたくない」

`null` 参照の扱いは、しばしばコードの複雑性やバグの原因となります。

#### 4.16.2 👉 解決策の詳細は「デザインパターン詳細解説：Null Object パターン」へ

この問題を解決するために、`null` の代わりに「何もしない」特別なオブジェクトを返す **Null Object パターン** が有効です。詳細は別資料で確認してください。

[デザインパターン詳細解説：Null Object パターン](<デザインパターン/デザインパターン詳細解説：Null Objectパターン.md>)

---

# 5. おわりに：デザインパターンの学習を続けよう

この「デザインパターン入門」資料では、ソフトウェア設計におけるデザインパターンの基本的な役割とメリット、分類、そして代表的なパターンがどのような問題を解決するのか、その入り口を見てきました。

## 5.1 設計の「引き出し」を増やすことの価値

デザインパターンは、過去のエンジニアたちが積み重ねてきた設計上の知恵であり、私たちがより良いソフトウェアを効率的に構築するための「**定石**」や「**思考の道具**」です。

パターンを知ることで、

- ゼロから設計を考えるのではなく、**実績のある解決策**を参考にできる。
- コードの**再利用性、保守性、拡張性**を高める具体的な方法論を学べる。
- チーム内で**設計に関する共通言語**を持つことができ、コミュニケーションが円滑になる。
- 既存のコードやフレームワークの**設計意図を理解する**助けになる。

といった多くの利点があります。デザインパターンを学ぶことは、皆さんのソフトウェア設計における「**引き出し**」を増やし、より多様な課題に対して、より洗練されたアプローチを選択できるようになることを意味します。

## 5.2 詳細解説資料や参考文献へ

この入門資料では、各パターンの「解決したい問題」を中心に紹介し、詳細な解説は別資料（「**デザインパターン詳細解説：〇〇パターン**」）に譲る形を取りました。

今回紹介したパターンの中で、

- 「このパターン、今自分が悩んでいる問題に役立ちそうだ」
- 「このパターンの具体的な仕組みをもっと知りたい」

と感じたものがあれば、ぜひ対応する**詳細解説資料**を読み進めてみてください。そこでは、パターンの構造、実装例、利点と注意点などが、より詳しく解説されています。

また、GoF の『オブジェクト指向における再利用のためのデザインパターン 改訂版』をはじめ、世の中にはデザインパターンに関する優れた書籍やオンラインリソースが数多く存在します。これらの**参考文献**にあたることも、理解を深める上で非常に有効です。

## 5.3 継続的な学習と実践の勧め

デザインパターンの学習は、一度資料を読んだら終わり、というものではありません。

- **知識の定着:** まずは基本的なパターンの名前、目的、解決する問題を覚え、カタログとして頭に入れておくことが第一歩です。
- **実践での適用:** 次に重要なのは、実際の開発の中で、学んだパターンを意識的に適用してみることです。「この場面では Strategy パターンが使えそうだ」「ここは Facade で単純化できるかもしれない」と考えて試してみる経験が、知識をスキルへと昇華させます。
- **リファクタリング:** 既存のコードを改善するリファクタリングの過程で、デザインパターンを適用することも効果的な学習方法です。
- **コードリーディング:** フレームワークやライブラリのコードを読む中で、パターンがどのように使われているかを発見し、学ぶことも有効です。
- **議論と共有:** チーム内で設計について議論する際にパターンを使ったり、自分が適用したパターンについて説明したりすることで、理解が深まります。

デザインパターンは、経験を積むほどにその価値や使いどころが分かってくる奥深い分野です。焦らず、しかし着実に、**継続的な学習と実践**を続けることが、皆さんの設計スキルを向上させるための王道です。

この入門資料が、皆さんのデザインパターン学習のきっかけとなり、より良いソフトウェア設計への探求心を刺激することができれば幸いです。
